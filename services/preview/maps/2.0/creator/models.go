package creator

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"io"
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
)

// The package's fully qualified name.
const fqdn = "github.com/v-ddaian/azure-sdk-for-go/services/preview/maps/2.0/creator"

            // AliasesCreateResponse the response model for the Alias Create API for the case when the alias was
            // successfully created.
            type AliasesCreateResponse struct {
            autorest.Response `json:"-"`
            // CreatedTimestamp - READ-ONLY; The created timestamp for the alias.
            CreatedTimestamp *string `json:"createdTimestamp,omitempty"`
            // AliasID - READ-ONLY; The id for the alias.
            AliasID *string `json:"aliasId,omitempty"`
            // CreatorDataItemID - READ-ONLY; The id for the creator data item that this alias references (could be null if the alias has not been assigned).
            CreatorDataItemID *string `json:"creatorDataItemId,omitempty"`
            // LastUpdatedTimestamp - READ-ONLY; The timestamp of the last time the alias was assigned.
            LastUpdatedTimestamp *string `json:"lastUpdatedTimestamp,omitempty"`
            }

            // AliasListItem detailed information for the alias.
            type AliasListItem struct {
            autorest.Response `json:"-"`
            // CreatedTimestamp - READ-ONLY; The created timestamp for the alias.
            CreatedTimestamp *string `json:"createdTimestamp,omitempty"`
            // AliasID - READ-ONLY; The id for the alias.
            AliasID *string `json:"aliasId,omitempty"`
            // CreatorDataItemID - READ-ONLY; The id for the creator data item that this alias references (could be null if the alias has not been assigned).
            CreatorDataItemID *string `json:"creatorDataItemId,omitempty"`
            // LastUpdatedTimestamp - READ-ONLY; The timestamp of the last time the alias was assigned.
            LastUpdatedTimestamp *string `json:"lastUpdatedTimestamp,omitempty"`
            }

            // AliasListResponse the response model for the List API. Returns a list of all the previously created
            // aliases.
            type AliasListResponse struct {
            autorest.Response `json:"-"`
            // Aliases - READ-ONLY; A list of all the previously created aliases.
            Aliases *[]AliasListItem `json:"aliases,omitempty"`
            // NextLink - READ-ONLY; If present, the location of the next page of data.
            NextLink *string `json:"nextLink,omitempty"`
            }

            // AliasListResponseIterator provides access to a complete listing of AliasListItem values.
            type AliasListResponseIterator struct {
                i int
                page AliasListResponsePage
            }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * AliasListResponseIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AliasListResponseIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * AliasListResponseIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter AliasListResponseIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter AliasListResponseIterator) Response() AliasListResponse {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter AliasListResponseIterator) Value() AliasListItem {
        if !iter.page.NotDone() {
        return AliasListItem{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the AliasListResponseIterator type.
        func NewAliasListResponseIterator (page AliasListResponsePage) AliasListResponseIterator {
        return AliasListResponseIterator{page: page}
        }


                // IsEmpty returns true if the ListResult contains no values.
                func (alr AliasListResponse) IsEmpty() bool {
                return alr.Aliases == nil || len(*alr.Aliases) == 0
                }

                // hasNextLink returns true if the NextLink is not empty.
                func (alr AliasListResponse) hasNextLink() bool {
                return alr.NextLink != nil && len(*alr.NextLink) != 0
                }
                    // aliasListResponsePreparer prepares a request to retrieve the next set of results.
                    // It returns nil if no more results exist.
                    func (alr AliasListResponse) aliasListResponsePreparer(ctx context.Context) (*http.Request, error) {
                    if !alr.hasNextLink() {
                    return nil, nil
                    }
                    return autorest.Prepare((&http.Request{}).WithContext(ctx),
                    autorest.AsJSON(),
                    autorest.AsGet(),
                    autorest.WithBaseURL(to.String( alr.NextLink)));
                    }

            // AliasListResponsePage contains a page of AliasListItem values.
            type AliasListResponsePage struct {
                fn func(context.Context, AliasListResponse) (AliasListResponse, error)
                alr AliasListResponse
            }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * AliasListResponsePage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/AliasListResponsePage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
        next, err := page.fn(ctx, page.alr)
        if err != nil {
        return err
        }
        page.alr = next
        if !next.hasNextLink() || !next.IsEmpty() {
        break
        }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * AliasListResponsePage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page AliasListResponsePage) NotDone() bool {
        return !page.alr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page AliasListResponsePage) Response() AliasListResponse {
        return page.alr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page AliasListResponsePage) Values() []AliasListItem {
        if page.alr.IsEmpty() {
        return nil
        }
        return *page.alr.Aliases
        }
        // Creates a new instance of the AliasListResponsePage type.
        func NewAliasListResponsePage (cur AliasListResponse, getNextPage func(context.Context, AliasListResponse) (AliasListResponse, error)) AliasListResponsePage {
        return AliasListResponsePage{
        fn: getNextPage,
        alr: cur,
        }
        }

            // BooleanRuleObject the boolean rule. The color is selected based on the logic value of the key.
            type BooleanRuleObject struct {
            // True - The color when value is true. Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255, 255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
            True *string `json:"true,omitempty"`
            // False - The color when value is false. Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255, 255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
            False *string `json:"false,omitempty"`
            }

            // BooleanTypeStyleRule the boolean type style rule object.
            type BooleanTypeStyleRule struct {
            // Rules - Boolean style rules.
            Rules *[]BooleanRuleObject `json:"rules,omitempty"`
            // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
            KeyName *string `json:"keyName,omitempty"`
            // Type - Possible values include: 'TypeStyleObject', 'TypeBoolean', 'TypeNumber', 'TypeString'
            Type Type `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for BooleanTypeStyleRule.
        func (btsr BooleanTypeStyleRule)MarshalJSON() ([]byte, error){
            btsr.Type = TypeBoolean
            objectMap := make(map[string]interface{})
                if(btsr.Rules != nil) {
                objectMap["rules"] = btsr.Rules
                }
                if(btsr.KeyName != nil) {
                objectMap["keyName"] = btsr.KeyName
                }
                if(btsr.Type != "") {
                objectMap["type"] = btsr.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleObject implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return &btsr, true
            }

            // AsNumberTypeStyleRule is the BasicStyleObject implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return nil, false
            }

            // AsStringTypeStyleRule is the BasicStyleObject implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return nil, false
            }

            // AsStyleObject is the BasicStyleObject implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsStyleObject() (*StyleObject, bool) {
                return nil, false
            }

                // AsBasicStyleObject is the BasicStyleObject implementation for BooleanTypeStyleRule.
                func(btsr BooleanTypeStyleRule) AsBasicStyleObject()(BasicStyleObject, bool) {
                    return &btsr, true
                }


            // BufferRequestBody an object with a FeatureCollection and a list of distances.  All the feature's
            // properties should contain `geometryId`, which is used for identifying the geometry and is
            // case-sensitive.
            type BufferRequestBody struct {
            Geometries *GeoJSONFeatureCollection `json:"geometries,omitempty"`
            // Distances - List of the distances to compute the buffer for, one-to-one per Feature in the collection, or one for all Features in the collection.
            Distances *[]float64 `json:"distances,omitempty"`
            }

            // BufferResponse this object is returned from a successful Spatial Buffer call.
            type BufferResponse struct {
            autorest.Response `json:"-"`
            // Summary - READ-ONLY; Summary of the call.
            Summary *BufferResponseSummary `json:"summary,omitempty"`
            // Result - The FeatureCollection of buffers for the input.
            Result *GeoJSONFeatureCollection `json:"result,omitempty"`
            }

        // MarshalJSON is the custom marshaler for BufferResponse.
        func (br BufferResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(br.Result != nil) {
                objectMap["result"] = br.Result
                }
                return json.Marshal(objectMap)
        }

            // BufferResponseSummary summary of the call.
            type BufferResponseSummary struct {
            // Udid - READ-ONLY; The udid for the user data if one exists
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; The information about what happened during the call.
            Information *string `json:"information,omitempty"`
            }

            // ClosestPointResponse this object is returned from a successful Spatial Closest Point call
            type ClosestPointResponse struct {
            autorest.Response `json:"-"`
            Summary *ClosestPointSummary `json:"summary,omitempty"`
            Result *[]ClosestPointResultEntry `json:"result,omitempty"`
            }

            // ClosestPointResultEntry closest Point Result Entry Object
            type ClosestPointResultEntry struct {
            // DistanceInMeters - READ-ONLY; The distance in meters from the source point to the closest point
            DistanceInMeters *float64 `json:"distanceInMeters,omitempty"`
            Position *SpatialCoordinate `json:"position,omitempty"`
            // GeometryID - READ-ONLY; The unique id identifies a geometry
            GeometryID *string `json:"geometryId,omitempty"`
            }

        // MarshalJSON is the custom marshaler for ClosestPointResultEntry.
        func (cpre ClosestPointResultEntry)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(cpre.Position != nil) {
                objectMap["position"] = cpre.Position
                }
                return json.Marshal(objectMap)
        }

            // ClosestPointSummary closest Point Summary object
            type ClosestPointSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; Processing information
            Information *string `json:"information,omitempty"`
            }

        // MarshalJSON is the custom marshaler for ClosestPointSummary.
        func (cps ClosestPointSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(cps.SourcePoint != nil) {
                objectMap["sourcePoint"] = cps.SourcePoint
                }
                return json.Marshal(objectMap)
        }

            // CollectionDefinitionResponse collection of GeoJSON features
            type CollectionDefinitionResponse struct {
            autorest.Response `json:"-"`
            // Description - describes the collection
            Description *string `json:"description,omitempty"`
            // IDPrefix - prefix of the collection used
            IDPrefix *string `json:"idPrefix,omitempty"`
            // Name - identifier of the collection used, for example, in URIs
            Name *string `json:"name,omitempty"`
            // Title - title of collection
            Title *string `json:"title,omitempty"`
            Ontology *string `json:"ontology,omitempty"`
            // GeometryType - type of geometry returned. Possible values include: 'GeoJSONGeometryTypeGeoJSONPoint', 'GeoJSONGeometryTypeGeoJSONMultiPoint', 'GeoJSONGeometryTypeGeoJSONLineString', 'GeoJSONGeometryTypeGeoJSONMultiLineString', 'GeoJSONGeometryTypeGeoJSONPolygon', 'GeoJSONGeometryTypeGeoJSONMultiPolygon', 'GeoJSONGeometryTypeGeoJSONGeometryCollection'
            GeometryType GeoJSONGeometryType `json:"geometryType,omitempty"`
            // FeatureTypes - type of features returned
            FeatureTypes *[]string `json:"featureTypes,omitempty"`
            // Properties - attributes of the collection used
            Properties *[]DefinitionProperties `json:"properties,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            }

            // CollectionInfo ...
            type CollectionInfo struct {
            autorest.Response `json:"-"`
            // Name - identifier of the collection used, for example, in URIs
            Name *string `json:"name,omitempty"`
            // Title - human readable title of the collection
            Title *string `json:"title,omitempty"`
            Ontology *string `json:"ontology,omitempty"`
            // Description - a description of the features in the collection
            Description *string `json:"description,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            }

            // CollectionsResponse ...
            type CollectionsResponse struct {
            autorest.Response `json:"-"`
            Ontology *string `json:"ontology,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            // Collections - All the collections in a given dataset.
            Collections *[]CollectionInfo `json:"collections,omitempty"`
            }

            // ConformanceResponse ...
            type ConformanceResponse struct {
            autorest.Response `json:"-"`
            // ConformsTo - List of requirements classes that the server conforms to.
            ConformsTo *[]string `json:"conformsTo,omitempty"`
            }

            // ConversionConvertFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type ConversionConvertFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(ConversionClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *ConversionConvertFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for ConversionConvertFuture.Result.
        func (future *ConversionConvertFuture) result(client ConversionClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "creator.ConversionConvertFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("creator.ConversionConvertFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.ConvertResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "creator.ConversionConvertFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // ConversionListDetailInfo detail information for the conversion requests.
            type ConversionListDetailInfo struct {
            autorest.Response `json:"-"`
            // ConversionID - READ-ONLY; A unique id that represents the artifact of a _successfully_ completed conversion process.
            ConversionID *string `json:"conversionId,omitempty"`
            Ontology *string `json:"ontology,omitempty"`
            // Udid - READ-ONLY; The unique id of the content provided to create this conversion.
            Udid *string `json:"udid,omitempty"`
            // Created - READ-ONLY; The date and time of this conversion.
            Created *string `json:"created,omitempty"`
            // Description - READ-ONLY; User provided description of the content being converted.
            Description *string `json:"description,omitempty"`
            // FeatureCounts - READ-ONLY; A summary of feature counts in this conversion.
            FeatureCounts interface{} `json:"featureCounts,omitempty"`
            }

        // MarshalJSON is the custom marshaler for ConversionListDetailInfo.
        func (cldi ConversionListDetailInfo)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(cldi.Ontology != nil) {
                objectMap["ontology"] = cldi.Ontology
                }
                return json.Marshal(objectMap)
        }

            // ConversionListResponse the response model for the Conversion List API.
            type ConversionListResponse struct {
            autorest.Response `json:"-"`
            // Conversions - READ-ONLY; A list of all the previously submitted conversion requests.
            Conversions *[]ConversionListDetailInfo `json:"conversions,omitempty"`
            // NextLink - READ-ONLY; If present, the location of the next page of data.
            NextLink *string `json:"nextLink,omitempty"`
            }

            // ConversionListResponseIterator provides access to a complete listing of ConversionListDetailInfo values.
            type ConversionListResponseIterator struct {
                i int
                page ConversionListResponsePage
            }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * ConversionListResponseIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionListResponseIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * ConversionListResponseIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter ConversionListResponseIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter ConversionListResponseIterator) Response() ConversionListResponse {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter ConversionListResponseIterator) Value() ConversionListDetailInfo {
        if !iter.page.NotDone() {
        return ConversionListDetailInfo{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the ConversionListResponseIterator type.
        func NewConversionListResponseIterator (page ConversionListResponsePage) ConversionListResponseIterator {
        return ConversionListResponseIterator{page: page}
        }


                // IsEmpty returns true if the ListResult contains no values.
                func (clr ConversionListResponse) IsEmpty() bool {
                return clr.Conversions == nil || len(*clr.Conversions) == 0
                }

                // hasNextLink returns true if the NextLink is not empty.
                func (clr ConversionListResponse) hasNextLink() bool {
                return clr.NextLink != nil && len(*clr.NextLink) != 0
                }
                    // conversionListResponsePreparer prepares a request to retrieve the next set of results.
                    // It returns nil if no more results exist.
                    func (clr ConversionListResponse) conversionListResponsePreparer(ctx context.Context) (*http.Request, error) {
                    if !clr.hasNextLink() {
                    return nil, nil
                    }
                    return autorest.Prepare((&http.Request{}).WithContext(ctx),
                    autorest.AsJSON(),
                    autorest.AsGet(),
                    autorest.WithBaseURL(to.String( clr.NextLink)));
                    }

            // ConversionListResponsePage contains a page of ConversionListDetailInfo values.
            type ConversionListResponsePage struct {
                fn func(context.Context, ConversionListResponse) (ConversionListResponse, error)
                clr ConversionListResponse
            }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * ConversionListResponsePage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionListResponsePage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
        next, err := page.fn(ctx, page.clr)
        if err != nil {
        return err
        }
        page.clr = next
        if !next.hasNextLink() || !next.IsEmpty() {
        break
        }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * ConversionListResponsePage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page ConversionListResponsePage) NotDone() bool {
        return !page.clr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page ConversionListResponsePage) Response() ConversionListResponse {
        return page.clr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page ConversionListResponsePage) Values() []ConversionListDetailInfo {
        if page.clr.IsEmpty() {
        return nil
        }
        return *page.clr.Conversions
        }
        // Creates a new instance of the ConversionListResponsePage type.
        func NewConversionListResponsePage (cur ConversionListResponse, getNextPage func(context.Context, ConversionListResponse) (ConversionListResponse, error)) ConversionListResponsePage {
        return ConversionListResponsePage{
        fn: getNextPage,
        clr: cur,
        }
        }

            // DatasetCreateFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DatasetCreateFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DatasetClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DatasetCreateFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DatasetCreateFuture.Result.
        func (future *DatasetCreateFuture) result(client DatasetClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "creator.DatasetCreateFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("creator.DatasetCreateFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.CreateResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "creator.DatasetCreateFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DatasetDetailInfo detail information for the dataset.
            type DatasetDetailInfo struct {
            autorest.Response `json:"-"`
            // Created - READ-ONLY; The created timestamp for the dataset.
            Created *string `json:"created,omitempty"`
            // DatasetID - READ-ONLY; The id for the dataset.
            DatasetID *string `json:"datasetId,omitempty"`
            Ontology *string `json:"ontology,omitempty"`
            // Description - READ-ONLY; The description for the dataset.
            Description *string `json:"description,omitempty"`
            DatasetSources *DatasetSources `json:"datasetSources,omitempty"`
            // FeatureCounts - READ-ONLY; The feature counts for the dataset.
            FeatureCounts interface{} `json:"featureCounts,omitempty"`
            }

        // MarshalJSON is the custom marshaler for DatasetDetailInfo.
        func (ddi DatasetDetailInfo)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ddi.Ontology != nil) {
                objectMap["ontology"] = ddi.Ontology
                }
                if(ddi.DatasetSources != nil) {
                objectMap["datasetSources"] = ddi.DatasetSources
                }
                return json.Marshal(objectMap)
        }

            // DatasetListResponse the response model for the Dataset List API. The response body will contain a list
            // of all the previously created datasets.
            type DatasetListResponse struct {
            autorest.Response `json:"-"`
            // Datasets - READ-ONLY; A list of all the previously created datasets.
            Datasets *[]DatasetDetailInfo `json:"datasets,omitempty"`
            // NextLink - READ-ONLY; If present, the location of the next page of data.
            NextLink *string `json:"nextLink,omitempty"`
            }

            // DatasetListResponseIterator provides access to a complete listing of DatasetDetailInfo values.
            type DatasetListResponseIterator struct {
                i int
                page DatasetListResponsePage
            }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * DatasetListResponseIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DatasetListResponseIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * DatasetListResponseIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter DatasetListResponseIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter DatasetListResponseIterator) Response() DatasetListResponse {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter DatasetListResponseIterator) Value() DatasetDetailInfo {
        if !iter.page.NotDone() {
        return DatasetDetailInfo{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the DatasetListResponseIterator type.
        func NewDatasetListResponseIterator (page DatasetListResponsePage) DatasetListResponseIterator {
        return DatasetListResponseIterator{page: page}
        }


                // IsEmpty returns true if the ListResult contains no values.
                func (dlr DatasetListResponse) IsEmpty() bool {
                return dlr.Datasets == nil || len(*dlr.Datasets) == 0
                }

                // hasNextLink returns true if the NextLink is not empty.
                func (dlr DatasetListResponse) hasNextLink() bool {
                return dlr.NextLink != nil && len(*dlr.NextLink) != 0
                }
                    // datasetListResponsePreparer prepares a request to retrieve the next set of results.
                    // It returns nil if no more results exist.
                    func (dlr DatasetListResponse) datasetListResponsePreparer(ctx context.Context) (*http.Request, error) {
                    if !dlr.hasNextLink() {
                    return nil, nil
                    }
                    return autorest.Prepare((&http.Request{}).WithContext(ctx),
                    autorest.AsJSON(),
                    autorest.AsGet(),
                    autorest.WithBaseURL(to.String( dlr.NextLink)));
                    }

            // DatasetListResponsePage contains a page of DatasetDetailInfo values.
            type DatasetListResponsePage struct {
                fn func(context.Context, DatasetListResponse) (DatasetListResponse, error)
                dlr DatasetListResponse
            }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * DatasetListResponsePage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DatasetListResponsePage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
        next, err := page.fn(ctx, page.dlr)
        if err != nil {
        return err
        }
        page.dlr = next
        if !next.hasNextLink() || !next.IsEmpty() {
        break
        }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * DatasetListResponsePage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page DatasetListResponsePage) NotDone() bool {
        return !page.dlr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page DatasetListResponsePage) Response() DatasetListResponse {
        return page.dlr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page DatasetListResponsePage) Values() []DatasetDetailInfo {
        if page.dlr.IsEmpty() {
        return nil
        }
        return *page.dlr.Datasets
        }
        // Creates a new instance of the DatasetListResponsePage type.
        func NewDatasetListResponsePage (cur DatasetListResponse, getNextPage func(context.Context, DatasetListResponse) (DatasetListResponse, error)) DatasetListResponsePage {
        return DatasetListResponsePage{
        fn: getNextPage,
        dlr: cur,
        }
        }

            // DatasetSources information about the details of the create request for the dataset.
            type DatasetSources struct {
            // ConversionIds - READ-ONLY; The list of `conversionId` that were used to create the dataset.
            ConversionIds *[]string `json:"conversionIds,omitempty"`
            // AppendDatasetID - READ-ONLY; The dataset that was appended to to create the current dataset.
            AppendDatasetID *string `json:"appendDatasetId,omitempty"`
            }

            // DataUpdatePreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DataUpdatePreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DataClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DataUpdatePreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DataUpdatePreviewFuture.Result.
        func (future *DataUpdatePreviewFuture) result(client DataClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "creator.DataUpdatePreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("creator.DataUpdatePreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.UpdatePreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "creator.DataUpdatePreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DataUploadPreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DataUploadPreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DataClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DataUploadPreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DataUploadPreviewFuture.Result.
        func (future *DataUploadPreviewFuture) result(client DataClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "creator.DataUploadPreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("creator.DataUploadPreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.UploadPreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "creator.DataUploadPreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DefinitionProperties ...
            type DefinitionProperties struct {
            // Name - name of attribute
            Name *string `json:"name,omitempty"`
            // Required - is attribute required
            Required *bool `json:"required,omitempty"`
            // Type - type of attribute
            Type interface{} `json:"type,omitempty"`
            }

            // ErrorAdditionalInfo the resource management error additional info.
            type ErrorAdditionalInfo struct {
            // Type - READ-ONLY; The additional info type.
            Type *string `json:"type,omitempty"`
            // Info - READ-ONLY; The additional info.
            Info interface{} `json:"info,omitempty"`
            }

            // ErrorDetail the error detail.
            type ErrorDetail struct {
            // Code - READ-ONLY; The error code.
            Code *string `json:"code,omitempty"`
            // Message - READ-ONLY; The error message.
            Message *string `json:"message,omitempty"`
            // Target - READ-ONLY; The error target.
            Target *string `json:"target,omitempty"`
            // Details - READ-ONLY; The error details.
            Details *[]ErrorDetail `json:"details,omitempty"`
            // AdditionalInfo - READ-ONLY; The error additional info.
            AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
            }

            // ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
            // failed operations. (This also follows the OData error response format.).
            type ErrorResponse struct {
            // Error - The error object.
            Error *ErrorDetail `json:"error,omitempty"`
            }

            // ExtendedGeoJSONFeatureCollection a valid `GeoJSON FeatureCollection` object type extended with
            // numberReturned and links array. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
            type ExtendedGeoJSONFeatureCollection struct {
            autorest.Response `json:"-"`
            // Type - Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. Possible values include: 'GeoJSONObjectTypeGeoJSONPoint', 'GeoJSONObjectTypeGeoJSONMultiPoint', 'GeoJSONObjectTypeGeoJSONLineString', 'GeoJSONObjectTypeGeoJSONMultiLineString', 'GeoJSONObjectTypeGeoJSONPolygon', 'GeoJSONObjectTypeGeoJSONMultiPolygon', 'GeoJSONObjectTypeGeoJSONGeometryCollection', 'GeoJSONObjectTypeGeoJSONFeature', 'GeoJSONObjectTypeGeoJSONFeatureCollection'
            Type GeoJSONObjectType `json:"type,omitempty"`
            // Features - Contains a list of valid `GeoJSON Feature` objects.
            Features *[]GeoJSONFeature `json:"features,omitempty"`
            Ontology *string `json:"ontology,omitempty"`
            // NumberReturned - Number of returned features.
            NumberReturned *int32 `json:"numberReturned,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            }

            // ExtendedGeoJSONFeatureCollectionData ...
            type ExtendedGeoJSONFeatureCollectionData struct {
            Ontology *string `json:"ontology,omitempty"`
            // NumberReturned - Number of returned features.
            NumberReturned *int32 `json:"numberReturned,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            }

            // FeatureResponse ...
            type FeatureResponse struct {
            autorest.Response `json:"-"`
            Ontology *string `json:"ontology,omitempty"`
            Feature *GeoJSONFeature `json:"feature,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            }

            // FeatureStateObject single feature state model.
            type FeatureStateObject struct {
            // KeyName - Feature state Keyname. Maximum length allowed is 1000.
            KeyName *string `json:"keyName,omitempty"`
            // Value - Value for the feature state. Type should comply with the style definition attached to the featurestate. Maximum length allowed for string type is 1024.
            Value interface{} `json:"value,omitempty"`
            // EventTimestamp - Valid Timestamp when the feature state was captured.
            EventTimestamp *string `json:"eventTimestamp,omitempty"`
            }

            // FeatureStatesStructure the feature states model for a feature.
            type FeatureStatesStructure struct {
            autorest.Response `json:"-"`
            // States - The feature states array.
            States *[]FeatureStateObject `json:"states,omitempty"`
            }

            // GeofenceGeometry the geofencing geometry.
            type GeofenceGeometry struct {
            // DeviceID - READ-ONLY; ID of the device.
            DeviceID *string `json:"deviceId,omitempty"`
            // UdID - READ-ONLY; The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object. Please refer to  [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature's properties should  contain `geometryId`, which is used for identifying the geometry and is case-sensitive.
            UdID *string `json:"udId,omitempty"`
            // GeometryID - READ-ONLY; The unique id identifies a geometry.
            GeometryID *string `json:"geometryId,omitempty"`
            // Distance - READ-ONLY; Distance from the coordinate to the closest border of the geofence. Positive means the  coordinate is outside of the geofence. If the coordinate is outside of the geofence, but more than the value of searchBuffer away from the closest geofence border, then the value is 999. Negative means the coordinate is inside of the geofence. If the coordinate is inside the polygon, but more than the value of searchBuffer away from the closest geofencing border, then the value is -999. A value of 999 means that there is great confidence the coordinate is well outside the geofence. A value of -999 means that there is great confidence the coordinate is well within the geofence.
            Distance *float64 `json:"distance,omitempty"`
            // NearestLat - READ-ONLY; Latitude of the nearest point of the geometry.
            NearestLat *float64 `json:"nearestLat,omitempty"`
            // NearestLon - READ-ONLY; Longitude of the nearest point of the geometry.
            NearestLon *float64 `json:"nearestLon,omitempty"`
            // NearestZ - READ-ONLY; Sea level in meter of the nearest point on the 2D extrusion geometry. This will only be presented in response when value is provided for 'zInMeter' in the request.
            NearestZ *float64 `json:"nearestZ,omitempty"`
            }

            // GeofenceResponse this object is returned from a geofence proximity call.
            type GeofenceResponse struct {
            autorest.Response `json:"-"`
            // Geometries - READ-ONLY; Lists the fence geometries that contain the coordinate position or overlap the searchBuffer around the position.
            Geometries *[]GeofenceGeometry `json:"geometries,omitempty"`
            // ExpiredGeofenceGeometryID - READ-ONLY; Lists of the geometry ID of the geofence which is expired relative to the user time in the request.
            ExpiredGeofenceGeometryID *[]string `json:"expiredGeofenceGeometryId,omitempty"`
            // InvalidPeriodGeofenceGeometryID - READ-ONLY; Lists of the geometry ID of the geofence which is in invalid period relative to the user time in the request.
            InvalidPeriodGeofenceGeometryID *[]string `json:"invalidPeriodGeofenceGeometryId,omitempty"`
            // IsEventPublished - READ-ONLY; True if at least one event is published to the Azure Maps event subscriber, false if no event is published to the Azure Maps event subscriber. This will only be presented in response when 'isAsync' query parameter is set to true.
            IsEventPublished *bool `json:"isEventPublished,omitempty"`
            }

            // GeoJSONFeature a valid `GeoJSON Feature` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.2) for details.
            type GeoJSONFeature struct {
            // Type - Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. Possible values include: 'GeoJSONObjectTypeGeoJSONPoint', 'GeoJSONObjectTypeGeoJSONMultiPoint', 'GeoJSONObjectTypeGeoJSONLineString', 'GeoJSONObjectTypeGeoJSONMultiLineString', 'GeoJSONObjectTypeGeoJSONPolygon', 'GeoJSONObjectTypeGeoJSONMultiPolygon', 'GeoJSONObjectTypeGeoJSONGeometryCollection', 'GeoJSONObjectTypeGeoJSONFeature', 'GeoJSONObjectTypeGeoJSONFeatureCollection'
            Type GeoJSONObjectType `json:"type,omitempty"`
            Geometry *GeoJSONGeometry `json:"geometry,omitempty"`
            // Properties - Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value
            Properties interface{} `json:"properties,omitempty"`
            // ID - Identifier for the feature.
            ID *string `json:"id,omitempty"`
            // FeatureType - The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value.
            FeatureType *string `json:"featureType,omitempty"`
            }

            // GeoJSONFeatureCollection a valid `GeoJSON FeatureCollection` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
            type GeoJSONFeatureCollection struct {
            // Type - Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. Possible values include: 'GeoJSONObjectTypeGeoJSONPoint', 'GeoJSONObjectTypeGeoJSONMultiPoint', 'GeoJSONObjectTypeGeoJSONLineString', 'GeoJSONObjectTypeGeoJSONMultiLineString', 'GeoJSONObjectTypeGeoJSONPolygon', 'GeoJSONObjectTypeGeoJSONMultiPolygon', 'GeoJSONObjectTypeGeoJSONGeometryCollection', 'GeoJSONObjectTypeGeoJSONFeature', 'GeoJSONObjectTypeGeoJSONFeatureCollection'
            Type GeoJSONObjectType `json:"type,omitempty"`
            // Features - Contains a list of valid `GeoJSON Feature` objects.
            Features *[]GeoJSONFeature `json:"features,omitempty"`
            }

            // GeoJSONFeatureCollectionData ...
            type GeoJSONFeatureCollectionData struct {
            // Features - Contains a list of valid `GeoJSON Feature` objects.
            Features *[]GeoJSONFeature `json:"features,omitempty"`
            }

            // GeoJSONFeatureData ...
            type GeoJSONFeatureData struct {
            Geometry *GeoJSONGeometry `json:"geometry,omitempty"`
            // Properties - Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value
            Properties interface{} `json:"properties,omitempty"`
            // ID - Identifier for the feature.
            ID *string `json:"id,omitempty"`
            // FeatureType - The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value.
            FeatureType *string `json:"featureType,omitempty"`
            }

            // GeoJSONGeometry a valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON
            // geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and
            // GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for
            // details.
            type GeoJSONGeometry struct {
            // Type - Possible values include: 'TypeGeoJSONObject', 'TypeGeoJSONGeometry'
            Type TypeBasicGeoJSONObject `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for GeoJSONGeometry.
        func (gjg GeoJSONGeometry)MarshalJSON() ([]byte, error){
            gjg.Type = TypeGeoJSONGeometry
            objectMap := make(map[string]interface{})
                if(gjg.Type != "") {
                objectMap["type"] = gjg.Type
                }
                return json.Marshal(objectMap)
        }

            // AsGeoJSONGeometry is the BasicGeoJSONObject implementation for GeoJSONGeometry.
            func (gjg GeoJSONGeometry) AsGeoJSONGeometry() (*GeoJSONGeometry, bool) {
                return &gjg, true
            }

            // AsGeoJSONObject is the BasicGeoJSONObject implementation for GeoJSONGeometry.
            func (gjg GeoJSONGeometry) AsGeoJSONObject() (*GeoJSONObject, bool) {
                return nil, false
            }

                // AsBasicGeoJSONObject is the BasicGeoJSONObject implementation for GeoJSONGeometry.
                func(gjg GeoJSONGeometry) AsBasicGeoJSONObject()(BasicGeoJSONObject, bool) {
                    return &gjg, true
                }


            // GeoJSONGeometryCollection a valid `GeoJSON GeometryCollection` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.8) for details.
            type GeoJSONGeometryCollection struct {
            // Geometries - Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Geometries *[]GeoJSONGeometry `json:"geometries,omitempty"`
            }

            // GeoJSONGeometryCollectionData ...
            type GeoJSONGeometryCollectionData struct {
            // Geometries - Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Geometries *[]GeoJSONGeometry `json:"geometries,omitempty"`
            }

            // GeoJSONLineString a valid `GeoJSON LineString` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details.
            type GeoJSONLineString struct {
            // Coordinates - Coordinates for the `GeoJson LineString` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONLineStringData ...
            type GeoJSONLineStringData struct {
            // Coordinates - Coordinates for the `GeoJson LineString` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONMultiLineString a valid `GeoJSON MultiLineString` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.5) for details.
            type GeoJSONMultiLineString struct {
            // Coordinates - Coordinates for the `GeoJson MultiLineString` geometry.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONMultiLineStringData ...
            type GeoJSONMultiLineStringData struct {
            // Coordinates - Coordinates for the `GeoJson MultiLineString` geometry.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONMultiPoint a valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details.
            type GeoJSONMultiPoint struct {
            // Coordinates - Coordinates for the `GeoJson MultiPoint` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONMultiPointData data contained by a `GeoJson MultiPoint`.
            type GeoJSONMultiPointData struct {
            // Coordinates - Coordinates for the `GeoJson MultiPoint` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONMultiPolygon a valid `GeoJSON MultiPolygon` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.7) for details.
            type GeoJSONMultiPolygon struct {
            // Coordinates - Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Coordinates *[][][][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONMultiPolygonData ...
            type GeoJSONMultiPolygonData struct {
            // Coordinates - Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Coordinates *[][][][]float64 `json:"coordinates,omitempty"`
            }

// BasicGeoJSONObject a valid `GeoJSON` object. Please refer to [RFC
// 7946](https://tools.ietf.org/html/rfc7946#section-3) for details.
        type BasicGeoJSONObject interface {
            AsGeoJSONGeometry () (*GeoJSONGeometry, bool)
        AsGeoJSONObject () (*GeoJSONObject, bool)
        }

        // GeoJSONObject a valid `GeoJSON` object. Please refer to [RFC
        // 7946](https://tools.ietf.org/html/rfc7946#section-3) for details.
        type GeoJSONObject struct {
        // Type - Possible values include: 'TypeGeoJSONObject', 'TypeGeoJSONGeometry'
        Type TypeBasicGeoJSONObject `json:"type,omitempty"`
        }

        func unmarshalBasicGeoJSONObject(body []byte) (BasicGeoJSONObject, error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }

        switch m["type"] {
            case string(TypeGeoJSONGeometry):
            var gjg GeoJSONGeometry
            err := json.Unmarshal(body, &gjg)
            return gjg, err
            default:
        var gjo GeoJSONObject
        err := json.Unmarshal(body, &gjo)
        return gjo, err
        }
        }
        func unmarshalBasicGeoJSONObjectArray(body []byte) ([]BasicGeoJSONObject, error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }

        gjoArray := make([]BasicGeoJSONObject, len(rawMessages))

        for index, rawMessage := range rawMessages {
        gjo, err := unmarshalBasicGeoJSONObject(*rawMessage)
        if err != nil {
        return nil, err
        }
        gjoArray[index] = gjo
        }
        return gjoArray, nil
        }

        // MarshalJSON is the custom marshaler for GeoJSONObject.
        func (gjo GeoJSONObject)MarshalJSON() ([]byte, error){
            gjo.Type = TypeGeoJSONObject
            objectMap := make(map[string]interface{})
                if(gjo.Type != "") {
                objectMap["type"] = gjo.Type
                }
                return json.Marshal(objectMap)
        }

            // AsGeoJSONGeometry is the BasicGeoJSONObject implementation for GeoJSONObject.
            func (gjo GeoJSONObject) AsGeoJSONGeometry() (*GeoJSONGeometry, bool) {
                return nil, false
            }

            // AsGeoJSONObject is the BasicGeoJSONObject implementation for GeoJSONObject.
            func (gjo GeoJSONObject) AsGeoJSONObject() (*GeoJSONObject, bool) {
                return &gjo, true
            }

                // AsBasicGeoJSONObject is the BasicGeoJSONObject implementation for GeoJSONObject.
                func(gjo GeoJSONObject) AsBasicGeoJSONObject()(BasicGeoJSONObject, bool) {
                    return &gjo, true
                }


            // GeoJSONPoint a valid `GeoJSON Point` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details.
            type GeoJSONPoint struct {
            Coordinates *[]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONPointData data contained by a `GeoJson Point`.
            type GeoJSONPointData struct {
            Coordinates *[]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONPolygon a valid `GeoJSON Polygon` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.6) for details.
            type GeoJSONPolygon struct {
            // Coordinates - Coordinates for the `GeoJson Polygon` geometry type.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // GeoJSONPolygonData ...
            type GeoJSONPolygonData struct {
            // Coordinates - Coordinates for the `GeoJson Polygon` geometry type.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // GreatCircleDistanceResponse this object is returned from a successful Great Circle Distance call
            type GreatCircleDistanceResponse struct {
            autorest.Response `json:"-"`
            // Summary - READ-ONLY; Summary object
            Summary *GreatCircleDistanceResponseSummary `json:"summary,omitempty"`
            // Result - READ-ONLY; Result Object
            Result *GreatCircleDistanceResponseResult `json:"result,omitempty"`
            }

            // GreatCircleDistanceResponseResult result Object
            type GreatCircleDistanceResponseResult struct {
            // DistanceInMeters - READ-ONLY; The great circle distance in meters from the source point to the target point
            DistanceInMeters *float64 `json:"distanceInMeters,omitempty"`
            }

            // GreatCircleDistanceResponseSummary summary object
            type GreatCircleDistanceResponseSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            TargetPoint *SpatialCoordinate `json:"targetPoint,omitempty"`
            }

            // LandingPageResponse ...
            type LandingPageResponse struct {
            autorest.Response `json:"-"`
            Ontology *string `json:"ontology,omitempty"`
            // Links - Links to other WFS endpoints.
            Links *[]WfsEndpointLink `json:"links,omitempty"`
            }

            // LongRunningOperationResult the response model for a Long-Running Operations API.
            type LongRunningOperationResult struct {
            autorest.Response `json:"-"`
            // OperationID - The Id for this long-running operation.
            OperationID *string `json:"operationId,omitempty"`
            // Status - READ-ONLY; The status state of the request. Possible values include: 'NotStarted', 'Running', 'Failed', 'Succeeded'
            Status LroStatus `json:"status,omitempty"`
            // Created - READ-ONLY; The created timestamp.
            Created *string `json:"created,omitempty"`
            Error *ErrorDetail `json:"error,omitempty"`
            Warning *ErrorDetail `json:"warning,omitempty"`
            }

        // MarshalJSON is the custom marshaler for LongRunningOperationResult.
        func (lror LongRunningOperationResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(lror.OperationID != nil) {
                objectMap["operationId"] = lror.OperationID
                }
                if(lror.Error != nil) {
                objectMap["error"] = lror.Error
                }
                if(lror.Warning != nil) {
                objectMap["warning"] = lror.Warning
                }
                return json.Marshal(objectMap)
        }

            // MapDataDetailInfo detail information for the data.
            type MapDataDetailInfo struct {
            // Udid - READ-ONLY; The unique data id for the data.
            Udid *string `json:"udid,omitempty"`
            // Location - READ-ONLY; The location of the data. Execute a HTTP `GET` on this location to download the data.
            Location *string `json:"location,omitempty"`
            // SizeInBytes - READ-ONLY; The size of the content in bytes.
            SizeInBytes *int64 `json:"sizeInBytes,omitempty"`
            // UploadStatus - READ-ONLY; The current upload status of the content.
            UploadStatus *string `json:"uploadStatus,omitempty"`
            // DataFormat - READ-ONLY; The current data format.
            DataFormat *string `json:"dataFormat,omitempty"`
            // Description - READ-ONLY; The current description.
            Description *string `json:"description,omitempty"`
            }

            // MapDataListResponse the response model for the Data List API. Returns a list of all the previously
            // uploaded data.
            type MapDataListResponse struct {
            autorest.Response `json:"-"`
            // MapDataList - READ-ONLY; A list of all the previously uploaded data.
            MapDataList *[]MapDataDetailInfo `json:"mapDataList,omitempty"`
            }

            // NumberRuleObject the numeric rule. The color is selected from the first range it falls into.
            type NumberRuleObject struct {
            Range *RangeObject `json:"range,omitempty"`
            // Color - The color when value is within the range. Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255, 255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
            Color *string `json:"color,omitempty"`
            }

            // NumberTypeStyleRule the numeric type style rule object.
            type NumberTypeStyleRule struct {
            // Rules - Numeric style rules.
            Rules *[]NumberRuleObject `json:"rules,omitempty"`
            // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
            KeyName *string `json:"keyName,omitempty"`
            // Type - Possible values include: 'TypeStyleObject', 'TypeBoolean', 'TypeNumber', 'TypeString'
            Type Type `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for NumberTypeStyleRule.
        func (ntsr NumberTypeStyleRule)MarshalJSON() ([]byte, error){
            ntsr.Type = TypeNumber
            objectMap := make(map[string]interface{})
                if(ntsr.Rules != nil) {
                objectMap["rules"] = ntsr.Rules
                }
                if(ntsr.KeyName != nil) {
                objectMap["keyName"] = ntsr.KeyName
                }
                if(ntsr.Type != "") {
                objectMap["type"] = ntsr.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleObject implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return nil, false
            }

            // AsNumberTypeStyleRule is the BasicStyleObject implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return &ntsr, true
            }

            // AsStringTypeStyleRule is the BasicStyleObject implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return nil, false
            }

            // AsStyleObject is the BasicStyleObject implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsStyleObject() (*StyleObject, bool) {
                return nil, false
            }

                // AsBasicStyleObject is the BasicStyleObject implementation for NumberTypeStyleRule.
                func(ntsr NumberTypeStyleRule) AsBasicStyleObject()(BasicStyleObject, bool) {
                    return &ntsr, true
                }


            // PointInPolygonResponse returns true if point is within the polygon, false otherwise
            type PointInPolygonResponse struct {
            autorest.Response `json:"-"`
            Summary *PointInPolygonSummary `json:"summary,omitempty"`
            Result *PointInPolygonResult `json:"result,omitempty"`
            }

            // PointInPolygonResult point In Polygon Result Object
            type PointInPolygonResult struct {
            // PointInPolygons - READ-ONLY; Point In Polygons Property
            PointInPolygons *bool `json:"pointInPolygons,omitempty"`
            // IntersectingGeometries - READ-ONLY; Geometries array
            IntersectingGeometries *[]string `json:"intersectingGeometries,omitempty"`
            }

            // PointInPolygonSummary point In Polygon Summary object
            type PointInPolygonSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content. Udid is not applicable for POST spatial operations(set to null)
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; Processing information
            Information *string `json:"information,omitempty"`
            }

        // MarshalJSON is the custom marshaler for PointInPolygonSummary.
        func (pips PointInPolygonSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(pips.SourcePoint != nil) {
                objectMap["sourcePoint"] = pips.SourcePoint
                }
                return json.Marshal(objectMap)
        }

            // RangeObject the numeric value range for this style rule. If the value is in the range, all the
            // conditions must hold true.
            type RangeObject struct {
            // Minimum - All the number x that x ≥ minimum.
            Minimum *float64 `json:"minimum,omitempty"`
            // Maximum - All the number x that x ≤ maximum.
            Maximum *float64 `json:"maximum,omitempty"`
            // ExclusiveMinimum - All the number x that x > exclusiveMinimum.
            ExclusiveMinimum *float64 `json:"exclusiveMinimum,omitempty"`
            // ExclusiveMaximum - All the number x that x < exclusiveMaximum.
            ExclusiveMaximum *float64 `json:"exclusiveMaximum,omitempty"`
            }

            // ReadCloser ...
            type ReadCloser struct {
            autorest.Response `json:"-"`
            Value *io.ReadCloser `json:"value,omitempty"`
            }

            // SpatialCoordinate a location represented as a latitude and longitude
            type SpatialCoordinate struct {
            // Lat - READ-ONLY; Latitude property
            Lat *float64 `json:"lat,omitempty"`
            // Lon - READ-ONLY; Longitude property
            Lon *float64 `json:"lon,omitempty"`
            }

            // StatesetCreatedResponse the response model for the successful Stateset Create API.
            type StatesetCreatedResponse struct {
            autorest.Response `json:"-"`
            // StatesetID - READ-ONLY; The ID for the new stateset created.
            StatesetID *string `json:"statesetId,omitempty"`
            }

            // StatesetGetResponse the response model for the successful Stateset Get API.
            type StatesetGetResponse struct {
            autorest.Response `json:"-"`
            // Description - READ-ONLY; Description associated with the stateset.
            Description *string `json:"description,omitempty"`
            // DatasetIds - Dataset ID associated with the stateset.
            DatasetIds *[]string `json:"datasetIds,omitempty"`
            StatesetStyle *StylesObject `json:"statesetStyle,omitempty"`
            }

        // MarshalJSON is the custom marshaler for StatesetGetResponse.
        func (sgr StatesetGetResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sgr.DatasetIds != nil) {
                objectMap["datasetIds"] = sgr.DatasetIds
                }
                if(sgr.StatesetStyle != nil) {
                objectMap["statesetStyle"] = sgr.StatesetStyle
                }
                return json.Marshal(objectMap)
        }

            // StatesetInfoObject the stateset information detail.
            type StatesetInfoObject struct {
            // StatesetID - The stateset ID of this stateset.
            StatesetID *string `json:"statesetId,omitempty"`
            // Description - READ-ONLY; Description associated with the stateset.
            Description *string `json:"description,omitempty"`
            // DatasetIds - Dataset ID associated with the stateset.
            DatasetIds *[]string `json:"datasetIds,omitempty"`
            StatesetStyle *StylesObject `json:"statesetStyle,omitempty"`
            }

        // MarshalJSON is the custom marshaler for StatesetInfoObject.
        func (sio StatesetInfoObject)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sio.StatesetID != nil) {
                objectMap["statesetId"] = sio.StatesetID
                }
                if(sio.DatasetIds != nil) {
                objectMap["datasetIds"] = sio.DatasetIds
                }
                if(sio.StatesetStyle != nil) {
                objectMap["statesetStyle"] = sio.StatesetStyle
                }
                return json.Marshal(objectMap)
        }

            // StatesetListResponse the response model for the successful Stateset List API.
            type StatesetListResponse struct {
            autorest.Response `json:"-"`
            // Statesets - A list of statesets information.
            Statesets *[]StatesetInfoObject `json:"statesets,omitempty"`
            // NextLink - READ-ONLY; If present, the location of the next page of data.
            NextLink *string `json:"nextLink,omitempty"`
            }

        // MarshalJSON is the custom marshaler for StatesetListResponse.
        func (slr StatesetListResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(slr.Statesets != nil) {
                objectMap["statesets"] = slr.Statesets
                }
                return json.Marshal(objectMap)
        }

            // StatesetListResponseIterator provides access to a complete listing of StatesetInfoObject values.
            type StatesetListResponseIterator struct {
                i int
                page StatesetListResponsePage
            }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * StatesetListResponseIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/StatesetListResponseIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * StatesetListResponseIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter StatesetListResponseIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter StatesetListResponseIterator) Response() StatesetListResponse {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter StatesetListResponseIterator) Value() StatesetInfoObject {
        if !iter.page.NotDone() {
        return StatesetInfoObject{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the StatesetListResponseIterator type.
        func NewStatesetListResponseIterator (page StatesetListResponsePage) StatesetListResponseIterator {
        return StatesetListResponseIterator{page: page}
        }


                // IsEmpty returns true if the ListResult contains no values.
                func (slr StatesetListResponse) IsEmpty() bool {
                return slr.Statesets == nil || len(*slr.Statesets) == 0
                }

                // hasNextLink returns true if the NextLink is not empty.
                func (slr StatesetListResponse) hasNextLink() bool {
                return slr.NextLink != nil && len(*slr.NextLink) != 0
                }
                    // statesetListResponsePreparer prepares a request to retrieve the next set of results.
                    // It returns nil if no more results exist.
                    func (slr StatesetListResponse) statesetListResponsePreparer(ctx context.Context) (*http.Request, error) {
                    if !slr.hasNextLink() {
                    return nil, nil
                    }
                    return autorest.Prepare((&http.Request{}).WithContext(ctx),
                    autorest.AsJSON(),
                    autorest.AsGet(),
                    autorest.WithBaseURL(to.String( slr.NextLink)));
                    }

            // StatesetListResponsePage contains a page of StatesetInfoObject values.
            type StatesetListResponsePage struct {
                fn func(context.Context, StatesetListResponse) (StatesetListResponse, error)
                slr StatesetListResponse
            }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * StatesetListResponsePage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/StatesetListResponsePage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
        next, err := page.fn(ctx, page.slr)
        if err != nil {
        return err
        }
        page.slr = next
        if !next.hasNextLink() || !next.IsEmpty() {
        break
        }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * StatesetListResponsePage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page StatesetListResponsePage) NotDone() bool {
        return !page.slr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page StatesetListResponsePage) Response() StatesetListResponse {
        return page.slr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page StatesetListResponsePage) Values() []StatesetInfoObject {
        if page.slr.IsEmpty() {
        return nil
        }
        return *page.slr.Statesets
        }
        // Creates a new instance of the StatesetListResponsePage type.
        func NewStatesetListResponsePage (cur StatesetListResponse, getNextPage func(context.Context, StatesetListResponse) (StatesetListResponse, error)) StatesetListResponsePage {
        return StatesetListResponsePage{
        fn: getNextPage,
        slr: cur,
        }
        }

            // StringTypeStyleRule the string type style rule object.
            type StringTypeStyleRule struct {
            // Rules - String style rules.
            Rules *[]map[string]*string `json:"rules,omitempty"`
            // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
            KeyName *string `json:"keyName,omitempty"`
            // Type - Possible values include: 'TypeStyleObject', 'TypeBoolean', 'TypeNumber', 'TypeString'
            Type Type `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for StringTypeStyleRule.
        func (stsr StringTypeStyleRule)MarshalJSON() ([]byte, error){
            stsr.Type = TypeString
            objectMap := make(map[string]interface{})
                if(stsr.Rules != nil) {
                objectMap["rules"] = stsr.Rules
                }
                if(stsr.KeyName != nil) {
                objectMap["keyName"] = stsr.KeyName
                }
                if(stsr.Type != "") {
                objectMap["type"] = stsr.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleObject implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return nil, false
            }

            // AsNumberTypeStyleRule is the BasicStyleObject implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return nil, false
            }

            // AsStringTypeStyleRule is the BasicStyleObject implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return &stsr, true
            }

            // AsStyleObject is the BasicStyleObject implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsStyleObject() (*StyleObject, bool) {
                return nil, false
            }

                // AsBasicStyleObject is the BasicStyleObject implementation for StringTypeStyleRule.
                func(stsr StringTypeStyleRule) AsBasicStyleObject()(BasicStyleObject, bool) {
                    return &stsr, true
                }


// BasicStyleObject the stateset style model. The style rule could be a numeric type style rule or a boolean type style
// rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject definitions
// [here](https://aka.ms/AzureMapsStatesetStylesObject).
        type BasicStyleObject interface {
            AsBooleanTypeStyleRule () (*BooleanTypeStyleRule, bool)
            AsNumberTypeStyleRule () (*NumberTypeStyleRule, bool)
            AsStringTypeStyleRule () (*StringTypeStyleRule, bool)
        AsStyleObject () (*StyleObject, bool)
        }

        // StyleObject the stateset style model. The style rule could be a numeric type style rule or a boolean type
        // style rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject definitions
        // [here](https://aka.ms/AzureMapsStatesetStylesObject).
        type StyleObject struct {
        // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
        KeyName *string `json:"keyName,omitempty"`
        // Type - Possible values include: 'TypeStyleObject', 'TypeBoolean', 'TypeNumber', 'TypeString'
        Type Type `json:"type,omitempty"`
        }

        func unmarshalBasicStyleObject(body []byte) (BasicStyleObject, error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }

        switch m["type"] {
            case string(TypeBoolean):
            var btsr BooleanTypeStyleRule
            err := json.Unmarshal(body, &btsr)
            return btsr, err
            case string(TypeNumber):
            var ntsr NumberTypeStyleRule
            err := json.Unmarshal(body, &ntsr)
            return ntsr, err
            case string(TypeString):
            var stsr StringTypeStyleRule
            err := json.Unmarshal(body, &stsr)
            return stsr, err
            default:
        var so StyleObject
        err := json.Unmarshal(body, &so)
        return so, err
        }
        }
        func unmarshalBasicStyleObjectArray(body []byte) ([]BasicStyleObject, error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }

        soArray := make([]BasicStyleObject, len(rawMessages))

        for index, rawMessage := range rawMessages {
        so, err := unmarshalBasicStyleObject(*rawMessage)
        if err != nil {
        return nil, err
        }
        soArray[index] = so
        }
        return soArray, nil
        }

        // MarshalJSON is the custom marshaler for StyleObject.
        func (so StyleObject)MarshalJSON() ([]byte, error){
            so.Type = TypeStyleObject
            objectMap := make(map[string]interface{})
                if(so.KeyName != nil) {
                objectMap["keyName"] = so.KeyName
                }
                if(so.Type != "") {
                objectMap["type"] = so.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleObject implementation for StyleObject.
            func (so StyleObject) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return nil, false
            }

            // AsNumberTypeStyleRule is the BasicStyleObject implementation for StyleObject.
            func (so StyleObject) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return nil, false
            }

            // AsStringTypeStyleRule is the BasicStyleObject implementation for StyleObject.
            func (so StyleObject) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return nil, false
            }

            // AsStyleObject is the BasicStyleObject implementation for StyleObject.
            func (so StyleObject) AsStyleObject() (*StyleObject, bool) {
                return &so, true
            }

                // AsBasicStyleObject is the BasicStyleObject implementation for StyleObject.
                func(so StyleObject) AsBasicStyleObject()(BasicStyleObject, bool) {
                    return &so, true
                }


            // StylesObject the styles model.
            type StylesObject struct {
            // Styles - An array of stateset styles. The style rule could be a numeric or string or a boolean type style rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject definitions [here](https://aka.ms/AzureMapsStatesetStylesObject).
            Styles *[]BasicStyleObject `json:"styles,omitempty"`
            }
        // UnmarshalJSON is the custom unmarshaler for StylesObject struct.
        func (so *StylesObject) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "styles":
    if v != nil {
        styles, err := unmarshalBasicStyleObjectArray(*v)
    if err != nil {
    return err
    }
        so.Styles = &styles
    }
            }
        }

        return nil
        }

            // TilesetCreateFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type TilesetCreateFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(TilesetClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *TilesetCreateFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for TilesetCreateFuture.Result.
        func (future *TilesetCreateFuture) result(client TilesetClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "creator.TilesetCreateFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("creator.TilesetCreateFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.CreateResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "creator.TilesetCreateFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // TilesetDetailInfo detail information for the data.
            type TilesetDetailInfo struct {
            autorest.Response `json:"-"`
            // TilesetID - READ-ONLY; The unique tileset id for the tileset.
            TilesetID *string `json:"tilesetId,omitempty"`
            Ontology *string `json:"ontology,omitempty"`
            // DatasetID - READ-ONLY; The unique dataset Id used to create the tileset.
            DatasetID *string `json:"datasetId,omitempty"`
            // Description - READ-ONLY; The description the caller provided when creating the tileset. Maximum length 1024 characters.
            Description *string `json:"description,omitempty"`
            // MinZoom - READ-ONLY; The lowest tile zoom level tile generated for the tileset.
            MinZoom *int32 `json:"minZoom,omitempty"`
            // MaxZoom - READ-ONLY; The highest tile zoom level tile generated for the tileset.
            MaxZoom *int32 `json:"maxZoom,omitempty"`
            // Bbox - READ-ONLY; Bounding box which all features of the tileset lay within. Projection used - EPSG:3857. Format : 'minLon, minLat, maxLon, maxLat'.
            Bbox *[]float64 `json:"bbox,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TilesetDetailInfo.
        func (tdi TilesetDetailInfo)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tdi.Ontology != nil) {
                objectMap["ontology"] = tdi.Ontology
                }
                return json.Marshal(objectMap)
        }

            // TilesetListResponse the response model for the Tileset List API. Returns a list of all tilesets.
            type TilesetListResponse struct {
            autorest.Response `json:"-"`
            // Tilesets - READ-ONLY; A list of all tilesets.
            Tilesets *[]TilesetDetailInfo `json:"tilesets,omitempty"`
            // NextLink - READ-ONLY; If present, the location of the next page of data.
            NextLink *string `json:"nextLink,omitempty"`
            }

            // TilesetListResponseIterator provides access to a complete listing of TilesetDetailInfo values.
            type TilesetListResponseIterator struct {
                i int
                page TilesetListResponsePage
            }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * TilesetListResponseIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TilesetListResponseIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * TilesetListResponseIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter TilesetListResponseIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter TilesetListResponseIterator) Response() TilesetListResponse {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter TilesetListResponseIterator) Value() TilesetDetailInfo {
        if !iter.page.NotDone() {
        return TilesetDetailInfo{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the TilesetListResponseIterator type.
        func NewTilesetListResponseIterator (page TilesetListResponsePage) TilesetListResponseIterator {
        return TilesetListResponseIterator{page: page}
        }


                // IsEmpty returns true if the ListResult contains no values.
                func (tlr TilesetListResponse) IsEmpty() bool {
                return tlr.Tilesets == nil || len(*tlr.Tilesets) == 0
                }

                // hasNextLink returns true if the NextLink is not empty.
                func (tlr TilesetListResponse) hasNextLink() bool {
                return tlr.NextLink != nil && len(*tlr.NextLink) != 0
                }
                    // tilesetListResponsePreparer prepares a request to retrieve the next set of results.
                    // It returns nil if no more results exist.
                    func (tlr TilesetListResponse) tilesetListResponsePreparer(ctx context.Context) (*http.Request, error) {
                    if !tlr.hasNextLink() {
                    return nil, nil
                    }
                    return autorest.Prepare((&http.Request{}).WithContext(ctx),
                    autorest.AsJSON(),
                    autorest.AsGet(),
                    autorest.WithBaseURL(to.String( tlr.NextLink)));
                    }

            // TilesetListResponsePage contains a page of TilesetDetailInfo values.
            type TilesetListResponsePage struct {
                fn func(context.Context, TilesetListResponse) (TilesetListResponse, error)
                tlr TilesetListResponse
            }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * TilesetListResponsePage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TilesetListResponsePage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
        next, err := page.fn(ctx, page.tlr)
        if err != nil {
        return err
        }
        page.tlr = next
        if !next.hasNextLink() || !next.IsEmpty() {
        break
        }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * TilesetListResponsePage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page TilesetListResponsePage) NotDone() bool {
        return !page.tlr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page TilesetListResponsePage) Response() TilesetListResponse {
        return page.tlr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page TilesetListResponsePage) Values() []TilesetDetailInfo {
        if page.tlr.IsEmpty() {
        return nil
        }
        return *page.tlr.Tilesets
        }
        // Creates a new instance of the TilesetListResponsePage type.
        func NewTilesetListResponsePage (cur TilesetListResponse, getNextPage func(context.Context, TilesetListResponse) (TilesetListResponse, error)) TilesetListResponsePage {
        return TilesetListResponsePage{
        fn: getNextPage,
        tlr: cur,
        }
        }

            // WfsEndpointLink links to other WFS endpoints
            type WfsEndpointLink struct {
            // Href - The link target.
            Href *string `json:"href,omitempty"`
            // Rel - The relation type.
            Rel *string `json:"rel,omitempty"`
            // Type - A hint indicating what the media type of the result of dereferencing the link should be.
            Type *string `json:"type,omitempty"`
            // Hreflang - A hint indicating what the language of the result of dereferencing the link should be.
            Hreflang *string `json:"hreflang,omitempty"`
            // Title - Used to label the destination of a link such that it can be used as a human-readable identifier (e.g., a menu entry) in the language indicated by the Content-Language header field (if present).
            Title *string `json:"title,omitempty"`
            }

