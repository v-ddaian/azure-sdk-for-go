package creator

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
)

// ConversionClient is the client for the Conversion methods of the Creator service.
type ConversionClient struct {
    BaseClient
}
// NewConversionClient creates an instance of the ConversionClient client.
func NewConversionClient(xMsClientID string) ConversionClient {
    return ConversionClient{ New(xMsClientID)}
}

// Convert **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
//
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and
// SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools
// that apply to Azure Maps Creator.
//
// The Conversion API lets the caller import a set of DWG design files as a zipped [Drawing
// Package](https://aka.ms/am-drawing-package) into Azure Maps. The [Drawing
// Package](https://aka.ms/am-drawing-package) should first be uploaded using the [Azure Maps Data
// Service](https://docs.microsoft.com/rest/api/maps/data). Once uploaded, use the `udid` returned by the [Data Upload
// API](https://docs.microsoft.com/rest/api/maps/data/uploadpreview) to call this Conversion API.
//
// ## Convert DWG package
//
// The Conversion API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
//
// ## Debug DWG package issues
//
//
// During the Conversion process, if there are any issues with the DWG package [errors and
// warnings](https://aka.ms/am-conversion-errors) are provided in the response along with a *diagnostic package* to
// visualize and diagnose these issues. In case any issues are encountered with your DWG package, the Conversion
// operation status process as detailed [here](https://aka.ms/am-creator-lrt-v2) returns the location of the
// *diagnostic package* that can be downloaded by the caller to help them visualize and diagnose these issues. The
// *diagnostic package* location can be found in the properties section of the conversion operation status response and
// looks like the following:
//
// ```json
// {
// "properties": {
// "diagnosticPackageLocation": "https://us.atlas.microsoft.com/mapdata/{DiagnosticPackageId}?api-version=1.0"
// }
// }
// ```
//
// The *diagnostic package* can be downloaded by executing a `HTTP GET` request on the `diagnosticPackageLocation`.
// For more details on how to use the tool to visualize and diagnose all the errors and warnings see [Drawing Error
// Visualizer](https://aka.ms/am-drawing-errors-visualizer). <br>
//
// A conversion operation will be marked as *success* if there are zero or more warnings but will be marked as *failed*
// if any errors are encountered.
    // Parameters:
        // udid - the unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
        // outputOntology - output ontology version. "facility-2.0" is the only supported value at this time. Please
        // refer to this [article](https://docs.microsoft.com/en-us/azure/azure-maps/creator-facility-ontology) for
        // more information about Azure Maps Creator ontologies.
        // description - user provided description of the content being converted.
func (client ConversionClient) Convert(ctx context.Context, udid string, outputOntology string, description string) (result ConversionConvertFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionClient.Convert")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.ConvertPreparer(ctx, udid, outputOntology, description)
    if err != nil {
    err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Convert", nil , "Failure preparing request")
    return
    }

        result, err = client.ConvertSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Convert", nil , "Failure sending request")
        return
        }

    return
}

    // ConvertPreparer prepares the Convert request.
    func (client ConversionClient) ConvertPreparer(ctx context.Context, udid string, outputOntology string, description string) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "geography": autorest.Encode("path",client.Geography),
        }

            const APIVersion = "2.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "outputOntology": autorest.Encode("query",outputOntology),
    "udid": autorest.Encode("query",udid),
    }
        if len(description) > 0 {
        queryParameters["description"] = autorest.Encode("query",description)
        }

    preparer := autorest.CreatePreparer(
autorest.AsPost(),
autorest.WithCustomBaseURL("https://{geography}.atlas.microsoft.com", urlParameters),
autorest.WithPath("/conversions"),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ConvertSender sends the Convert request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversionClient) ConvertSender(req *http.Request) (future ConversionConvertFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // ConvertResponder handles the response to the Convert request. The method always
    // closes the http.Response Body.
    func (client ConversionClient) ConvertResponder(resp *http.Response) (result LongRunningOperationResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// Delete **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
//
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and
// SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools
// that apply to Azure Maps Creator.
//
// This API allows the caller to delete any data conversions created previously using the [Conversion
// API](https://docs.microsoft.com/en-us/rest/api/maps/conversion/convertpreview).
//
// ### Submit Delete Request
//
// To delete your conversion data you will issue a `DELETE` request where the path will contain the `conversionId` of
// the data to delete.
//
// ### Conversion Delete Response
//
// The Conversion Delete API returns a HTTP `204 No Content` response with an empty body, if the converted data
// resources were deleted successfully.<br>
// A HTTP `400 Bad Request` error response will be returned if no resource associated with the passed-in `conversionId`
// is found.
    // Parameters:
        // conversionID - the conversion id for the content. The `conversionId` must have been obtained from a
        // successful [Conversion API](https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert) call.
func (client ConversionClient) Delete(ctx context.Context, conversionID string) (result autorest.Response, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionClient.Delete")
        defer func() {
            sc := -1
        if result.Response != nil {
        sc = result.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.DeletePreparer(ctx, conversionID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Delete", nil , "Failure preparing request")
    return
    }

        resp, err := client.DeleteSender(req)
        if err != nil {
        result.Response = resp
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Delete", resp, "Failure sending request")
        return
        }

        result, err = client.DeleteResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Delete", resp, "Failure responding to request")
        return
        }

    return
}

    // DeletePreparer prepares the Delete request.
    func (client ConversionClient) DeletePreparer(ctx context.Context, conversionID string) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "geography": autorest.Encode("path",client.Geography),
        }

        pathParameters := map[string]interface{} {
        "conversionId": autorest.Encode("path",conversionID),
        }

            const APIVersion = "2.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }

    preparer := autorest.CreatePreparer(
autorest.AsDelete(),
autorest.WithCustomBaseURL("https://{geography}.atlas.microsoft.com", urlParameters),
autorest.WithPathParameters("/conversions/{conversionId}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteSender sends the Delete request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversionClient) DeleteSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteResponder handles the response to the Delete request. The method always
    // closes the http.Response Body.
    func (client ConversionClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
            autorest.ByClosing())
            result.Response = resp
            return
    }

// Get **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
//
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and
// SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools
// that apply to Azure Maps Creator.
//
// This API allows the caller to fetch a successful data conversion submitted previously using the [Conversion
// API](https://docs.microsoft.com/en-us/rest/api/maps/conversion/convertpreview).
    // Parameters:
        // conversionID - the conversion id for the content. The `conversionId` must have been obtained from a
        // successful [Conversion API](https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert) call.
func (client ConversionClient) Get(ctx context.Context, conversionID string) (result ConversionListDetailInfo, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionClient.Get")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetPreparer(ctx, conversionID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Get", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Get", resp, "Failure sending request")
        return
        }

        result, err = client.GetResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "Get", resp, "Failure responding to request")
        return
        }

    return
}

    // GetPreparer prepares the Get request.
    func (client ConversionClient) GetPreparer(ctx context.Context, conversionID string) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "geography": autorest.Encode("path",client.Geography),
        }

        pathParameters := map[string]interface{} {
        "conversionId": autorest.Encode("path",conversionID),
        }

            const APIVersion = "2.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("https://{geography}.atlas.microsoft.com", urlParameters),
autorest.WithPathParameters("/conversions/{conversionId}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSender sends the Get request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversionClient) GetSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetResponder handles the response to the Get request. The method always
    // closes the http.Response Body.
    func (client ConversionClient) GetResponder(resp *http.Response) (result ConversionListDetailInfo, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetOperation this path will be obtained from a call to POST /conversions.  While in progress, an http200 will be
// returned with no extra headers -  followed by an http200 with Resource-Location header once successfully completed.
    // Parameters:
        // operationID - the ID to query the status for the dataset create/import request.
func (client ConversionClient) GetOperation(ctx context.Context, operationID string) (result LongRunningOperationResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionClient.GetOperation")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetOperationPreparer(ctx, operationID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "creator.ConversionClient", "GetOperation", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetOperationSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "GetOperation", resp, "Failure sending request")
        return
        }

        result, err = client.GetOperationResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "GetOperation", resp, "Failure responding to request")
        return
        }

    return
}

    // GetOperationPreparer prepares the GetOperation request.
    func (client ConversionClient) GetOperationPreparer(ctx context.Context, operationID string) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "geography": autorest.Encode("path",client.Geography),
        }

        pathParameters := map[string]interface{} {
        "operationId": autorest.Encode("path",operationID),
        }

            const APIVersion = "2.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("https://{geography}.atlas.microsoft.com", urlParameters),
autorest.WithPathParameters("/conversions/operations/{operationId}",pathParameters),
autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetOperationSender sends the GetOperation request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversionClient) GetOperationSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOperationResponder handles the response to the GetOperation request. The method always
    // closes the http.Response Body.
    func (client ConversionClient) GetOperationResponder(resp *http.Response) (result LongRunningOperationResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// List **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
//
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and
// SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools
// that apply to Azure Maps Creator.
//
// This API allows the caller to fetch a list of all successful data conversions submitted previously using the
// [Conversion API](https://docs.microsoft.com/en-us/rest/api/maps/conversion/convertpreview).
//
// ### Submit List Request
//
// To list all successful conversions you will issue a `GET` request with no additional parameters.
//
// ### List Data Response
//
// The Conversion List API returns the complete list of all conversion details in `json` format.<br>
//
// Here is a sample response returning the details of two successful conversion requests:
//
// <br>
//
// ```json
// {
// "conversions":
// [
// {
// "conversionId": "54398242-ea6c-1f31-4fa6-79b1ae0fc24d",
// "udid": "31838736-8b84-11ea-bc55-0242ac130003",
// "created": "5/19/2020 9:00:00 AM +00:00",
// "description": "User provided description.",
// "featureCounts": {
// "DIR": 1,
// "LVL": 3,
// "FCL": 1,
// "UNIT": 150,
// "CTG": 8,
// "AEL": 0,
// "OPN": 10
// }
// },
// {
// "conversionId": "2acf7d32-8b84-11ea-bc55-0242ac130003",
// "udid": "1214bc58-8b84-11ea-bc55-0242ac1300039",
// "created": "5/19/2020 9:00:00 AM +00:00",
// "description": "User provided description.",
// "featureCounts": {
// "DIR": 1,
// "LVL": 3,
// "FCL": 1,
// "UNIT": 150,
// "CTG": 8,
// "AEL": 0,
// "OPN": 10
// }
// }
// ]
// }
// ```
//
// <br>
func (client ConversionClient) List(ctx context.Context) (result ConversionListResponsePage, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversionClient.List")
        defer func() {
            sc := -1
        if result.clr.Response.Response != nil {
        sc = result.clr.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        result.fn = client.listNextResults
    req, err := client.ListPreparer(ctx)
    if err != nil {
    err = autorest.NewErrorWithError(err, "creator.ConversionClient", "List", nil , "Failure preparing request")
    return
    }

        resp, err := client.ListSender(req)
        if err != nil {
        result.clr.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "List", resp, "Failure sending request")
        return
        }

        result.clr, err = client.ListResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "creator.ConversionClient", "List", resp, "Failure responding to request")
        return
        }
            if result.clr.hasNextLink() && result.clr.IsEmpty() {
            err = result.NextWithContext(ctx)
            return
            }

    return
}

    // ListPreparer prepares the List request.
    func (client ConversionClient) ListPreparer(ctx context.Context) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "geography": autorest.Encode("path",client.Geography),
        }

            const APIVersion = "2.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("https://{geography}.atlas.microsoft.com", urlParameters),
autorest.WithPath("/conversions"),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ListSender sends the List request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversionClient) ListSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ListResponder handles the response to the List request. The method always
    // closes the http.Response Body.
    func (client ConversionClient) ListResponder(resp *http.Response) (result ConversionListResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

            // listNextResults retrieves the next set of results, if any.
            func (client ConversionClient) listNextResults(ctx context.Context, lastResults ConversionListResponse) (result ConversionListResponse, err error) {
            req, err := lastResults.conversionListResponsePreparer(ctx)
            if err != nil {
            return result, autorest.NewErrorWithError(err, "creator.ConversionClient", "listNextResults", nil , "Failure preparing next results request")
            }
            if req == nil {
            return
            }
            resp, err := client.ListSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            return result, autorest.NewErrorWithError(err, "creator.ConversionClient", "listNextResults", resp, "Failure sending next results request")
            }
            result, err = client.ListResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "creator.ConversionClient", "listNextResults", resp, "Failure responding to next results request")
            }
            return
                    }

            // ListComplete enumerates all values, automatically crossing page boundaries as required.
            func (client ConversionClient) ListComplete(ctx context.Context) (result ConversionListResponseIterator, err error) {
            if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/ConversionClient.List")
            defer func() {
            sc := -1
            if result.Response().Response.Response != nil {
            sc = result.page.Response().Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
            }()
            }
                    result.page, err = client.List(ctx)
                            return
            }

