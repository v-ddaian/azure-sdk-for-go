package azmaps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// SearchClient is the client for the Search methods of the Azmaps service.
type SearchClient struct {
    BaseClient
}
// NewSearchClient creates an instance of the SearchClient client.
func NewSearchClient(subscriptionKey string, xMsClientID string) SearchClient {
    return NewSearchClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewSearchClientWithBaseURI creates an instance of the SearchClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewSearchClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) SearchClient {
        return SearchClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetSearchAddress **Address Geocoding**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// In many cases, the complete search service might be too much, for instance if you are only interested in traditional
// geocoding. Search can also be accessed for address look up exclusively. The geocoding is performed by hitting the
// geocode endpoint with just the address or partial address in question. The geocoding search index will be queried
// for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of
// typos and incomplete addresses. It will also handle everything from exact street addresses or street or
// intersections as well as higher level geographies such as city centers, counties, states etc.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the address to search for (e.g., "1 Microsoft way, Redmond, WA"), must be properly URL encoded.
        // typeahead - boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the
        // search will enter predictive mode
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // ofs - starting offset of the returned results within the full result set. Default: 0, minimum: 0 and
        // maximum: 1900
        // countrySet - comma separated string of country codes, e.g. FR,ES. This will limit the search to the
        // specified countries
        // lat - latitude where results should be biased. E.g. 37.337
        // lon - longitude where results should be biased. E.g. -121.89
        // radius - the radius in meters to for the results to be constrained to the defined area
        // topLeft - top left position of the bounding box. E.g. 37.553,-122.453
        // btmRight - bottom right position of the bounding box. E.g. 37.553,-122.453
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **Addr** = Address ranges
        //
        // **Geo** = Geographies
        //
        // **PAD** = Point Addresses
        //
        // **POI** = Points of Interest
        //
        // **Str** = Streets
        //
        // **XStr** = Cross Streets (intersections)
        //
        // Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        //
        // By default extended postal codes are included for all indexes except Geo. Extended postal code lists for
        // geographies can be quite long so they have to be explicitly requested when needed.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=PAD,Addr,POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
func (client SearchClient) GetSearchAddress(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, view string) (result SearchAddressResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchAddress")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: ofs,
         Constraints: []validation.Constraint{	{Target: "ofs", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ofs", Name: validation.InclusiveMaximum, Rule: int64(1900), Chain: nil },
        	{Target: "ofs", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchAddress", err.Error())
        }

        req, err := client.GetSearchAddressPreparer(ctx, formatParameter, query, typeahead, limit, ofs, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, view)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddress", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchAddressSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddress", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchAddressResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddress", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchAddressPreparer prepares the GetSearchAddress request.
    func (client SearchClient) GetSearchAddressPreparer(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, view string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if typeahead != nil {
        queryParameters["typeahead"] = autorest.Encode("query",*typeahead)
            } else {
            queryParameters["typeahead"] = autorest.Encode("query",false)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if ofs != nil {
        queryParameters["ofs"] = autorest.Encode("query",*ofs)
            } else {
            queryParameters["ofs"] = autorest.Encode("query",0)
        }
        if countrySet != nil && len(countrySet) > 0 {
        queryParameters["countrySet"] = autorest.Encode("query",countrySet,",")
        }
        if lat != nil {
        queryParameters["lat"] = autorest.Encode("query",*lat)
        }
        if lon != nil {
        queryParameters["lon"] = autorest.Encode("query",*lon)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(topLeft) > 0 {
        queryParameters["topLeft"] = autorest.Encode("query",topLeft)
        }
        if len(btmRight) > 0 {
        queryParameters["btmRight"] = autorest.Encode("query",btmRight)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/address/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchAddressSender sends the GetSearchAddress request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchAddressSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchAddressResponder handles the response to the GetSearchAddress request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchAddressResponder(resp *http.Response) (result SearchAddressResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchAddressReverse **Reverse Geocode to an Address**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862) into a human
// understandable street address. Most often  this is needed in tracking applications where you  receive a GPS feed
// from the device or asset and  wish to know what address where the coordinate is  located. This endpoint will return
// address  information for a given coordinate.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the applicable query specified as a comma separated string composed by latitude followed by
        // longitude e.g. "47.641268,-122.125679".
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // returnSpeedLimit - boolean. To enable return of the posted speed limit
        // heading - the directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is
        // North, 90 is East and so on, values range from -360 to 360. The precision can include upto one decimal place
        // radius - the radius in meters to for the results to be constrained to the defined area
        // number - if a number is sent in along with the request, the response may include the side of the street
        // (Left/Right) and also an offset position for that number
        // returnRoadUse - boolean. To enable return of the road use array for reverse geocodes at street level
        // roadUse - to restrict reverse geocodes to a certain type of road use. The road use array for reverse
        // geocodes can be one or more of LimitedAccess, Arterial, Terminal, Ramp, Rotary, LocalStreet
        // allowFreeformNewline - format of newlines in the formatted address.
        //
        // If true, the address will contain newlines.
        // If false, newlines will be converted to commas.
        // returnMatchType - include information on the type of match the geocoder achieved in the response.
        // entityType - specifies the level of filtering performed on geographies. Narrows the search for specified
        // geography entity types, e.g. return only municipality. The resulting response will contain the geography ID
        // as well as the entity type matched. If you provide more than one entity as a comma separated list, endpoint
        // will return the 'smallest entity available'. Returned Geometry ID can be used to get the geometry of that
        // geography via [Get Search Polygon](https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon) API.
        // The following parameters are ignored when entityType is set:
        //
        // * heading
        // * number
        // * returnRoadUse
        // * returnSpeedLimit
        // * roadUse
        // * returnMatchType
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
func (client SearchClient) GetSearchAddressReverse(ctx context.Context, formatParameter TextFormat, query string, language string, returnSpeedLimit *bool, heading *float64, radius *float64, number string, returnRoadUse *bool, roadUse string, allowFreeformNewline *bool, returnMatchType *bool, entityType EntityType, view string) (result SearchAddressReverseResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchAddressReverse")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: heading,
         Constraints: []validation.Constraint{	{Target: "heading", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "heading", Name: validation.InclusiveMaximum, Rule: float64(360), Chain: nil },
        	{Target: "heading", Name: validation.InclusiveMinimum, Rule: float64(-360), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchAddressReverse", err.Error())
        }

        req, err := client.GetSearchAddressReversePreparer(ctx, formatParameter, query, language, returnSpeedLimit, heading, radius, number, returnRoadUse, roadUse, allowFreeformNewline, returnMatchType, entityType, view)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressReverse", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchAddressReverseSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressReverse", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchAddressReverseResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressReverse", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchAddressReversePreparer prepares the GetSearchAddressReverse request.
    func (client SearchClient) GetSearchAddressReversePreparer(ctx context.Context, formatParameter TextFormat, query string, language string, returnSpeedLimit *bool, heading *float64, radius *float64, number string, returnRoadUse *bool, roadUse string, allowFreeformNewline *bool, returnMatchType *bool, entityType EntityType, view string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if returnSpeedLimit != nil {
        queryParameters["returnSpeedLimit"] = autorest.Encode("query",*returnSpeedLimit)
            } else {
            queryParameters["returnSpeedLimit"] = autorest.Encode("query",false)
        }
        if heading != nil {
        queryParameters["heading"] = autorest.Encode("query",*heading)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(number) > 0 {
        queryParameters["number"] = autorest.Encode("query",number)
        }
        if returnRoadUse != nil {
        queryParameters["returnRoadUse"] = autorest.Encode("query",*returnRoadUse)
            } else {
            queryParameters["returnRoadUse"] = autorest.Encode("query",false)
        }
        if len(roadUse) > 0 {
        queryParameters["roadUse"] = autorest.Encode("query",roadUse)
        }
        if allowFreeformNewline != nil {
        queryParameters["allowFreeformNewline"] = autorest.Encode("query",*allowFreeformNewline)
        }
        if returnMatchType != nil {
        queryParameters["returnMatchType"] = autorest.Encode("query",*returnMatchType)
        }
        if len(string(entityType)) > 0 {
        queryParameters["entityType"] = autorest.Encode("query",entityType)
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/address/reverse/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchAddressReverseSender sends the GetSearchAddressReverse request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchAddressReverseSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchAddressReverseResponder handles the response to the GetSearchAddressReverse request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchAddressReverseResponder(resp *http.Response) (result SearchAddressReverseResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchAddressReverseCrossStreet **Reverse Geocode to a Cross Street**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862) into a human
// understandable cross street. Most often this  is needed in tracking applications where you  receive a GPS feed from
// the device or asset and wish to know what address where the coordinate is  located.
// This endpoint will return cross street information  for a given coordinate.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the applicable query specified as a comma separated string composed by latitude followed by
        // longitude e.g. "47.641268,-122.125679".
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // heading - the directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is
        // North, 90 is East and so on, values range from -360 to 360. The precision can include upto one decimal place
        // radius - the radius in meters to for the results to be constrained to the defined area
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
func (client SearchClient) GetSearchAddressReverseCrossStreet(ctx context.Context, formatParameter TextFormat, query string, limit *int32, heading *float64, radius *float64, language string, view string) (result SearchAddressReverseCrossStreetResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchAddressReverseCrossStreet")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: heading,
         Constraints: []validation.Constraint{	{Target: "heading", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "heading", Name: validation.InclusiveMaximum, Rule: float64(360), Chain: nil },
        	{Target: "heading", Name: validation.InclusiveMinimum, Rule: float64(-360), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchAddressReverseCrossStreet", err.Error())
        }

        req, err := client.GetSearchAddressReverseCrossStreetPreparer(ctx, formatParameter, query, limit, heading, radius, language, view)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressReverseCrossStreet", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchAddressReverseCrossStreetSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressReverseCrossStreet", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchAddressReverseCrossStreetResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressReverseCrossStreet", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchAddressReverseCrossStreetPreparer prepares the GetSearchAddressReverseCrossStreet request.
    func (client SearchClient) GetSearchAddressReverseCrossStreetPreparer(ctx context.Context, formatParameter TextFormat, query string, limit *int32, heading *float64, radius *float64, language string, view string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if heading != nil {
        queryParameters["heading"] = autorest.Encode("query",*heading)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/address/reverse/crossStreet/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchAddressReverseCrossStreetSender sends the GetSearchAddressReverseCrossStreet request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchAddressReverseCrossStreetSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchAddressReverseCrossStreetResponder handles the response to the GetSearchAddressReverseCrossStreet request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchAddressReverseCrossStreetResponder(resp *http.Response) (result SearchAddressReverseCrossStreetResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchAddressStructured **Structured Address Geocoding**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// Azure Address Geocoding can also be accessed for  structured address look up exclusively. The geocoding search index
// will be queried for everything above the  street level data. No POIs will be returned. Note that the geocoder is
// very tolerant of typos and incomplete  addresses. It will also handle everything from exact  street addresses or
// street or intersections as well as higher level geographies such as city centers,  counties, states etc.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // countryCode - the 2 or 3 letter [ISO3166-1](https://www.iso.org/iso-3166-country-codes.html) country code
        // portion of an address. E.g. US.
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // ofs - starting offset of the returned results within the full result set. Default: 0, minimum: 0 and
        // maximum: 1900
        // streetNumber - the street number portion of an address
        // streetName - the street name portion of an address
        // crossStreet - the cross street name for the structured address
        // municipality - the municipality portion of an address
        // municipalitySubdivision - the municipality subdivision (sub/super city) for the structured address
        // countryTertiarySubdivision - the named area for the structured address
        // countrySecondarySubdivision - the county for the structured address
        // countrySubdivision - the country subdivision portion of an address
        // postalCode - the postal code portion of an address
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **Addr** = Address ranges
        //
        // **Geo** = Geographies
        //
        // **PAD** = Point Addresses
        //
        // **POI** = Points of Interest
        //
        // **Str** = Streets
        //
        // **XStr** = Cross Streets (intersections)
        //
        // Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        //
        // By default extended postal codes are included for all indexes except Geo. Extended postal code lists for
        // geographies can be quite long so they have to be explicitly requested when needed.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=PAD,Addr,POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
func (client SearchClient) GetSearchAddressStructured(ctx context.Context, formatParameter TextFormat, countryCode string, language string, limit *int32, ofs *int32, streetNumber string, streetName string, crossStreet string, municipality string, municipalitySubdivision string, countryTertiarySubdivision string, countrySecondarySubdivision string, countrySubdivision string, postalCode string, extendedPostalCodesFor string, view string) (result SearchAddressStructuredResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchAddressStructured")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: ofs,
         Constraints: []validation.Constraint{	{Target: "ofs", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ofs", Name: validation.InclusiveMaximum, Rule: int64(1900), Chain: nil },
        	{Target: "ofs", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchAddressStructured", err.Error())
        }

        req, err := client.GetSearchAddressStructuredPreparer(ctx, formatParameter, countryCode, language, limit, ofs, streetNumber, streetName, crossStreet, municipality, municipalitySubdivision, countryTertiarySubdivision, countrySecondarySubdivision, countrySubdivision, postalCode, extendedPostalCodesFor, view)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressStructured", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchAddressStructuredSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressStructured", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchAddressStructuredResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchAddressStructured", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchAddressStructuredPreparer prepares the GetSearchAddressStructured request.
    func (client SearchClient) GetSearchAddressStructuredPreparer(ctx context.Context, formatParameter TextFormat, countryCode string, language string, limit *int32, ofs *int32, streetNumber string, streetName string, crossStreet string, municipality string, municipalitySubdivision string, countryTertiarySubdivision string, countrySecondarySubdivision string, countrySubdivision string, postalCode string, extendedPostalCodesFor string, view string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "countryCode": autorest.Encode("query",countryCode),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if ofs != nil {
        queryParameters["ofs"] = autorest.Encode("query",*ofs)
            } else {
            queryParameters["ofs"] = autorest.Encode("query",0)
        }
        if len(streetNumber) > 0 {
        queryParameters["streetNumber"] = autorest.Encode("query",streetNumber)
        }
        if len(streetName) > 0 {
        queryParameters["streetName"] = autorest.Encode("query",streetName)
        }
        if len(crossStreet) > 0 {
        queryParameters["crossStreet"] = autorest.Encode("query",crossStreet)
        }
        if len(municipality) > 0 {
        queryParameters["municipality"] = autorest.Encode("query",municipality)
        }
        if len(municipalitySubdivision) > 0 {
        queryParameters["municipalitySubdivision"] = autorest.Encode("query",municipalitySubdivision)
        }
        if len(countryTertiarySubdivision) > 0 {
        queryParameters["countryTertiarySubdivision"] = autorest.Encode("query",countryTertiarySubdivision)
        }
        if len(countrySecondarySubdivision) > 0 {
        queryParameters["countrySecondarySubdivision"] = autorest.Encode("query",countrySecondarySubdivision)
        }
        if len(countrySubdivision) > 0 {
        queryParameters["countrySubdivision"] = autorest.Encode("query",countrySubdivision)
        }
        if len(postalCode) > 0 {
        queryParameters["postalCode"] = autorest.Encode("query",postalCode)
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/address/structured/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchAddressStructuredSender sends the GetSearchAddressStructured request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchAddressStructuredSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchAddressStructuredResponder handles the response to the GetSearchAddressStructured request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchAddressStructuredResponder(resp *http.Response) (result SearchAddressStructuredResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchFuzzy **Free Form Search**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// The basic default API is Free Form Search which handles the most fuzzy of inputs handling any combination of address
// or POI tokens. This search API is the canonical 'single line search'. The Free Form Search API is a seamless
// combination of POI search and geocoding. The API can also be weighted with a contextual position (lat./lon. pair),
// or fully constrained by a coordinate and radius, or it can be executed more generally without any geo biasing anchor
// point.<br><br>We strongly advise you to use the 'countrySet' parameter to specify only the countries for which your
// application needs coverage, as the default behavior will be to search the entire world, potentially returning
// unnecessary results.<br><br> E.g.: `countrySet`=US,FR <br><br>Please see [Search
// Coverage](https://docs.microsoft.com/azure/location-based-services/geocoding-coverage) for a complete list of all
// the supported countries.<br><br>Most Search queries default to `maxFuzzyLevel`=2 to gain performance and also reduce
// unusual results. This new default can be overridden as needed per request by passing in the query param
// `maxFuzzyLevel`=3 or 4.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the applicable query string (e.g., "seattle", "pizza"). Can _also_ be specified as a comma separated
        // string composed by latitude followed by longitude (e.g., "47.641268, -122.125679"). Must be properly URL
        // encoded.
        // typeahead - boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the
        // search will enter predictive mode
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // ofs - starting offset of the returned results within the full result set. Default: 0, minimum: 0 and
        // maximum: 1900
        // categorySet - a comma-separated list of category set IDs which could be used to restrict the result to
        // specific Points of Interest categories. ID order does not matter. When multiple category identifiers are
        // provided, only POIs that belong to (at least) one of the categories from the provided list will be returned.
        // The list of supported categories can be discovered using  [POI Categories
        // API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        //
        // * **categorySet=7315** (Search Points of Interest from category Restaurant)
        //
        // * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French
        // Restaurant)
        // countrySet - comma separated string of country codes, e.g. FR,ES. This will limit the search to the
        // specified countries
        // lat - latitude where results should be biased. E.g. 37.337
        // lon - longitude where results should be biased. E.g. -121.89
        // radius - the radius in meters to for the results to be constrained to the defined area
        // topLeft - top left position of the bounding box. E.g. 37.553,-122.453
        // btmRight - bottom right position of the bounding box. E.g. 37.553,-122.453
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **Addr** = Address ranges
        //
        // **Geo** = Geographies
        //
        // **PAD** = Point Addresses
        //
        // **POI** = Points of Interest
        //
        // **Str** = Streets
        //
        // **XStr** = Cross Streets (intersections)
        //
        // Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        //
        // By default extended postal codes are included for all indexes except Geo. Extended postal code lists for
        // geographies can be quite long so they have to be explicitly requested when needed.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=PAD,Addr,POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // minFuzzyLevel - minimum fuzziness level to be used. Default: 1, minimum: 1 and maximum: 4
        //
        // * Level 1 has no spell checking.
        //
        // * Level 2 uses normal n-gram spell checking. For example, query "restrant" can be matched to "restaurant."
        //
        // * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for
        // "rstrnt" to "restaurant" matching. Shingle spell checking is for "mountainview" to "mountain view" matching.
        //
        // * Level 4 doesn’t add any more spell checking functions.
        //
        //
        //
        // The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop
        // searching at the level specified by maxFuzzyLevel.
        // maxFuzzyLevel - maximum fuzziness level to be used. Default: 2, minimum: 1 and maximum: 4
        //
        // * Level 1 has no spell checking.
        //
        // * Level 2 uses normal n-gram spell checking. For example, query "restrant" can be matched to "restaurant."
        //
        // * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for
        // "rstrnt" to "restaurant" matching. Shingle spell checking is for "mountainview" to "mountain view" matching.
        //
        // * Level 4 doesn’t add any more spell checking functions.
        //
        //
        //
        // The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop
        // searching at the level specified by maxFuzzyLevel.
        // idxSet - a comma separated list of indexes which should be utilized for the search. Item order does not
        // matter. Available indexes are: Addr = Address range interpolation, Geo = Geographies, PAD = Point Addresses,
        // POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections)
        // brandSet - a comma-separated list of brand names which could be used to restrict the result to specific
        // brands. Item order does not matter. When multiple brands are provided, only results that belong to (at
        // least) one of the provided list will be returned. Brands that contain a "," in their name should be put into
        // quotes.
        //
        // Usage examples:
        //
        // brandSet=Foo
        //
        // brandSet=Foo,Bar
        //
        // brandSet="A,B,C Comma",Bar
        // connectorSet - a comma-separated list of connector types which could be used to restrict the result to
        // Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple
        // connector types are provided, only results that belong to (at least) one of the provided list will be
        // returned.
        //
        // Available connector types are:
        // * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region.
        // They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug & socket types
        // - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        // * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the
        // original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination
        // with 120V single phase or up to 240V single phase infrastructure.
        // * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a
        // cable and plug attached to the charging point.
        // * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set
        // into the charging point.
        // * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the
        // original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase
        // infrastructure.
        // * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and
        // industrial partners. Because of this is is also known as the TEPCO's connector. It supports fast DC
        // charging.
        // * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is
        // sometime referred to as by some combination of the standard, the color and the fact that is a single phase
        // connector. The connector usually has the "P+N+E, 6h" configuration.
        // * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        // * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to
        // either Tesla's proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or
        // the modified Type 2 (DC over Type 2) in Europe.
        //
        // Usage examples:
        //
        // connectorSet=IEC62196Type2CableAttached
        // connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
        // openingHours - hours of operation for a POI (Points of Interest). The availability of hours of operation
        // will vary based on the data available.
        // Supported value: nextSevenDays
func (client SearchClient) GetSearchFuzzy(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, categorySet []int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, minFuzzyLevel *int32, maxFuzzyLevel *int32, idxSet []SearchIndexSet, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (result SearchFuzzyResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchFuzzy")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: ofs,
         Constraints: []validation.Constraint{	{Target: "ofs", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ofs", Name: validation.InclusiveMaximum, Rule: int64(1900), Chain: nil },
        	{Target: "ofs", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}},
        { TargetValue: minFuzzyLevel,
         Constraints: []validation.Constraint{	{Target: "minFuzzyLevel", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "minFuzzyLevel", Name: validation.InclusiveMaximum, Rule: int64(4), Chain: nil },
        	{Target: "minFuzzyLevel", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: maxFuzzyLevel,
         Constraints: []validation.Constraint{	{Target: "maxFuzzyLevel", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "maxFuzzyLevel", Name: validation.InclusiveMaximum, Rule: int64(4), Chain: nil },
        	{Target: "maxFuzzyLevel", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchFuzzy", err.Error())
        }

        req, err := client.GetSearchFuzzyPreparer(ctx, formatParameter, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, minFuzzyLevel, maxFuzzyLevel, idxSet, brandSet, connectorSet, view, openingHours)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchFuzzy", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchFuzzySender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchFuzzy", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchFuzzyResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchFuzzy", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchFuzzyPreparer prepares the GetSearchFuzzy request.
    func (client SearchClient) GetSearchFuzzyPreparer(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, categorySet []int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, minFuzzyLevel *int32, maxFuzzyLevel *int32, idxSet []SearchIndexSet, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if typeahead != nil {
        queryParameters["typeahead"] = autorest.Encode("query",*typeahead)
            } else {
            queryParameters["typeahead"] = autorest.Encode("query",false)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if ofs != nil {
        queryParameters["ofs"] = autorest.Encode("query",*ofs)
            } else {
            queryParameters["ofs"] = autorest.Encode("query",0)
        }
        if categorySet != nil && len(categorySet) > 0 {
        queryParameters["categorySet"] = autorest.Encode("query",categorySet,",")
        }
        if countrySet != nil && len(countrySet) > 0 {
        queryParameters["countrySet"] = autorest.Encode("query",countrySet,",")
        }
        if lat != nil {
        queryParameters["lat"] = autorest.Encode("query",*lat)
        }
        if lon != nil {
        queryParameters["lon"] = autorest.Encode("query",*lon)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(topLeft) > 0 {
        queryParameters["topLeft"] = autorest.Encode("query",topLeft)
        }
        if len(btmRight) > 0 {
        queryParameters["btmRight"] = autorest.Encode("query",btmRight)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if minFuzzyLevel != nil {
        queryParameters["minFuzzyLevel"] = autorest.Encode("query",*minFuzzyLevel)
            } else {
            queryParameters["minFuzzyLevel"] = autorest.Encode("query",1)
        }
        if maxFuzzyLevel != nil {
        queryParameters["maxFuzzyLevel"] = autorest.Encode("query",*maxFuzzyLevel)
            } else {
            queryParameters["maxFuzzyLevel"] = autorest.Encode("query",2)
        }
        if idxSet != nil && len(idxSet) > 0 {
        queryParameters["idxSet"] = autorest.Encode("query",idxSet,",")
        }
        if brandSet != nil && len(brandSet) > 0 {
        queryParameters["brandSet"] = autorest.Encode("query",brandSet,",")
        }
        if connectorSet != nil && len(connectorSet) > 0 {
        queryParameters["connectorSet"] = autorest.Encode("query",connectorSet,",")
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }
        if len(string(openingHours)) > 0 {
        queryParameters["openingHours"] = autorest.Encode("query",openingHours)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/fuzzy/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchFuzzySender sends the GetSearchFuzzy request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchFuzzySender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchFuzzyResponder handles the response to the GetSearchFuzzy request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchFuzzyResponder(resp *http.Response) (result SearchFuzzyResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchNearby **Nearby Search**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// If you have a use case for only retrieving POI results around a specific location, the nearby search method may be
// the right choice. This endpoint will only return POI results, and does not take in a search query parameter.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // lat - latitude where results should be biased. E.g. 37.337.
        // lon - longitude where results should be biased. E.g. -121.89.
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // ofs - starting offset of the returned results within the full result set. Default: 0, minimum: 0 and
        // maximum: 1900
        // categorySet - a comma-separated list of category set IDs which could be used to restrict the result to
        // specific Points of Interest categories. ID order does not matter. When multiple category identifiers are
        // provided, only POIs that belong to (at least) one of the categories from the provided list will be returned.
        // The list of supported categories can be discovered using  [POI Categories
        // API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        //
        // * **categorySet=7315** (Search Points of Interest from category Restaurant)
        //
        // * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French
        // Restaurant)
        // countrySet - comma separated string of country codes, e.g. FR,ES. This will limit the search to the
        // specified countries
        // radius - the radius in meters to for the results to be constrained to the defined area, Min value is 1, Max
        // Value is 50000.
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **Addr** = Address ranges
        //
        // **Geo** = Geographies
        //
        // **PAD** = Point Addresses
        //
        // **POI** = Points of Interest
        //
        // **Str** = Streets
        //
        // **XStr** = Cross Streets (intersections)
        //
        // Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        //
        // By default extended postal codes are included for all indexes except Geo. Extended postal code lists for
        // geographies can be quite long so they have to be explicitly requested when needed.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=PAD,Addr,POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // brandSet - a comma-separated list of brand names which could be used to restrict the result to specific
        // brands. Item order does not matter. When multiple brands are provided, only results that belong to (at
        // least) one of the provided list will be returned. Brands that contain a "," in their name should be put into
        // quotes.
        //
        // Usage examples:
        //
        // brandSet=Foo
        //
        // brandSet=Foo,Bar
        //
        // brandSet="A,B,C Comma",Bar
        // connectorSet - a comma-separated list of connector types which could be used to restrict the result to
        // Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple
        // connector types are provided, only results that belong to (at least) one of the provided list will be
        // returned.
        //
        // Available connector types are:
        // * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region.
        // They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug & socket types
        // - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        // * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the
        // original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination
        // with 120V single phase or up to 240V single phase infrastructure.
        // * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a
        // cable and plug attached to the charging point.
        // * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set
        // into the charging point.
        // * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the
        // original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase
        // infrastructure.
        // * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and
        // industrial partners. Because of this is is also known as the TEPCO's connector. It supports fast DC
        // charging.
        // * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is
        // sometime referred to as by some combination of the standard, the color and the fact that is a single phase
        // connector. The connector usually has the "P+N+E, 6h" configuration.
        // * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        // * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to
        // either Tesla's proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or
        // the modified Type 2 (DC over Type 2) in Europe.
        //
        // Usage examples:
        //
        // connectorSet=IEC62196Type2CableAttached
        // connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
func (client SearchClient) GetSearchNearby(ctx context.Context, formatParameter TextFormat, lat float64, lon float64, limit *int32, ofs *int32, categorySet []int32, countrySet []string, radius *float64, language string, extendedPostalCodesFor string, brandSet []string, connectorSet []ConnectorSet, view string) (result SearchNearbyResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchNearby")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: ofs,
         Constraints: []validation.Constraint{	{Target: "ofs", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ofs", Name: validation.InclusiveMaximum, Rule: int64(1900), Chain: nil },
        	{Target: "ofs", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchNearby", err.Error())
        }

        req, err := client.GetSearchNearbyPreparer(ctx, formatParameter, lat, lon, limit, ofs, categorySet, countrySet, radius, language, extendedPostalCodesFor, brandSet, connectorSet, view)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchNearby", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchNearbySender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchNearby", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchNearbyResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchNearby", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchNearbyPreparer prepares the GetSearchNearby request.
    func (client SearchClient) GetSearchNearbyPreparer(ctx context.Context, formatParameter TextFormat, lat float64, lon float64, limit *int32, ofs *int32, categorySet []int32, countrySet []string, radius *float64, language string, extendedPostalCodesFor string, brandSet []string, connectorSet []ConnectorSet, view string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if ofs != nil {
        queryParameters["ofs"] = autorest.Encode("query",*ofs)
            } else {
            queryParameters["ofs"] = autorest.Encode("query",0)
        }
        if categorySet != nil && len(categorySet) > 0 {
        queryParameters["categorySet"] = autorest.Encode("query",categorySet,",")
        }
        if countrySet != nil && len(countrySet) > 0 {
        queryParameters["countrySet"] = autorest.Encode("query",countrySet,",")
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if brandSet != nil && len(brandSet) > 0 {
        queryParameters["brandSet"] = autorest.Encode("query",brandSet,",")
        }
        if connectorSet != nil && len(connectorSet) > 0 {
        queryParameters["connectorSet"] = autorest.Encode("query",connectorSet,",")
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/nearby/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchNearbySender sends the GetSearchNearby request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchNearbySender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchNearbyResponder handles the response to the GetSearchNearby request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchNearbyResponder(resp *http.Response) (result SearchNearbyResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchPOI **Get POI by Name**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// Points of Interest (POI) Search allows you to request POI results by name.  Search supports additional query
// parameters such as language and filtering results by area of interest driven by country or bounding box.  Endpoint
// will return only POI results matching the query string. Response includes POI details such as address, coordinate
// location and category.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded.
        // typeahead - boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the
        // search will enter predictive mode
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // ofs - starting offset of the returned results within the full result set. Default: 0, minimum: 0 and
        // maximum: 1900
        // categorySet - a comma-separated list of category set IDs which could be used to restrict the result to
        // specific Points of Interest categories. ID order does not matter. When multiple category identifiers are
        // provided, only POIs that belong to (at least) one of the categories from the provided list will be returned.
        // The list of supported categories can be discovered using  [POI Categories
        // API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        //
        // * **categorySet=7315** (Search Points of Interest from category Restaurant)
        //
        // * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French
        // Restaurant)
        // countrySet - comma separated string of country codes, e.g. FR,ES. This will limit the search to the
        // specified countries
        // lat - latitude where results should be biased. E.g. 37.337
        // lon - longitude where results should be biased. E.g. -121.89
        // radius - the radius in meters to for the results to be constrained to the defined area
        // topLeft - top left position of the bounding box. E.g. 37.553,-122.453
        // btmRight - bottom right position of the bounding box. E.g. 37.553,-122.453
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **POI** = Points of Interest
        //
        // Value should be **POI** or **None** to disable extended postal codes.
        //
        // By default extended postal codes are included.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // brandSet - a comma-separated list of brand names which could be used to restrict the result to specific
        // brands. Item order does not matter. When multiple brands are provided, only results that belong to (at
        // least) one of the provided list will be returned. Brands that contain a "," in their name should be put into
        // quotes.
        //
        // Usage examples:
        //
        // brandSet=Foo
        //
        // brandSet=Foo,Bar
        //
        // brandSet="A,B,C Comma",Bar
        // connectorSet - a comma-separated list of connector types which could be used to restrict the result to
        // Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple
        // connector types are provided, only results that belong to (at least) one of the provided list will be
        // returned.
        //
        // Available connector types are:
        // * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region.
        // They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug & socket types
        // - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        // * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the
        // original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination
        // with 120V single phase or up to 240V single phase infrastructure.
        // * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a
        // cable and plug attached to the charging point.
        // * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set
        // into the charging point.
        // * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the
        // original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase
        // infrastructure.
        // * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and
        // industrial partners. Because of this is is also known as the TEPCO's connector. It supports fast DC
        // charging.
        // * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is
        // sometime referred to as by some combination of the standard, the color and the fact that is a single phase
        // connector. The connector usually has the "P+N+E, 6h" configuration.
        // * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        // * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to
        // either Tesla's proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or
        // the modified Type 2 (DC over Type 2) in Europe.
        //
        // Usage examples:
        //
        // connectorSet=IEC62196Type2CableAttached
        // connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
        // openingHours - hours of operation for a POI (Points of Interest). The availability of hours of operation
        // will vary based on the data available.
        // Supported value: nextSevenDays
func (client SearchClient) GetSearchPOI(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, categorySet []int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (result SearchPoiResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchPOI")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: ofs,
         Constraints: []validation.Constraint{	{Target: "ofs", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ofs", Name: validation.InclusiveMaximum, Rule: int64(1900), Chain: nil },
        	{Target: "ofs", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchPOI", err.Error())
        }

        req, err := client.GetSearchPOIPreparer(ctx, formatParameter, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, brandSet, connectorSet, view, openingHours)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOI", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchPOISender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOI", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchPOIResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOI", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchPOIPreparer prepares the GetSearchPOI request.
    func (client SearchClient) GetSearchPOIPreparer(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, categorySet []int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if typeahead != nil {
        queryParameters["typeahead"] = autorest.Encode("query",*typeahead)
            } else {
            queryParameters["typeahead"] = autorest.Encode("query",false)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if ofs != nil {
        queryParameters["ofs"] = autorest.Encode("query",*ofs)
            } else {
            queryParameters["ofs"] = autorest.Encode("query",0)
        }
        if categorySet != nil && len(categorySet) > 0 {
        queryParameters["categorySet"] = autorest.Encode("query",categorySet,",")
        }
        if countrySet != nil && len(countrySet) > 0 {
        queryParameters["countrySet"] = autorest.Encode("query",countrySet,",")
        }
        if lat != nil {
        queryParameters["lat"] = autorest.Encode("query",*lat)
        }
        if lon != nil {
        queryParameters["lon"] = autorest.Encode("query",*lon)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(topLeft) > 0 {
        queryParameters["topLeft"] = autorest.Encode("query",topLeft)
        }
        if len(btmRight) > 0 {
        queryParameters["btmRight"] = autorest.Encode("query",btmRight)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if brandSet != nil && len(brandSet) > 0 {
        queryParameters["brandSet"] = autorest.Encode("query",brandSet,",")
        }
        if connectorSet != nil && len(connectorSet) > 0 {
        queryParameters["connectorSet"] = autorest.Encode("query",connectorSet,",")
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }
        if len(string(openingHours)) > 0 {
        queryParameters["openingHours"] = autorest.Encode("query",openingHours)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/poi/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchPOISender sends the GetSearchPOI request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchPOISender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchPOIResponder handles the response to the GetSearchPOI request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchPOIResponder(resp *http.Response) (result SearchPoiResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchPOICategory **Get POI by Category**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// Points of Interest (POI) Category Search allows you to request POI results from given category. Search allows to
// query POIs from one category at a time.  Endpoint will only return POI results which are categorized as specified.
// Response includes POI details such as address, coordinate location and classification.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the POI category to search for (e.g., "AIRPORT", "RESTAURANT"), must be properly URL encoded.
        // Supported main categories can be requested by calling [Get Search POI Category Tree
        // API](https://aka.ms/AzureMapsPOICategoryTree). List of available categories can also be found
        // [here](https://docs.microsoft.com/azure/azure-maps/supported-search-categories). We recommend to use POI
        // Search Category Tree API to request the supported categories.
        // typeahead - boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the
        // search will enter predictive mode
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // ofs - starting offset of the returned results within the full result set. Default: 0, minimum: 0 and
        // maximum: 1900
        // categorySet - a comma-separated list of category set IDs which could be used to restrict the result to
        // specific Points of Interest categories. ID order does not matter. When multiple category identifiers are
        // provided, only POIs that belong to (at least) one of the categories from the provided list will be returned.
        // The list of supported categories can be discovered using  [POI Categories
        // API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        //
        // * **categorySet=7315** (Search Points of Interest from category Restaurant)
        //
        // * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French
        // Restaurant)
        // countrySet - comma separated string of country codes, e.g. FR,ES. This will limit the search to the
        // specified countries
        // lat - latitude where results should be biased. E.g. 37.337
        // lon - longitude where results should be biased. E.g. -121.89
        // radius - the radius in meters to for the results to be constrained to the defined area
        // topLeft - top left position of the bounding box. E.g. 37.553,-122.453
        // btmRight - bottom right position of the bounding box. E.g. 37.553,-122.453
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **Addr** = Address ranges
        //
        // **Geo** = Geographies
        //
        // **PAD** = Point Addresses
        //
        // **POI** = Points of Interest
        //
        // **Str** = Streets
        //
        // **XStr** = Cross Streets (intersections)
        //
        // Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        //
        // By default extended postal codes are included for all indexes except Geo. Extended postal code lists for
        // geographies can be quite long so they have to be explicitly requested when needed.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=PAD,Addr,POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // brandSet - a comma-separated list of brand names which could be used to restrict the result to specific
        // brands. Item order does not matter. When multiple brands are provided, only results that belong to (at
        // least) one of the provided list will be returned. Brands that contain a "," in their name should be put into
        // quotes.
        //
        // Usage examples:
        //
        // brandSet=Foo
        //
        // brandSet=Foo,Bar
        //
        // brandSet="A,B,C Comma",Bar
        // connectorSet - a comma-separated list of connector types which could be used to restrict the result to
        // Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple
        // connector types are provided, only results that belong to (at least) one of the provided list will be
        // returned.
        //
        // Available connector types are:
        // * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region.
        // They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug & socket types
        // - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        // * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the
        // original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination
        // with 120V single phase or up to 240V single phase infrastructure.
        // * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a
        // cable and plug attached to the charging point.
        // * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set
        // into the charging point.
        // * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the
        // original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase
        // infrastructure.
        // * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and
        // industrial partners. Because of this is is also known as the TEPCO's connector. It supports fast DC
        // charging.
        // * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is
        // sometime referred to as by some combination of the standard, the color and the fact that is a single phase
        // connector. The connector usually has the "P+N+E, 6h" configuration.
        // * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        // * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to
        // either Tesla's proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or
        // the modified Type 2 (DC over Type 2) in Europe.
        //
        // Usage examples:
        //
        // connectorSet=IEC62196Type2CableAttached
        // connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
        // openingHours - hours of operation for a POI (Points of Interest). The availability of hours of operation
        // will vary based on the data available.
        // Supported value: nextSevenDays
func (client SearchClient) GetSearchPOICategory(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, categorySet []int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (result SearchPoiCategoryResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchPOICategory")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: ofs,
         Constraints: []validation.Constraint{	{Target: "ofs", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ofs", Name: validation.InclusiveMaximum, Rule: int64(1900), Chain: nil },
        	{Target: "ofs", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "GetSearchPOICategory", err.Error())
        }

        req, err := client.GetSearchPOICategoryPreparer(ctx, formatParameter, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, brandSet, connectorSet, view, openingHours)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOICategory", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchPOICategorySender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOICategory", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchPOICategoryResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOICategory", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchPOICategoryPreparer prepares the GetSearchPOICategory request.
    func (client SearchClient) GetSearchPOICategoryPreparer(ctx context.Context, formatParameter TextFormat, query string, typeahead *bool, limit *int32, ofs *int32, categorySet []int32, countrySet []string, lat *float64, lon *float64, radius *float64, topLeft string, btmRight string, language string, extendedPostalCodesFor string, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if typeahead != nil {
        queryParameters["typeahead"] = autorest.Encode("query",*typeahead)
            } else {
            queryParameters["typeahead"] = autorest.Encode("query",false)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if ofs != nil {
        queryParameters["ofs"] = autorest.Encode("query",*ofs)
            } else {
            queryParameters["ofs"] = autorest.Encode("query",0)
        }
        if categorySet != nil && len(categorySet) > 0 {
        queryParameters["categorySet"] = autorest.Encode("query",categorySet,",")
        }
        if countrySet != nil && len(countrySet) > 0 {
        queryParameters["countrySet"] = autorest.Encode("query",countrySet,",")
        }
        if lat != nil {
        queryParameters["lat"] = autorest.Encode("query",*lat)
        }
        if lon != nil {
        queryParameters["lon"] = autorest.Encode("query",*lon)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(topLeft) > 0 {
        queryParameters["topLeft"] = autorest.Encode("query",topLeft)
        }
        if len(btmRight) > 0 {
        queryParameters["btmRight"] = autorest.Encode("query",btmRight)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if brandSet != nil && len(brandSet) > 0 {
        queryParameters["brandSet"] = autorest.Encode("query",brandSet,",")
        }
        if connectorSet != nil && len(connectorSet) > 0 {
        queryParameters["connectorSet"] = autorest.Encode("query",connectorSet,",")
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }
        if len(string(openingHours)) > 0 {
        queryParameters["openingHours"] = autorest.Encode("query",openingHours)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/poi/category/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchPOICategorySender sends the GetSearchPOICategory request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchPOICategorySender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchPOICategoryResponder handles the response to the GetSearchPOICategory request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchPOICategoryResponder(resp *http.Response) (result SearchPoiCategoryResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchPOICategoryTreePreview **Get POI Category Tree**
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// POI Category API provides a full list of supported Points of Interest (POI) categories and subcategories together
// with their translations and synonyms. The returned content can be used to provide more meaningful results through
// other Search Service APIs, like [Get Search POI](https://docs.microsoft.com/rest/api/maps/search/getsearchpoi).
    // Parameters:
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, except NGT and NGT-Latn. Language tag is case insensitive. When data in specified language is not
        // available for a specific field, default language is used (English).
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for
        // details.
func (client SearchClient) GetSearchPOICategoryTreePreview(ctx context.Context, language string) (result PoiCategoryResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchPOICategoryTreePreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetSearchPOICategoryTreePreviewPreparer(ctx, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOICategoryTreePreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchPOICategoryTreePreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOICategoryTreePreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchPOICategoryTreePreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPOICategoryTreePreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchPOICategoryTreePreviewPreparer prepares the GetSearchPOICategoryTreePreview request.
    func (client SearchClient) GetSearchPOICategoryTreePreviewPreparer(ctx context.Context, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/poi/category/tree/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchPOICategoryTreePreviewSender sends the GetSearchPOICategoryTreePreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchPOICategoryTreePreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchPOICategoryTreePreviewResponder handles the response to the GetSearchPOICategoryTreePreview request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchPOICategoryTreePreviewResponder(resp *http.Response) (result PoiCategoryResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSearchPolygon **Get Polygon**
//
//
// **Applies to**: S1 pricing tier.
//
//
// The Get Polygon service allows you to request the geometry data such as a city or country  outline for a set of
// entities, previously retrieved from an Online Search request in GeoJSON format. The geometry  ID is returned in the
// dataSources object under "geometry" and "id" in either a Search Address or Search Fuzzy call.
//
// Please note that any geometry ID retrieved from an Online Search endpoint has a limited lifetime. The client  should
// not store geometry IDs in persistent storage for later referral, as the stability of these identifiers is  not
// guaranteed for a long period of time. It is expected that a request to the Polygon method is made within a  few
// minutes of the request to the Online Search method that provided the ID. The service allows for batch  requests up
// to 20 identifiers.
    // Parameters:
        // geometries - comma separated list of geometry UUIDs, previously retrieved from an Online Search request.
func (client SearchClient) GetSearchPolygon(ctx context.Context, geometries string) (result SearchPolygonResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.GetSearchPolygon")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetSearchPolygonPreparer(ctx, geometries)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPolygon", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSearchPolygonSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPolygon", resp, "Failure sending request")
        return
        }

        result, err = client.GetSearchPolygonResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "GetSearchPolygon", resp, "Failure responding to request")
        return
        }

    return
}

    // GetSearchPolygonPreparer prepares the GetSearchPolygon request.
    func (client SearchClient) GetSearchPolygonPreparer(ctx context.Context, geometries string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "geometries": autorest.Encode("query",geometries),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/polygon/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSearchPolygonSender sends the GetSearchPolygon request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) GetSearchPolygonSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchPolygonResponder handles the response to the GetSearchPolygon request. The method always
    // closes the http.Response Body.
    func (client SearchClient) GetSearchPolygonResponder(resp *http.Response) (result SearchPolygonResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostSearchAddressBatch **Search Address Batch API**
//
//
// **Applies to**: S1 pricing tier.
//
//
//
// The Search Address Batch API sends batches of queries to [Search Address
// API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can
// call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows
// caller to batch up to **10,000** queries and sync API up to **100** queries.
// ### Submit Synchronous Batch Request
// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will
// respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later.
// The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The
// number of batch items is limited to **100** for this API.
// ```
// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// ```
// ### Submit Asynchronous Batch Request
// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// - It allows the retrieval of results in a separate call (multiple downloads are possible).
// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// - The number of batch items is limited to **10,000** for this API.
//
// When you make a request by using async request, by default the service returns a 202 response code along a redirect
// URL in the Location field of the response header. This URL should be checked periodically until the response data or
// error information is available.
// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the
// expiration period.
//
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch `POST` request to Azure Maps
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request has been accepted.
//
// > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any
// other `Error` status code.
//
// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to
// download the results of the batch request.
// This status URI looks like following:
//
// ```
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
//
// ### POST Body for Batch Request
// To send the _search address_ queries you will use a `POST` request where the request body will contain the
// `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample
// request body containing 5 _search address_ queries:
//
//
// ```json
// {
// "batchItems": [
// {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
// {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
// {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
// {"query": "?query=Pike Pl, Seattle, WA 98101&lat=47.610970&lon=-122.342469&radius=1000"},
// {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&limit=1"}
// ]
// }
// ```
//
// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and
// subscription-key. It can accept any of the supported _search address_ [URI
// parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string
// values in the _search address_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it
// should also be properly URL-encoded.
//
//
// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch
// should contain at least **1** query.
//
//
// ### Download Asynchronous Batch Results
// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download
// URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
//
// ```
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a `GET` request using the _download URL_.
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
//
// > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
//
//
//
// ### Batch Response Model
// The returned data content is similar for async and sync requests. When downloading the results of an async batch
// request, if the batch has finished processing, the response body contains the batch response. This batch response
// contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and
// `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems`
// array which contains a response for each and every query in the batch request. The `batchItems` will contain the
// results in the exact same order the original queries were sent in the batch request. Each item in `batchItems`
// contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
//
// -
// [`SearchAddressResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#searchaddressresponse)
// - If the query completed successfully.
//
// - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
//
//
// Here's a sample Batch Response with 2 _successful_ and 1 _failed_ result:
//
//
// ```json
// {
// "summary": {
// "successfulRequests": 2,
// "totalRequests": 3
// },
// "batchItems": [
// {
// "statusCode": 200,
// "response":
// {
// "summary": {
// "query": "one microsoft way redmond wa 98052"
// },
// "results": [
// {
// "position": {
// "lat": 47.63989,
// "lon": -122.12509
// }
// }
// ]
// }
// },
// {
// "statusCode": 200,
// "response":
// {
// "summary": {
// "query": "pike pl seattle wa 98101"
// },
// "results": [
// {
// "position": {
// "lat": 47.60963,
// "lon": -122.34215
// }
// }
// ]
// }
// },
// {
// "statusCode": 400,
// "response":
// {
// "error":
// {
// "code": "400 BadRequest",
// "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
// }
// }
// }
// ]
// }
// ```
    // Parameters:
        // searchAddressBatchRequestBody - the list of address geocoding queries/requests to process. The list can
        // contain  a max of 10,000 queries and must contain at least 1 query.
func (client SearchClient) PostSearchAddressBatch(ctx context.Context, searchAddressBatchRequestBody BatchRequestBody) (result SearchPostSearchAddressBatchFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.PostSearchAddressBatch")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.PostSearchAddressBatchPreparer(ctx, searchAddressBatchRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAddressBatch", nil , "Failure preparing request")
    return
    }

        result, err = client.PostSearchAddressBatchSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAddressBatch", nil , "Failure sending request")
        return
        }

    return
}

    // PostSearchAddressBatchPreparer prepares the PostSearchAddressBatch request.
    func (client SearchClient) PostSearchAddressBatchPreparer(ctx context.Context, searchAddressBatchRequestBody BatchRequestBody) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/address/batch/{format}",pathParameters),
autorest.WithJSON(searchAddressBatchRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostSearchAddressBatchSender sends the PostSearchAddressBatch request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) PostSearchAddressBatchSender(req *http.Request) (future SearchPostSearchAddressBatchFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // PostSearchAddressBatchResponder handles the response to the PostSearchAddressBatch request. The method always
    // closes the http.Response Body.
    func (client SearchClient) PostSearchAddressBatchResponder(resp *http.Response) (result BatchResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostSearchAddressReverseBatch **Search Address Reverse Batch API**
//
//
// **Applies to**: S1 pricing tier.
//
//
//
// The Search Address Batch API sends batches of queries to [Search Address Reverse
// API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call.
// You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The
// async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
// ### Submit Synchronous Batch Request
// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will
// respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later.
// The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The
// number of batch items is limited to **100** for this API.
// ```
// POST
// https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// ```
// ### Submit Asynchronous Batch Request
// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// - It allows the retrieval of results in a separate call (multiple downloads are possible).
// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// - The number of batch items is limited to **10,000** for this API.
//
// When you make a request by using async request, by default the service returns a 202 response code along a redirect
// URL in the Location field of the response header. This URL should be checked periodically until the response data or
// error information is available.
// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the
// expiration period.
//
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch `POST` request to Azure Maps
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request has been accepted.
//
// > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any
// other `Error` status code.
//
// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to
// download the results of the batch request.
// This status URI looks like following:
//
// ```
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
//
// ### POST Body for Batch Request
// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the
// `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample
// request body containing 5 _search address reverse_ queries:
//
//
// ```json
// {
// "batchItems": [
// {"query": "?query=48.858561,2.294911"},
// {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
// {"query": "?query=47.621028,-122.348170"},
// {"query": "?query=43.722990,10.396695"},
// {"query": "?query=40.750958,-73.982336"}
// ]
// }
// ```
//
// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path,
// api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI
// parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The
// string values in the _search address reverse_ query must be properly escaped (e.g. " character should be escaped
// with \\ ) and it should also be properly URL-encoded.
//
//
// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch
// should contain at least **1** query.
//
//
// ### Download Asynchronous Batch Results
// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download
// URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
//
// ```
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a `GET` request using the _download URL_.
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
//
// > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
//
//
//
// ### Batch Response Model
// The returned data content is similar for async and sync requests. When downloading the results of an async batch
// request, if the batch has finished processing, the response body contains the batch response. This batch response
// contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and
// `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems`
// array which contains a response for each and every query in the batch request. The `batchItems` will contain the
// results in the exact same order the original queries were sent in the batch request. Each item in `batchItems`
// contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
//
// -
// [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse)
// - If the query completed successfully.
//
// - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
//
//
// Here's a sample Batch Response with 2 _successful_ and 1 _failed_ result:
//
//
// ```json
// {
// "summary": {
// "successfulRequests": 2,
// "totalRequests": 3
// },
// "batchItems": [
// {
// "statusCode": 200,
// "response":
// {
// "summary": {
// "queryTime": 11
// },
// "addresses": [
// {
// "address": {
// "country": "France",
// "freeformAddress": "Avenue Anatole France, 75007 Paris"
// },
// "position": "48.858490,2.294820"
// }
// ]
// }
// },
// {
// "statusCode": 200,
// "response":
// {
// "summary": {
// "queryTime": 1
// },
// "addresses": [
// {
// "address": {
// "country": "United States of America",
// "freeformAddress": "157th Pl NE, Redmond WA 98052"
// },
// "position": "47.640470,-122.129430"
// }
// ]
// }
// },
// {
// "statusCode": 400,
// "response":
// {
// "error":
// {
// "code": "400 BadRequest",
// "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
// }
// }
// }
// ]
// }
// ```
    // Parameters:
        // searchAddressReverseBatchRequestBody - the list of reverse geocoding queries/requests to process. The list
        // can contain  a max of 10,000 queries and must contain at least 1 query.
func (client SearchClient) PostSearchAddressReverseBatch(ctx context.Context, searchAddressReverseBatchRequestBody BatchRequestBody) (result SearchPostSearchAddressReverseBatchFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.PostSearchAddressReverseBatch")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.PostSearchAddressReverseBatchPreparer(ctx, searchAddressReverseBatchRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAddressReverseBatch", nil , "Failure preparing request")
    return
    }

        result, err = client.PostSearchAddressReverseBatchSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAddressReverseBatch", nil , "Failure sending request")
        return
        }

    return
}

    // PostSearchAddressReverseBatchPreparer prepares the PostSearchAddressReverseBatch request.
    func (client SearchClient) PostSearchAddressReverseBatchPreparer(ctx context.Context, searchAddressReverseBatchRequestBody BatchRequestBody) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/address/reverse/batch/{format}",pathParameters),
autorest.WithJSON(searchAddressReverseBatchRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostSearchAddressReverseBatchSender sends the PostSearchAddressReverseBatch request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) PostSearchAddressReverseBatchSender(req *http.Request) (future SearchPostSearchAddressReverseBatchFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // PostSearchAddressReverseBatchResponder handles the response to the PostSearchAddressReverseBatch request. The method always
    // closes the http.Response Body.
    func (client SearchClient) PostSearchAddressReverseBatchResponder(resp *http.Response) (result BatchResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostSearchAlongRoute **Applies to**: S0 and S1 pricing tiers.
//
//
// The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified route. This search
// is constrained by specifying the `maxDetourTime` limiting measure.<br><br>To send the route-points you will use a
// `POST` request where the request body will contain the `route` object represented as a `GeoJSON LineString` type and
// the `Content-Type` header will be set to `application/json`. Each route-point in `route` is represented as a
// `GeoJSON Position` type i.e. an array where the _longitude_ value is followed by the _latitude_ value and the
// _altitude_ value is ignored. The `route` should contain at least 2 route-points.<br><br>It is possible that original
// route will be altered, some of it's points may be skipped. If the route that passes through the found point is
// faster than the original one, the `detourTime` value in the response is negative.
    // Parameters:
        // query - the POI name to search for (e.g., "statue of liberty", "starbucks", "pizza"). Must be properly URL
        // encoded.
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // maxDetourTime - maximum detour time of the point of interest in seconds. Max value is 3600 seconds
        // searchAlongRouteRequestBody - this represents the route to search along and should be a valid `GeoJSON
        // LineString` type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details.
        // categorySet - a comma-separated list of category set IDs which could be used to restrict the result to
        // specific Points of Interest categories. ID order does not matter. When multiple category identifiers are
        // provided, only POIs that belong to (at least) one of the categories from the provided list will be returned.
        // The list of supported categories can be discovered using  [POI Categories
        // API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        //
        // * **categorySet=7315** (Search Points of Interest from category Restaurant)
        //
        // * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French
        // Restaurant)
        // limit - maximum number of responses that will be returned. Default value is 10. Max value is 20
        // brandSet - a comma-separated list of brand names which could be used to restrict the result to specific
        // brands. Item order does not matter. When multiple brands are provided, only results that belong to (at
        // least) one of the provided list will be returned. Brands that contain a "," in their name should be put into
        // quotes.
        //
        // Usage examples:
        //
        // brandSet=Foo
        //
        // brandSet=Foo,Bar
        //
        // brandSet="A,B,C Comma",Bar
        // connectorSet - a comma-separated list of connector types which could be used to restrict the result to
        // Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple
        // connector types are provided, only results that belong to (at least) one of the provided list will be
        // returned.
        //
        // Available connector types are:
        // * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region.
        // They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug & socket types
        // - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        // * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the
        // original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination
        // with 120V single phase or up to 240V single phase infrastructure.
        // * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a
        // cable and plug attached to the charging point.
        // * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set
        // into the charging point.
        // * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is
        // based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current
        // (DC) contacts to allow DC fast charging.
        // * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the
        // original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase
        // infrastructure.
        // * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and
        // industrial partners. Because of this is is also known as the TEPCO's connector. It supports fast DC
        // charging.
        // * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is
        // sometime referred to as by some combination of the standard, the color and the fact that is a single phase
        // connector. The connector usually has the "P+N+E, 6h" configuration.
        // * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        // * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to
        // either Tesla's proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or
        // the modified Type 2 (DC over Type 2) in Europe.
        //
        // Usage examples:
        //
        // connectorSet=IEC62196Type2CableAttached
        // connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
        // openingHours - hours of operation for a POI (Points of Interest). The availability of hours of operation
        // will vary based on the data available.
        // Supported value: nextSevenDays
func (client SearchClient) PostSearchAlongRoute(ctx context.Context, query string, formatParameter TextFormat, maxDetourTime int32, searchAlongRouteRequestBody SearchAlongRouteRequestBody, categorySet []int32, limit *int32, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (result SearchAlongRouteResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.PostSearchAlongRoute")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: maxDetourTime,
         Constraints: []validation.Constraint{	{Target: "maxDetourTime", Name: validation.InclusiveMaximum, Rule: int64(3600), Chain: nil }}},
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil },
        }}}},
        { TargetValue: searchAlongRouteRequestBody,
         Constraints: []validation.Constraint{	{Target: "searchAlongRouteRequestBody.Route", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "searchAlongRouteRequestBody.Route.Coordinates", Name: validation.Null, Rule: true, Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "PostSearchAlongRoute", err.Error())
        }

        req, err := client.PostSearchAlongRoutePreparer(ctx, query, formatParameter, maxDetourTime, searchAlongRouteRequestBody, categorySet, limit, brandSet, connectorSet, view, openingHours)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAlongRoute", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostSearchAlongRouteSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAlongRoute", resp, "Failure sending request")
        return
        }

        result, err = client.PostSearchAlongRouteResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchAlongRoute", resp, "Failure responding to request")
        return
        }

    return
}

    // PostSearchAlongRoutePreparer prepares the PostSearchAlongRoute request.
    func (client SearchClient) PostSearchAlongRoutePreparer(ctx context.Context, query string, formatParameter TextFormat, maxDetourTime int32, searchAlongRouteRequestBody SearchAlongRouteRequestBody, categorySet []int32, limit *int32, brandSet []string, connectorSet []ConnectorSet, view string, openingHours OpeningHours) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "maxDetourTime": autorest.Encode("query",maxDetourTime),
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if categorySet != nil && len(categorySet) > 0 {
        queryParameters["categorySet"] = autorest.Encode("query",categorySet,",")
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if brandSet != nil && len(brandSet) > 0 {
        queryParameters["brandSet"] = autorest.Encode("query",brandSet,",")
        }
        if connectorSet != nil && len(connectorSet) > 0 {
        queryParameters["connectorSet"] = autorest.Encode("query",connectorSet,",")
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }
        if len(string(openingHours)) > 0 {
        queryParameters["openingHours"] = autorest.Encode("query",openingHours)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/alongRoute/{format}",pathParameters),
autorest.WithJSON(searchAlongRouteRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostSearchAlongRouteSender sends the PostSearchAlongRoute request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) PostSearchAlongRouteSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostSearchAlongRouteResponder handles the response to the PostSearchAlongRoute request. The method always
    // closes the http.Response Body.
    func (client SearchClient) PostSearchAlongRouteResponder(resp *http.Response) (result SearchAlongRouteResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostSearchFuzzyBatch **Search Fuzzy Batch API**
//
//
// **Applies to**: S1 pricing tier.
//
//
//
// The Search Address Batch API sends batches of queries to [Search Fuzzy
// API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can
// call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API
// allows caller to batch up to **10,000** queries and sync API up to **100** queries.
// ### Submit Synchronous Batch Request
// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will
// respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later.
// The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The
// number of batch items is limited to **100** for this API.
// ```
// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// ```
// ### Submit Asynchronous Batch Request
// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// - It allows the retrieval of results in a separate call (multiple downloads are possible).
// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// - The number of batch items is limited to **10,000** for this API.
//
// When you make a request by using async request, by default the service returns a 202 response code along a redirect
// URL in the Location field of the response header. This URL should be checked periodically until the response data or
// error information is available.
// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the
// expiration period.
//
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch `POST` request to Azure Maps
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request has been accepted.
//
// > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any
// other `Error` status code.
//
// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to
// download the results of the batch request.
// This status URI looks like following:
//
// ```
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
//
// ### POST Body for Batch Request
// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the
// `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample
// request body containing 5 _search fuzzy_ queries:
//
//
// ```json
// {
// "batchItems": [
// {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
// {"query": "?query=Statue Of Liberty&limit=2"},
// {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
// {"query": "?query=Space Needle"},
// {"query": "?query=pizza&limit=10"}
// ]
// }
// ```
//
// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and
// subscription-key. It can accept any of the supported _search fuzzy_ [URI
// parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values
// in the _search fuzzy_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it should
// also be properly URL-encoded.
//
//
// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch
// should contain at least **1** query.
//
//
// ### Download Asynchronous Batch Results
// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download
// URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
//
// ```
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a `GET` request using the _download URL_.
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
//
// > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
//
//
//
// ### Batch Response Model
// The returned data content is similar for async and sync requests. When downloading the results of an async batch
// request, if the batch has finished processing, the response body contains the batch response. This batch response
// contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and
// `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems`
// array which contains a response for each and every query in the batch request. The `batchItems` will contain the
// results in the exact same order the original queries were sent in the batch request. Each item in `batchItems`
// contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
//
// - [`SearchFuzzyResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchfuzzyresponse)
// - If the query completed successfully.
//
// - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
//
//
// Here's a sample Batch Response with 2 _successful_ and 1 _failed_ result:
//
//
// ```json
// {
// "summary": {
// "successfulRequests": 2,
// "totalRequests": 3
// },
// "batchItems": [
// {
// "statusCode": 200,
// "response":
// {
// "summary": {
// "query": "atm"
// },
// "results": [
// {
// "type": "POI",
// "poi": {
// "name": "ATM at Wells Fargo"
// },
// "address": {
// "country": "United States Of America",
// "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
// }
// }
// ]
// }
// },
// {
// "statusCode": 200,
// "response":
// {
// "summary": {
// "query": "statue of liberty"
// },
// "results": [
// {
// "type": "POI",
// "poi": {
// "name": "Statue of Liberty"
// },
// "address": {
// "country": "United States Of America",
// "freeformAddress": "New York, NY 10004"
// }
// }
// ]
// }
// },
// {
// "statusCode": 400,
// "response":
// {
// "error":
// {
// "code": "400 BadRequest",
// "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
// }
// }
// }
// ]
// }
// ```
    // Parameters:
        // searchFuzzyBatchRequestBody - the list of search fuzzy queries/requests to process. The list can contain  a
        // max of 10,000 queries and must contain at least 1 query.
func (client SearchClient) PostSearchFuzzyBatch(ctx context.Context, searchFuzzyBatchRequestBody BatchRequestBody) (result SearchPostSearchFuzzyBatchFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.PostSearchFuzzyBatch")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.PostSearchFuzzyBatchPreparer(ctx, searchFuzzyBatchRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchFuzzyBatch", nil , "Failure preparing request")
    return
    }

        result, err = client.PostSearchFuzzyBatchSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchFuzzyBatch", nil , "Failure sending request")
        return
        }

    return
}

    // PostSearchFuzzyBatchPreparer prepares the PostSearchFuzzyBatch request.
    func (client SearchClient) PostSearchFuzzyBatchPreparer(ctx context.Context, searchFuzzyBatchRequestBody BatchRequestBody) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/fuzzy/batch/{format}",pathParameters),
autorest.WithJSON(searchFuzzyBatchRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostSearchFuzzyBatchSender sends the PostSearchFuzzyBatch request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) PostSearchFuzzyBatchSender(req *http.Request) (future SearchPostSearchFuzzyBatchFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // PostSearchFuzzyBatchResponder handles the response to the PostSearchFuzzyBatch request. The method always
    // closes the http.Response Body.
    func (client SearchClient) PostSearchFuzzyBatchResponder(resp *http.Response) (result BatchResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostSearchInsideGeometry **Applies to**: S0 and S1 pricing tiers.
//
// The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The
// search results that fall inside the geometry/geometries will be returned.<br><br>To send the geometry you will use a
// `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the
// `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as
// Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:<ul><li>**GeoJSON
// FeatureCollection** <br>The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the
// recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of
// 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following
// conditions:<ul style="list-style-type:none"><li>A `Feature` object for the Polygon geometry can have a max of 50
// coordinates and it's properties must be empty.</li><li>A `Feature` object for the Circle geometry is composed of a
// _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the
// object's properties along with the _subType_ property whose value should be 'Circle'.</li></ul><br> Please see the
// Examples section below for a sample `FeatureCollection` representation.<br><br></li><li>**GeoJSON
// GeometryCollection**<br>The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the
// recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of
// 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples
// section below for a sample `GeometryCollection` representation.<br><br></li><li>**GeoJSON Polygon**<br>The
// `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains
// a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a
// sample `Polygon` representation.<br><br></li></ul>.<br><br>
    // Parameters:
        // query - the POI name to search for (e.g., "statue of liberty", "starbucks", "pizza"). Must be properly URL
        // encoded.
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // searchInsideGeometryRequestBody - this represents the geometry for one or more geographical features (parks,
        // state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to [RFC
        // 7946](https://tools.ietf.org/html/rfc7946) for details.
        // limit - maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // categorySet - a comma-separated list of category set IDs which could be used to restrict the result to
        // specific Points of Interest categories. ID order does not matter. When multiple category identifiers are
        // provided, only POIs that belong to (at least) one of the categories from the provided list will be returned.
        // The list of supported categories can be discovered using  [POI Categories
        // API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        //
        // * **categorySet=7315** (Search Points of Interest from category Restaurant)
        //
        // * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French
        // Restaurant)
        // extendedPostalCodesFor - indexes for which extended postal codes should be included in the results.
        //
        // Available indexes are:
        //
        // **Addr** = Address ranges
        //
        // **Geo** = Geographies
        //
        // **PAD** = Point Addresses
        //
        // **POI** = Points of Interest
        //
        // **Str** = Streets
        //
        // **XStr** = Cross Streets (intersections)
        //
        // Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        //
        // By default extended postal codes are included for all indexes except Geo. Extended postal code lists for
        // geographies can be quite long so they have to be explicitly requested when needed.
        //
        // Usage examples:
        //
        // extendedPostalCodesFor=POI
        //
        // extendedPostalCodesFor=PAD,Addr,POI
        //
        // extendedPostalCodesFor=None
        //
        // Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is
        // region-dependent.
        // idxSet - a comma separated list of indexes which should be utilized for the search. Item order does not
        // matter. Available indexes are: Addr = Address range interpolation, Geo = Geographies, PAD = Point Addresses,
        // POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections)
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
        // openingHours - hours of operation for a POI (Points of Interest). The availability of hours of operation
        // will vary based on the data available.
        // Supported value: nextSevenDays
func (client SearchClient) PostSearchInsideGeometry(ctx context.Context, query string, formatParameter TextFormat, searchInsideGeometryRequestBody SearchInsideGeometryRequestBody, limit *int32, language string, categorySet []int32, extendedPostalCodesFor string, idxSet []SearchIndexSet, view string, openingHours OpeningHours) (result SearchGeometryResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SearchClient.PostSearchInsideGeometry")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: limit,
         Constraints: []validation.Constraint{	{Target: "limit", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "limit", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil },
        	{Target: "limit", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.SearchClient", "PostSearchInsideGeometry", err.Error())
        }

        req, err := client.PostSearchInsideGeometryPreparer(ctx, query, formatParameter, searchInsideGeometryRequestBody, limit, language, categorySet, extendedPostalCodesFor, idxSet, view, openingHours)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchInsideGeometry", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostSearchInsideGeometrySender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchInsideGeometry", resp, "Failure sending request")
        return
        }

        result, err = client.PostSearchInsideGeometryResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.SearchClient", "PostSearchInsideGeometry", resp, "Failure responding to request")
        return
        }

    return
}

    // PostSearchInsideGeometryPreparer prepares the PostSearchInsideGeometry request.
    func (client SearchClient) PostSearchInsideGeometryPreparer(ctx context.Context, query string, formatParameter TextFormat, searchInsideGeometryRequestBody SearchInsideGeometryRequestBody, limit *int32, language string, categorySet []int32, extendedPostalCodesFor string, idxSet []SearchIndexSet, view string, openingHours OpeningHours) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
            } else {
            queryParameters["limit"] = autorest.Encode("query",10)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if categorySet != nil && len(categorySet) > 0 {
        queryParameters["categorySet"] = autorest.Encode("query",categorySet,",")
        }
        if len(extendedPostalCodesFor) > 0 {
        queryParameters["extendedPostalCodesFor"] = autorest.Encode("query",extendedPostalCodesFor)
        }
        if idxSet != nil && len(idxSet) > 0 {
        queryParameters["idxSet"] = autorest.Encode("query",idxSet,",")
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }
        if len(string(openingHours)) > 0 {
        queryParameters["openingHours"] = autorest.Encode("query",openingHours)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/search/geometry/{format}",pathParameters),
autorest.WithJSON(searchInsideGeometryRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostSearchInsideGeometrySender sends the PostSearchInsideGeometry request. The method will close the
    // http.Response Body if it receives an error.
    func (client SearchClient) PostSearchInsideGeometrySender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostSearchInsideGeometryResponder handles the response to the PostSearchInsideGeometry request. The method always
    // closes the http.Response Body.
    func (client SearchClient) PostSearchInsideGeometryResponder(resp *http.Response) (result SearchGeometryResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

