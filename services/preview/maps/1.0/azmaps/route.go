package azmaps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/autorest/date"
)

// RouteClient is the client for the Route methods of the Azmaps service.
type RouteClient struct {
    BaseClient
}
// NewRouteClient creates an instance of the RouteClient client.
func NewRouteClient(subscriptionKey string, xMsClientID string) RouteClient {
    return NewRouteClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewRouteClientWithBaseURI creates an instance of the RouteClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewRouteClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) RouteClient {
        return RouteClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetRouteDirections **Applies to**: S0 and S1 pricing tiers.
//
//
// Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route
// will take into account factors such as current traffic and the typical road speeds on the requested day of the week
// and time of day.
//
// Information returned includes the distance, estimated travel time, and a representation of the route geometry.
// Additional routing information such as optimized waypoint order or turn by turn instructions is also available,
// depending on the options selected.
//
// Routing service provides a set of parameters for a detailed description of vehicle-specific Consumption Model.
// Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed
// explanation of the concepts and parameters involved.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the Coordinates through which the route is calculated, delimited by a colon.  A minimum of two
        // coordinates is required.  The first one is the origin and the last is the destination of the route. Optional
        // coordinates in-between act as WayPoints in the route.  You can pass up to 150 WayPoints.
        // maxAlternatives - number of desired alternative routes to be calculated. Default: 0, minimum: 0 and maximum:
        // 5
        // alternativeType - controls the optimality, with respect to the given planning criteria, of the calculated
        // alternatives compared to the reference route.
        // minDeviationDistance - all alternative routes returned will follow the reference route (see section POST
        // Requests) from the origin point of the calculateRoute request for at least this number of meters. Can only
        // be used when reconstructing a route. The minDeviationDistance parameter cannot be used in conjunction with
        // arriveAt
        // arriveAt - the date and time of arrival at the destination point. It must be specified as a dateTime. When a
        // time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value
        // must be in the future. The arriveAt parameter cannot be used in conjunction with departAt,
        // minDeviationDistance or minDeviationTime.
        // departAt - the date and time of departure from the origin point. Departure times apart from now must be
        // specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the
        // origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00).
        // minDeviationTime - all alternative routes returned will follow the reference route (see section POST
        // Requests) from the origin point of the calculateRoute request for at least this number of seconds. Can only
        // be used when reconstructing a route. The minDeviationTime parameter cannot be used in conjunction with
        // arriveAt. Default value is 0. Setting )minDeviationTime_ to a value greater than zero has the following
        // consequences:
        // - The origin point of the _calculateRoute_ Request must be on
        // (or very near) the input reference route.
        // - If this is not the case, an error is returned.
        // - However, the origin point does not need to be at the beginning
        // of the input reference route (it can be thought of as the current
        // vehicle position on the reference route).
        // - The reference route, returned as the first route in the _calculateRoute_
        // Response, will start at the origin point specified in the _calculateRoute_
        // Request. The initial part of the input reference route up until the origin
        // point will be excluded from the Response.
        // - The values of _minDeviationDistance_ and _minDeviationTime_ determine
        // how far alternative routes will be guaranteed to follow the reference
        // route from the origin point onwards.
        // - The route must use _departAt_.
        // - The _vehicleHeading_ is ignored.
        // instructionsType - if specified, guidance instructions will be returned. Note that the instructionsType
        // parameter cannot be used in conjunction with routeRepresentation=none
        // language - the language parameter determines the language of the guidance messages. Proper nouns (the names
        // of streets, plazas, etc.) are returned in the specified  language, or if that is not available, they are
        // returned in an available language  that is close to it. Allowed values are (a subset of) the IETF language
        // tags. The currently supported  languages are listed in the [Supported languages
        // section](https://docs.microsoft.com/azure/azure-maps/supported-languages).
        //
        // Default value: en-GB
        // computeBestOrder - re-order the route waypoints using a fast heuristic algorithm to reduce the route length.
        // Yields best results when used in conjunction with routeType _shortest_. Notice that origin and destination
        // are excluded from the optimized waypoint indices. To include origin and destination in the response, please
        // increase all the indices by 1 to account for the origin, and then add the destination as the final index.
        // Possible values are true or false. True computes a better order if possible, but is not allowed to be used
        // in conjunction with maxAlternatives value greater than 0 or in conjunction with circle waypoints. False will
        // use the locations in the given order and not allowed to be used in conjunction with routeRepresentation
        // _none_.
        // routeRepresentation - specifies the representation of the set of routes provided as response. This parameter
        // value can only be used in conjunction with computeBestOrder=true.
        // computeTravelTimeFor - specifies whether to return additional travel times using different types of traffic
        // information (none, historic, live) as well as the default best-estimate travel time.
        // vehicleHeading - the directional heading of the vehicle in degrees starting at true North and continuing in
        // clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees.
        // Possible values 0-359
        // report - specifies which data should be reported for diagnosis purposes. The only possible value is
        // _effectiveSettings_. Reports the effective parameters or data used when calling the API. In the case of
        // defaulted parameters the default will be reflected where the parameter was not specified by the caller.
        // sectionType - specifies which of the section types is reported in the route response. <br><br>For example if
        // sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can
        // be used. The default sectionType refers to the travelMode input. By default travelMode is set to car
        // vehicleAxleWeight - weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per
        // axle are not considered.
        // vehicleWidth - width of the vehicle in meters. A value of 0 means that width restrictions are not
        // considered.
        // vehicleHeight - height of the vehicle in meters. A value of 0 means that height restrictions are not
        // considered.
        // vehicleLength - length of the vehicle in meters. A value of 0 means that length restrictions are not
        // considered.
        // vehicleMaxSpeed - maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to
        // check whether a vehicle is allowed on motorways.
        //
        // * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route
        // planning.
        //
        // * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60
        // km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as
        // this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the
        // current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
        // vehicleWeight - weight of the vehicle in kilograms.
        //
        // * It is mandatory if any of the *Efficiency parameters are set.
        //
        // * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are
        // considered.
        //
        // * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then
        // weight restrictions are considered.
        //
        // * In all other cases, this parameter is ignored.
        //
        // Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
        // vehicleCommercial - vehicle is used for commercial purposes and thus may not be allowed to drive  on some
        // roads.
        // windingness - level of turns for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // hilliness - degree of hilliness for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // travelMode - the mode of travel for the requested route. If not defined, default is 'car'. Note that the
        // requested travelMode may not be available for the entire route. Where the requested travelMode is not
        // available for a particular section, the travelMode element of the response for that section will be "other".
        // Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not
        // available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not
        // be used.
        // avoid - specifies something that the route calculation should try to avoid when determining the route. Can
        // be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'.
        // In calculateReachableRange requests, the value alreadyUsedRoads must not be used.
        // traffic - possible values:
        // * true - Do consider all available traffic information during routing
        // * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
        // during routing, the effect of historic traffic on effective road speeds is still incorporated.
        // routeType - the type of route requested.
        // vehicleLoadType - types of cargo that may be classified as hazardous materials and restricted from some
        // roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for
        // use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used
        // for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only
        // considered for travelMode=truck.
        // vehicleEngineType - engine type of the vehicle. When a detailed Consumption Model is specified, it must be
        // consistent with the value of **vehicleEngineType**.
        // constantSpeedConsumptionInLitersPerHundredkm - specifies the speed-dependent component of consumption.
        //
        // Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on
        // a consumption curve. Consumption rates for speeds not in the list are found as follows:
        //
        // * by linear interpolation, if the given speed lies in between two speeds in the list
        //
        // * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two
        // points in the list
        //
        // The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same
        // speed. If it only contains a single point, then the consumption rate of that point is used without further
        // processing.
        //
        // Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest
        // speed. This ensures that extrapolation does not lead to negative consumption rates.
        //
        // Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative
        // consumption rate for any smaller speed.
        //
        // The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
        //
        // Sensible Values : 50,6.3:130,11.5
        //
        // **Note** : This parameter is required for **The Combustion Consumption Model**.
        // currentFuelInLiters - specifies the current supply of fuel in liters.
        //
        // Sensible Values : 55
        // auxiliaryPowerInLitersPerHour - specifies the amount of fuel consumed for sustaining auxiliary systems of
        // the vehicle, in liters per hour.
        //
        // It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
        //
        // Sensible Values : 0.2
        // fuelEnergyDensityInMJoulesPerLiter - specifies the amount of chemical energy stored in one liter of fuel in
        // megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved
        // or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel
        // fuel.
        //
        // This parameter is required if any ***Efficiency** parameter is set.
        //
        // Sensible Values : 34.2
        // accelerationEfficiency - specifies the efficiency of converting chemical energy stored in fuel to kinetic
        // energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed).
        // ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using
        // **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **decelerationEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
        // decelerationEfficiency - specifies the efficiency of converting kinetic energy to saved (not consumed) fuel
        // when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained
        // by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **accelerationEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
        // uphillEfficiency - specifies the efficiency of converting chemical energy stored in fuel to potential energy
        // when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed).
        // ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using
        // **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **downhillEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**downhillEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
        // downhillEfficiency - specifies the efficiency of converting potential energy to saved (not consumed) fuel
        // when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is
        // obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **uphillEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**uphillEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
        // constantSpeedConsumptionInkWhPerHundredkm - specifies the speed-dependent component of consumption.
        //
        // Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption
        // curve. Consumption rates for speeds not in the list are found as follows:
        //
        // * by linear interpolation, if the given speed lies in between two speeds in the list
        //
        // * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two
        // points in the list
        //
        // The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same
        // speed. If it only contains a single point, then the consumption rate of that point is used without further
        // processing.
        //
        // Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest
        // speed. This ensures that extrapolation does not lead to negative consumption rates.
        //
        // Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative
        // consumption rate for any smaller  speed.
        //
        // The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
        //
        // Sensible Values : 50,8.2:130,21.3
        //
        // This parameter is required for **Electric consumption model**.
        // currentChargeInkWh - specifies the current electric energy supply in kilowatt hours (kWh).
        //
        // This parameter co-exists with **maxChargeInkWh** parameter.
        //
        // The range of values allowed are 0.0 to **maxChargeInkWh**.
        //
        // Sensible Values : 43
        // maxChargeInkWh - specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in
        // the vehicle's battery.
        //
        // This parameter co-exists with **currentChargeInkWh** parameter.
        //
        // Minimum value has to be greater than or equal to **currentChargeInkWh**.
        //
        // Sensible Values : 85
        // auxiliaryPowerInkW - specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts
        // (kW).
        //
        // It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
        //
        // Sensible Values : 1.7
func (client RouteClient) GetRouteDirections(ctx context.Context, formatParameter TextFormat, query string, maxAlternatives *int32, alternativeType AlternativeRouteType, minDeviationDistance *int32, arriveAt *date.Time, departAt *date.Time, minDeviationTime *int32, instructionsType RouteInstructionsType, language string, computeBestOrder *bool, routeRepresentation RouteRepresentation, computeTravelTimeFor ComputeTravelTimeFor, vehicleHeading *int32, report string, sectionType SectionType, vehicleAxleWeight *int32, vehicleWidth *float64, vehicleHeight *float64, vehicleLength *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, vehicleCommercial *bool, windingness Windingness, hilliness Hilliness, travelMode TravelMode, avoid Avoid, traffic *bool, routeType RouteType, vehicleLoadType VehicleLoadType, vehicleEngineType VehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm *float64, currentFuelInLiters *float64, auxiliaryPowerInLitersPerHour *float64, fuelEnergyDensityInMJoulesPerLiter *float64, accelerationEfficiency *float64, decelerationEfficiency *float64, uphillEfficiency *float64, downhillEfficiency *float64, constantSpeedConsumptionInkWhPerHundredkm string, currentChargeInkWh string, maxChargeInkWh string, auxiliaryPowerInkW string) (result RouteDirectionsResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RouteClient.GetRouteDirections")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: maxAlternatives,
         Constraints: []validation.Constraint{	{Target: "maxAlternatives", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "maxAlternatives", Name: validation.InclusiveMaximum, Rule: int64(5), Chain: nil },
        	{Target: "maxAlternatives", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}},
        { TargetValue: vehicleHeading,
         Constraints: []validation.Constraint{	{Target: "vehicleHeading", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "vehicleHeading", Name: validation.InclusiveMaximum, Rule: int64(359), Chain: nil },
        	{Target: "vehicleHeading", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.RouteClient", "GetRouteDirections", err.Error())
        }

        req, err := client.GetRouteDirectionsPreparer(ctx, formatParameter, query, maxAlternatives, alternativeType, minDeviationDistance, arriveAt, departAt, minDeviationTime, instructionsType, language, computeBestOrder, routeRepresentation, computeTravelTimeFor, vehicleHeading, report, sectionType, vehicleAxleWeight, vehicleWidth, vehicleHeight, vehicleLength, vehicleMaxSpeed, vehicleWeight, vehicleCommercial, windingness, hilliness, travelMode, avoid, traffic, routeType, vehicleLoadType, vehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm, currentFuelInLiters, auxiliaryPowerInLitersPerHour, fuelEnergyDensityInMJoulesPerLiter, accelerationEfficiency, decelerationEfficiency, uphillEfficiency, downhillEfficiency, constantSpeedConsumptionInkWhPerHundredkm, currentChargeInkWh, maxChargeInkWh, auxiliaryPowerInkW)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "GetRouteDirections", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetRouteDirectionsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "GetRouteDirections", resp, "Failure sending request")
        return
        }

        result, err = client.GetRouteDirectionsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "GetRouteDirections", resp, "Failure responding to request")
        return
        }

    return
}

    // GetRouteDirectionsPreparer prepares the GetRouteDirections request.
    func (client RouteClient) GetRouteDirectionsPreparer(ctx context.Context, formatParameter TextFormat, query string, maxAlternatives *int32, alternativeType AlternativeRouteType, minDeviationDistance *int32, arriveAt *date.Time, departAt *date.Time, minDeviationTime *int32, instructionsType RouteInstructionsType, language string, computeBestOrder *bool, routeRepresentation RouteRepresentation, computeTravelTimeFor ComputeTravelTimeFor, vehicleHeading *int32, report string, sectionType SectionType, vehicleAxleWeight *int32, vehicleWidth *float64, vehicleHeight *float64, vehicleLength *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, vehicleCommercial *bool, windingness Windingness, hilliness Hilliness, travelMode TravelMode, avoid Avoid, traffic *bool, routeType RouteType, vehicleLoadType VehicleLoadType, vehicleEngineType VehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm *float64, currentFuelInLiters *float64, auxiliaryPowerInLitersPerHour *float64, fuelEnergyDensityInMJoulesPerLiter *float64, accelerationEfficiency *float64, decelerationEfficiency *float64, uphillEfficiency *float64, downhillEfficiency *float64, constantSpeedConsumptionInkWhPerHundredkm string, currentChargeInkWh string, maxChargeInkWh string, auxiliaryPowerInkW string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if maxAlternatives != nil {
        queryParameters["maxAlternatives"] = autorest.Encode("query",*maxAlternatives)
            } else {
            queryParameters["maxAlternatives"] = autorest.Encode("query",0)
        }
        if len(string(alternativeType)) > 0 {
        queryParameters["alternativeType"] = autorest.Encode("query",alternativeType)
            } else {
            queryParameters["alternativeType"] = autorest.Encode("query","anyRoute")
        }
        if minDeviationDistance != nil {
        queryParameters["minDeviationDistance"] = autorest.Encode("query",*minDeviationDistance)
            } else {
            queryParameters["minDeviationDistance"] = autorest.Encode("query",0)
        }
        if arriveAt != nil {
        queryParameters["arriveAt"] = autorest.Encode("query",*arriveAt)
        }
        if departAt != nil {
        queryParameters["departAt"] = autorest.Encode("query",*departAt)
        }
        if minDeviationTime != nil {
        queryParameters["minDeviationTime"] = autorest.Encode("query",*minDeviationTime)
            } else {
            queryParameters["minDeviationTime"] = autorest.Encode("query",0)
        }
        if len(string(instructionsType)) > 0 {
        queryParameters["instructionsType"] = autorest.Encode("query",instructionsType)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if computeBestOrder != nil {
        queryParameters["computeBestOrder"] = autorest.Encode("query",*computeBestOrder)
            } else {
            queryParameters["computeBestOrder"] = autorest.Encode("query",false)
        }
        if len(string(routeRepresentation)) > 0 {
        queryParameters["routeRepresentation"] = autorest.Encode("query",routeRepresentation)
            } else {
            queryParameters["routeRepresentation"] = autorest.Encode("query","polyline")
        }
        if len(string(computeTravelTimeFor)) > 0 {
        queryParameters["computeTravelTimeFor"] = autorest.Encode("query",computeTravelTimeFor)
            } else {
            queryParameters["computeTravelTimeFor"] = autorest.Encode("query","none")
        }
        if vehicleHeading != nil {
        queryParameters["vehicleHeading"] = autorest.Encode("query",*vehicleHeading)
        }
        if len(report) > 0 {
        queryParameters["report"] = autorest.Encode("query",report)
        }
        if len(string(sectionType)) > 0 {
        queryParameters["sectionType"] = autorest.Encode("query",sectionType)
            } else {
            queryParameters["sectionType"] = autorest.Encode("query","travelMode")
        }
        if vehicleAxleWeight != nil {
        queryParameters["vehicleAxleWeight"] = autorest.Encode("query",*vehicleAxleWeight)
            } else {
            queryParameters["vehicleAxleWeight"] = autorest.Encode("query",0)
        }
        if vehicleWidth != nil {
        queryParameters["vehicleWidth"] = autorest.Encode("query",*vehicleWidth)
            } else {
            queryParameters["vehicleWidth"] = autorest.Encode("query",0)
        }
        if vehicleHeight != nil {
        queryParameters["vehicleHeight"] = autorest.Encode("query",*vehicleHeight)
            } else {
            queryParameters["vehicleHeight"] = autorest.Encode("query",0)
        }
        if vehicleLength != nil {
        queryParameters["vehicleLength"] = autorest.Encode("query",*vehicleLength)
            } else {
            queryParameters["vehicleLength"] = autorest.Encode("query",0)
        }
        if vehicleMaxSpeed != nil {
        queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",*vehicleMaxSpeed)
            } else {
            queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",0)
        }
        if vehicleWeight != nil {
        queryParameters["vehicleWeight"] = autorest.Encode("query",*vehicleWeight)
            } else {
            queryParameters["vehicleWeight"] = autorest.Encode("query",0)
        }
        if vehicleCommercial != nil {
        queryParameters["vehicleCommercial"] = autorest.Encode("query",*vehicleCommercial)
            } else {
            queryParameters["vehicleCommercial"] = autorest.Encode("query",false)
        }
        if len(string(windingness)) > 0 {
        queryParameters["windingness"] = autorest.Encode("query",windingness)
            } else {
            queryParameters["windingness"] = autorest.Encode("query","normal")
        }
        if len(string(hilliness)) > 0 {
        queryParameters["hilliness"] = autorest.Encode("query",hilliness)
            } else {
            queryParameters["hilliness"] = autorest.Encode("query","normal")
        }
        if len(string(travelMode)) > 0 {
        queryParameters["travelMode"] = autorest.Encode("query",travelMode)
            } else {
            queryParameters["travelMode"] = autorest.Encode("query","car")
        }
        if len(string(avoid)) > 0 {
        queryParameters["avoid"] = autorest.Encode("query",avoid)
        }
        if traffic != nil {
        queryParameters["traffic"] = autorest.Encode("query",*traffic)
            } else {
            queryParameters["traffic"] = autorest.Encode("query",true)
        }
        if len(string(routeType)) > 0 {
        queryParameters["routeType"] = autorest.Encode("query",routeType)
            } else {
            queryParameters["routeType"] = autorest.Encode("query","fastest")
        }
        if len(string(vehicleLoadType)) > 0 {
        queryParameters["vehicleLoadType"] = autorest.Encode("query",vehicleLoadType)
        }
        if len(string(vehicleEngineType)) > 0 {
        queryParameters["vehicleEngineType"] = autorest.Encode("query",vehicleEngineType)
            } else {
            queryParameters["vehicleEngineType"] = autorest.Encode("query","combustion")
        }
        if constantSpeedConsumptionInLitersPerHundredkm != nil {
        queryParameters["constantSpeedConsumptionInLitersPerHundredkm"] = autorest.Encode("query",*constantSpeedConsumptionInLitersPerHundredkm)
        }
        if currentFuelInLiters != nil {
        queryParameters["currentFuelInLiters"] = autorest.Encode("query",*currentFuelInLiters)
        }
        if auxiliaryPowerInLitersPerHour != nil {
        queryParameters["auxiliaryPowerInLitersPerHour"] = autorest.Encode("query",*auxiliaryPowerInLitersPerHour)
        }
        if fuelEnergyDensityInMJoulesPerLiter != nil {
        queryParameters["fuelEnergyDensityInMJoulesPerLiter"] = autorest.Encode("query",*fuelEnergyDensityInMJoulesPerLiter)
        }
        if accelerationEfficiency != nil {
        queryParameters["accelerationEfficiency"] = autorest.Encode("query",*accelerationEfficiency)
        }
        if decelerationEfficiency != nil {
        queryParameters["decelerationEfficiency"] = autorest.Encode("query",*decelerationEfficiency)
        }
        if uphillEfficiency != nil {
        queryParameters["uphillEfficiency"] = autorest.Encode("query",*uphillEfficiency)
        }
        if downhillEfficiency != nil {
        queryParameters["downhillEfficiency"] = autorest.Encode("query",*downhillEfficiency)
        }
        if len(constantSpeedConsumptionInkWhPerHundredkm) > 0 {
        queryParameters["constantSpeedConsumptionInkWhPerHundredkm"] = autorest.Encode("query",constantSpeedConsumptionInkWhPerHundredkm)
        }
        if len(currentChargeInkWh) > 0 {
        queryParameters["currentChargeInkWh"] = autorest.Encode("query",currentChargeInkWh)
        }
        if len(maxChargeInkWh) > 0 {
        queryParameters["maxChargeInkWh"] = autorest.Encode("query",maxChargeInkWh)
        }
        if len(auxiliaryPowerInkW) > 0 {
        queryParameters["auxiliaryPowerInkW"] = autorest.Encode("query",auxiliaryPowerInkW)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/route/directions/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetRouteDirectionsSender sends the GetRouteDirections request. The method will close the
    // http.Response Body if it receives an error.
    func (client RouteClient) GetRouteDirectionsSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRouteDirectionsResponder handles the response to the GetRouteDirections request. The method always
    // closes the http.Response Body.
    func (client RouteClient) GetRouteDirectionsResponder(resp *http.Response) (result RouteDirectionsResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetRouteRange __Route Range (Isochrone) API__
//
//
// **Applies to**: S1 pricing tier.
//
// This service will calculate a set of locations that can be reached from the origin point based on fuel, energy,
// time or distance budget that is specified. A polygon boundary (or Isochrone) is returned in a counterclockwise
// orientation as well as the precise polygon center which was the result of the origin point.
//
// The returned polygon can be used for further processing such as  [Search Inside
// Geometry](https://docs.microsoft.com/rest/api/maps/search/postsearchinsidegeometry) to  search for POIs within the
// provided Isochrone.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the Coordinate from which the range calculation should start.
        // fuelBudgetInLiters - fuel budget in liters that determines maximal range which can be travelled using the
        // specified Combustion Consumption Model.<br> When fuelBudgetInLiters is used, it is mandatory to specify a
        // detailed  Combustion Consumption Model.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh,
        // timeBudgetInSec, or distanceBudgetInMeters) must be used.
        // energyBudgetInkWh - electric energy budget in kilowatt hours (kWh) that determines maximal range which can
        // be travelled using the specified Electric Consumption Model.<br> When energyBudgetInkWh is used, it is
        // mandatory to specify a detailed Electric Consumption Model.<br> Exactly one budget (fuelBudgetInLiters,
        // energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used.
        // timeBudgetInSec - time budget in seconds that determines maximal range which can be travelled using driving
        // time. The Consumption Model will only affect the range when routeType is eco.<br> Exactly one budget
        // (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used.
        // distanceBudgetInMeters - distance budget in meters that determines maximal range which can be travelled
        // using driving distance.  The Consumption Model will only affect the range when routeType is eco.<br> Exactly
        // one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used.
        // departAt - the date and time of departure from the origin point. Departure times apart from now must be
        // specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the
        // origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00).
        // routeType - the type of route requested.
        // traffic - possible values:
        // * true - Do consider all available traffic information during routing
        // * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
        // during routing, the effect of historic traffic on effective road speeds is still incorporated.
        // avoid - specifies something that the route calculation should try to avoid when determining the route. Can
        // be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'.
        // In calculateReachableRange requests, the value alreadyUsedRoads must not be used.
        // travelMode - the mode of travel for the requested route. If not defined, default is 'car'. Note that the
        // requested travelMode may not be available for the entire route. Where the requested travelMode is not
        // available for a particular section, the travelMode element of the response for that section will be "other".
        // Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not
        // available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not
        // be used.
        // hilliness - degree of hilliness for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // windingness - level of turns for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // vehicleAxleWeight - weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per
        // axle are not considered.
        // vehicleWidth - width of the vehicle in meters. A value of 0 means that width restrictions are not
        // considered.
        // vehicleHeight - height of the vehicle in meters. A value of 0 means that height restrictions are not
        // considered.
        // vehicleLength - length of the vehicle in meters. A value of 0 means that length restrictions are not
        // considered.
        // vehicleMaxSpeed - maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to
        // check whether a vehicle is allowed on motorways.
        //
        // * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route
        // planning.
        //
        // * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60
        // km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as
        // this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the
        // current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
        // vehicleWeight - weight of the vehicle in kilograms.
        //
        // * It is mandatory if any of the *Efficiency parameters are set.
        //
        // * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are
        // considered.
        //
        // * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then
        // weight restrictions are considered.
        //
        // * In all other cases, this parameter is ignored.
        //
        // Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
        // vehicleCommercial - vehicle is used for commercial purposes and thus may not be allowed to drive  on some
        // roads.
        // vehicleLoadType - types of cargo that may be classified as hazardous materials and restricted from some
        // roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for
        // use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used
        // for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only
        // considered for travelMode=truck.
        // vehicleEngineType - engine type of the vehicle. When a detailed Consumption Model is specified, it must be
        // consistent with the value of **vehicleEngineType**.
        // constantSpeedConsumptionInLitersPerHundredkm - specifies the speed-dependent component of consumption.
        //
        // Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on
        // a consumption curve. Consumption rates for speeds not in the list are found as follows:
        //
        // * by linear interpolation, if the given speed lies in between two speeds in the list
        //
        // * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two
        // points in the list
        //
        // The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same
        // speed. If it only contains a single point, then the consumption rate of that point is used without further
        // processing.
        //
        // Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest
        // speed. This ensures that extrapolation does not lead to negative consumption rates.
        //
        // Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative
        // consumption rate for any smaller speed.
        //
        // The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
        //
        // Sensible Values : 50,6.3:130,11.5
        //
        // **Note** : This parameter is required for **The Combustion Consumption Model**.
        // currentFuelInLiters - specifies the current supply of fuel in liters.
        //
        // Sensible Values : 55
        // auxiliaryPowerInLitersPerHour - specifies the amount of fuel consumed for sustaining auxiliary systems of
        // the vehicle, in liters per hour.
        //
        // It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
        //
        // Sensible Values : 0.2
        // fuelEnergyDensityInMJoulesPerLiter - specifies the amount of chemical energy stored in one liter of fuel in
        // megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved
        // or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel
        // fuel.
        //
        // This parameter is required if any ***Efficiency** parameter is set.
        //
        // Sensible Values : 34.2
        // accelerationEfficiency - specifies the efficiency of converting chemical energy stored in fuel to kinetic
        // energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed).
        // ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using
        // **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **decelerationEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
        // decelerationEfficiency - specifies the efficiency of converting kinetic energy to saved (not consumed) fuel
        // when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained
        // by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **accelerationEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
        // uphillEfficiency - specifies the efficiency of converting chemical energy stored in fuel to potential energy
        // when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed).
        // ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using
        // **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **downhillEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**downhillEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
        // downhillEfficiency - specifies the efficiency of converting potential energy to saved (not consumed) fuel
        // when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is
        // obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **uphillEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**uphillEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
        // constantSpeedConsumptionInkWhPerHundredkm - specifies the speed-dependent component of consumption.
        //
        // Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption
        // curve. Consumption rates for speeds not in the list are found as follows:
        //
        // * by linear interpolation, if the given speed lies in between two speeds in the list
        //
        // * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two
        // points in the list
        //
        // The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same
        // speed. If it only contains a single point, then the consumption rate of that point is used without further
        // processing.
        //
        // Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest
        // speed. This ensures that extrapolation does not lead to negative consumption rates.
        //
        // Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative
        // consumption rate for any smaller  speed.
        //
        // The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
        //
        // Sensible Values : 50,8.2:130,21.3
        //
        // This parameter is required for **Electric consumption model**.
        // currentChargeInkWh - specifies the current electric energy supply in kilowatt hours (kWh).
        //
        // This parameter co-exists with **maxChargeInkWh** parameter.
        //
        // The range of values allowed are 0.0 to **maxChargeInkWh**.
        //
        // Sensible Values : 43
        // maxChargeInkWh - specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in
        // the vehicle's battery.
        //
        // This parameter co-exists with **currentChargeInkWh** parameter.
        //
        // Minimum value has to be greater than or equal to **currentChargeInkWh**.
        //
        // Sensible Values : 85
        // auxiliaryPowerInkW - specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts
        // (kW).
        //
        // It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
        //
        // Sensible Values : 1.7
func (client RouteClient) GetRouteRange(ctx context.Context, formatParameter TextFormat, query string, fuelBudgetInLiters *float64, energyBudgetInkWh *float64, timeBudgetInSec *float64, distanceBudgetInMeters *float64, departAt *date.Time, routeType RouteType, traffic *bool, avoid Avoid, travelMode TravelMode, hilliness Hilliness, windingness Windingness, vehicleAxleWeight *int32, vehicleWidth *float64, vehicleHeight *float64, vehicleLength *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, vehicleCommercial *bool, vehicleLoadType VehicleLoadType, vehicleEngineType VehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm *float64, currentFuelInLiters *float64, auxiliaryPowerInLitersPerHour *float64, fuelEnergyDensityInMJoulesPerLiter *float64, accelerationEfficiency *float64, decelerationEfficiency *float64, uphillEfficiency *float64, downhillEfficiency *float64, constantSpeedConsumptionInkWhPerHundredkm string, currentChargeInkWh string, maxChargeInkWh string, auxiliaryPowerInkW string) (result RouteRangeResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RouteClient.GetRouteRange")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetRouteRangePreparer(ctx, formatParameter, query, fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, distanceBudgetInMeters, departAt, routeType, traffic, avoid, travelMode, hilliness, windingness, vehicleAxleWeight, vehicleWidth, vehicleHeight, vehicleLength, vehicleMaxSpeed, vehicleWeight, vehicleCommercial, vehicleLoadType, vehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm, currentFuelInLiters, auxiliaryPowerInLitersPerHour, fuelEnergyDensityInMJoulesPerLiter, accelerationEfficiency, decelerationEfficiency, uphillEfficiency, downhillEfficiency, constantSpeedConsumptionInkWhPerHundredkm, currentChargeInkWh, maxChargeInkWh, auxiliaryPowerInkW)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "GetRouteRange", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetRouteRangeSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "GetRouteRange", resp, "Failure sending request")
        return
        }

        result, err = client.GetRouteRangeResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "GetRouteRange", resp, "Failure responding to request")
        return
        }

    return
}

    // GetRouteRangePreparer prepares the GetRouteRange request.
    func (client RouteClient) GetRouteRangePreparer(ctx context.Context, formatParameter TextFormat, query string, fuelBudgetInLiters *float64, energyBudgetInkWh *float64, timeBudgetInSec *float64, distanceBudgetInMeters *float64, departAt *date.Time, routeType RouteType, traffic *bool, avoid Avoid, travelMode TravelMode, hilliness Hilliness, windingness Windingness, vehicleAxleWeight *int32, vehicleWidth *float64, vehicleHeight *float64, vehicleLength *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, vehicleCommercial *bool, vehicleLoadType VehicleLoadType, vehicleEngineType VehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm *float64, currentFuelInLiters *float64, auxiliaryPowerInLitersPerHour *float64, fuelEnergyDensityInMJoulesPerLiter *float64, accelerationEfficiency *float64, decelerationEfficiency *float64, uphillEfficiency *float64, downhillEfficiency *float64, constantSpeedConsumptionInkWhPerHundredkm string, currentChargeInkWh string, maxChargeInkWh string, auxiliaryPowerInkW string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if fuelBudgetInLiters != nil {
        queryParameters["fuelBudgetInLiters"] = autorest.Encode("query",*fuelBudgetInLiters)
        }
        if energyBudgetInkWh != nil {
        queryParameters["energyBudgetInkWh"] = autorest.Encode("query",*energyBudgetInkWh)
        }
        if timeBudgetInSec != nil {
        queryParameters["timeBudgetInSec"] = autorest.Encode("query",*timeBudgetInSec)
        }
        if distanceBudgetInMeters != nil {
        queryParameters["distanceBudgetInMeters"] = autorest.Encode("query",*distanceBudgetInMeters)
        }
        if departAt != nil {
        queryParameters["departAt"] = autorest.Encode("query",*departAt)
        }
        if len(string(routeType)) > 0 {
        queryParameters["routeType"] = autorest.Encode("query",routeType)
            } else {
            queryParameters["routeType"] = autorest.Encode("query","fastest")
        }
        if traffic != nil {
        queryParameters["traffic"] = autorest.Encode("query",*traffic)
            } else {
            queryParameters["traffic"] = autorest.Encode("query",true)
        }
        if len(string(avoid)) > 0 {
        queryParameters["avoid"] = autorest.Encode("query",avoid)
        }
        if len(string(travelMode)) > 0 {
        queryParameters["travelMode"] = autorest.Encode("query",travelMode)
            } else {
            queryParameters["travelMode"] = autorest.Encode("query","car")
        }
        if len(string(hilliness)) > 0 {
        queryParameters["hilliness"] = autorest.Encode("query",hilliness)
            } else {
            queryParameters["hilliness"] = autorest.Encode("query","normal")
        }
        if len(string(windingness)) > 0 {
        queryParameters["windingness"] = autorest.Encode("query",windingness)
            } else {
            queryParameters["windingness"] = autorest.Encode("query","normal")
        }
        if vehicleAxleWeight != nil {
        queryParameters["vehicleAxleWeight"] = autorest.Encode("query",*vehicleAxleWeight)
            } else {
            queryParameters["vehicleAxleWeight"] = autorest.Encode("query",0)
        }
        if vehicleWidth != nil {
        queryParameters["vehicleWidth"] = autorest.Encode("query",*vehicleWidth)
            } else {
            queryParameters["vehicleWidth"] = autorest.Encode("query",0)
        }
        if vehicleHeight != nil {
        queryParameters["vehicleHeight"] = autorest.Encode("query",*vehicleHeight)
            } else {
            queryParameters["vehicleHeight"] = autorest.Encode("query",0)
        }
        if vehicleLength != nil {
        queryParameters["vehicleLength"] = autorest.Encode("query",*vehicleLength)
            } else {
            queryParameters["vehicleLength"] = autorest.Encode("query",0)
        }
        if vehicleMaxSpeed != nil {
        queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",*vehicleMaxSpeed)
            } else {
            queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",0)
        }
        if vehicleWeight != nil {
        queryParameters["vehicleWeight"] = autorest.Encode("query",*vehicleWeight)
            } else {
            queryParameters["vehicleWeight"] = autorest.Encode("query",0)
        }
        if vehicleCommercial != nil {
        queryParameters["vehicleCommercial"] = autorest.Encode("query",*vehicleCommercial)
            } else {
            queryParameters["vehicleCommercial"] = autorest.Encode("query",false)
        }
        if len(string(vehicleLoadType)) > 0 {
        queryParameters["vehicleLoadType"] = autorest.Encode("query",vehicleLoadType)
        }
        if len(string(vehicleEngineType)) > 0 {
        queryParameters["vehicleEngineType"] = autorest.Encode("query",vehicleEngineType)
            } else {
            queryParameters["vehicleEngineType"] = autorest.Encode("query","combustion")
        }
        if constantSpeedConsumptionInLitersPerHundredkm != nil {
        queryParameters["constantSpeedConsumptionInLitersPerHundredkm"] = autorest.Encode("query",*constantSpeedConsumptionInLitersPerHundredkm)
        }
        if currentFuelInLiters != nil {
        queryParameters["currentFuelInLiters"] = autorest.Encode("query",*currentFuelInLiters)
        }
        if auxiliaryPowerInLitersPerHour != nil {
        queryParameters["auxiliaryPowerInLitersPerHour"] = autorest.Encode("query",*auxiliaryPowerInLitersPerHour)
        }
        if fuelEnergyDensityInMJoulesPerLiter != nil {
        queryParameters["fuelEnergyDensityInMJoulesPerLiter"] = autorest.Encode("query",*fuelEnergyDensityInMJoulesPerLiter)
        }
        if accelerationEfficiency != nil {
        queryParameters["accelerationEfficiency"] = autorest.Encode("query",*accelerationEfficiency)
        }
        if decelerationEfficiency != nil {
        queryParameters["decelerationEfficiency"] = autorest.Encode("query",*decelerationEfficiency)
        }
        if uphillEfficiency != nil {
        queryParameters["uphillEfficiency"] = autorest.Encode("query",*uphillEfficiency)
        }
        if downhillEfficiency != nil {
        queryParameters["downhillEfficiency"] = autorest.Encode("query",*downhillEfficiency)
        }
        if len(constantSpeedConsumptionInkWhPerHundredkm) > 0 {
        queryParameters["constantSpeedConsumptionInkWhPerHundredkm"] = autorest.Encode("query",constantSpeedConsumptionInkWhPerHundredkm)
        }
        if len(currentChargeInkWh) > 0 {
        queryParameters["currentChargeInkWh"] = autorest.Encode("query",currentChargeInkWh)
        }
        if len(maxChargeInkWh) > 0 {
        queryParameters["maxChargeInkWh"] = autorest.Encode("query",maxChargeInkWh)
        }
        if len(auxiliaryPowerInkW) > 0 {
        queryParameters["auxiliaryPowerInkW"] = autorest.Encode("query",auxiliaryPowerInkW)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/route/range/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetRouteRangeSender sends the GetRouteRange request. The method will close the
    // http.Response Body if it receives an error.
    func (client RouteClient) GetRouteRangeSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRouteRangeResponder handles the response to the GetRouteRange request. The method always
    // closes the http.Response Body.
    func (client RouteClient) GetRouteRangeResponder(resp *http.Response) (result RouteRangeResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostRouteDirections **Applies to**: S0 and S1 pricing tiers.
//
//
// Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route
// will take into account factors such as current traffic and the typical road speeds on the requested day of the week
// and time of day.
//
// Information returned includes the distance, estimated travel time, and a representation of the route geometry.
// Additional routing information such as optimized waypoint order or turn by turn instructions is also available,
// depending on the options selected.
//
// Routing service provides a set of parameters for a detailed description of a vehicle-specific Consumption Model.
// Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed
// explanation of the concepts and parameters involved.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // query - the Coordinates through which the route is calculated. Needs two coordinates at least. Delimited by
        // colon. First one is the origin and the last is the destination of the route. The coordinates are in a
        // lat,long format. Optional coordinates in between act as WayPoints in the route.
        // routeDirectionsRequestBody - used for reconstructing a route and for calculating zero or more alternative
        // routes to this reference route.  The provided sequence of coordinates is used as input for route
        // reconstruction. The alternative routes  are calculated between the origin and destination points specified
        // in the base path parameter locations.  If both minDeviationDistance and minDeviationTime are set to zero,
        // then these origin and destination points  are expected to be at (or very near) the beginning and end of the
        // reference route, respectively. Intermediate  locations (waypoints) are not supported when using
        // supportingPoints.
        //
        // Setting at least one of minDeviationDistance or minDeviationTime to a value greater than zero has the
        // following consequences:
        //
        // *  The origin point of the calculateRoute request must be on (or very near) the input reference route. If
        // this is not the case, an error is returned. However, the origin point does not need to be at the beginning
        // of  the input reference route (it can be thought of as the current vehicle position on the reference route).
        // *  The reference route, returned as the first route in the calculateRoute response, will start at the origin
        // point specified in the calculateRoute request. The initial part of the input reference route up until the
        // origin point will be excluded from the response.
        // *  The values of minDeviationDistance and minDeviationTime determine how far alternative routes will be
        // guaranteed to follow the reference route from the origin point onwards.
        // *  The route must use departAt.
        // *  The vehicleHeading is ignored.
        // maxAlternatives - number of desired alternative routes to be calculated. Default: 0, minimum: 0 and maximum:
        // 5
        // alternativeType - controls the optimality, with respect to the given planning criteria, of the calculated
        // alternatives compared to the reference route.
        // minDeviationDistance - all alternative routes returned will follow the reference route (see section POST
        // Requests) from the origin point of the calculateRoute request for at least this number of meters. Can only
        // be used when reconstructing a route. The minDeviationDistance parameter cannot be used in conjunction with
        // arriveAt
        // minDeviationTime - all alternative routes returned will follow the reference route (see section POST
        // Requests) from the origin point of the calculateRoute request for at least this number of seconds. Can only
        // be used when reconstructing a route. The minDeviationTime parameter cannot be used in conjunction with
        // arriveAt. Default value is 0. Setting )minDeviationTime_ to a value greater than zero has the following
        // consequences:
        // - The origin point of the _calculateRoute_ Request must be on
        // (or very near) the input reference route.
        // - If this is not the case, an error is returned.
        // - However, the origin point does not need to be at the beginning
        // of the input reference route (it can be thought of as the current
        // vehicle position on the reference route).
        // - The reference route, returned as the first route in the _calculateRoute_
        // Response, will start at the origin point specified in the _calculateRoute_
        // Request. The initial part of the input reference route up until the origin
        // point will be excluded from the Response.
        // - The values of _minDeviationDistance_ and _minDeviationTime_ determine
        // how far alternative routes will be guaranteed to follow the reference
        // route from the origin point onwards.
        // - The route must use _departAt_.
        // - The _vehicleHeading_ is ignored.
        // instructionsType - if specified, guidance instructions will be returned. Note that the instructionsType
        // parameter cannot be used in conjunction with routeRepresentation=none
        // language - the language parameter determines the language of the guidance messages. It does not affect
        // proper nouns (the names of streets, plazas, etc.) It has no effect when instructionsType=coded. Allowed
        // values are (a subset of) the IETF language tags described
        // computeBestOrder - re-order the route waypoints using a fast heuristic algorithm to reduce the route length.
        // Yields best results when used in conjunction with routeType _shortest_. Notice that origin and destination
        // are excluded from the optimized waypoint indices. To include origin and destination in the response, please
        // increase all the indices by 1 to account for the origin, and then add the destination as the final index.
        // Possible values are true or false. True computes a better order if possible, but is not allowed to be used
        // in conjunction with maxAlternatives value greater than 0 or in conjunction with circle waypoints. False will
        // use the locations in the given order and not allowed to be used in conjunction with routeRepresentation
        // _none_.
        // routeRepresentation - specifies the representation of the set of routes provided as response. This parameter
        // value can only be used in conjunction with computeBestOrder=true.
        // computeTravelTimeFor - specifies whether to return additional travel times using different types of traffic
        // information (none, historic, live) as well as the default best-estimate travel time.
        // vehicleHeading - the directional heading of the vehicle in degrees starting at true North and continuing in
        // clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees.
        // Possible values 0-359
        // report - specifies which data should be reported for diagnosis purposes. The only possible value is
        // _effectiveSettings_. Reports the effective parameters or data used when calling the API. In the case of
        // defaulted parameters the default will be reflected where the parameter was not specified by the caller.
        // sectionType - specifies which of the section types is reported in the route response. <br><br>For example if
        // sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can
        // be used. The default sectionType refers to the travelMode input. By default travelMode is set to car
        // arriveAt - the date and time of arrival at the destination point. It must be specified as a dateTime. When a
        // time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value
        // must be in the future. The arriveAt parameter cannot be used in conjunction with departAt,
        // minDeviationDistance or minDeviationTime.
        // departAt - the date and time of departure from the origin point. Departure times apart from now must be
        // specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the
        // origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00).
        // vehicleAxleWeight - weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per
        // axle are not considered.
        // vehicleLength - length of the vehicle in meters. A value of 0 means that length restrictions are not
        // considered.
        // vehicleHeight - height of the vehicle in meters. A value of 0 means that height restrictions are not
        // considered.
        // vehicleWidth - width of the vehicle in meters. A value of 0 means that width restrictions are not
        // considered.
        // vehicleMaxSpeed - maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to
        // check whether a vehicle is allowed on motorways.
        //
        // * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route
        // planning.
        //
        // * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60
        // km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as
        // this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the
        // current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
        // vehicleWeight - weight of the vehicle in kilograms.
        //
        // * It is mandatory if any of the *Efficiency parameters are set.
        //
        // * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are
        // considered.
        //
        // * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then
        // weight restrictions are considered.
        //
        // * In all other cases, this parameter is ignored.
        //
        // Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
        // vehicleCommercial - vehicle is used for commercial purposes and thus may not be allowed to drive  on some
        // roads.
        // windingness - level of turns for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // hilliness - degree of hilliness for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // travelMode - the mode of travel for the requested route. If not defined, default is 'car'. Note that the
        // requested travelMode may not be available for the entire route. Where the requested travelMode is not
        // available for a particular section, the travelMode element of the response for that section will be "other".
        // Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not
        // available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not
        // be used.
        // avoid - specifies something that the route calculation should try to avoid when determining the route. Can
        // be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'.
        // In calculateReachableRange requests, the value alreadyUsedRoads must not be used.
        // traffic - possible values:
        // * true - Do consider all available traffic information during routing
        // * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
        // during routing, the effect of historic traffic on effective road speeds is still incorporated.
        // routeType - the type of route requested.
        // vehicleLoadType - types of cargo that may be classified as hazardous materials and restricted from some
        // roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for
        // use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used
        // for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only
        // considered for travelMode=truck.
        // vehicleEngineType - engine type of the vehicle. When a detailed Consumption Model is specified, it must be
        // consistent with the value of **vehicleEngineType**.
        // constantSpeedConsumptionInLitersPerHundredkm - specifies the speed-dependent component of consumption.
        //
        // Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on
        // a consumption curve. Consumption rates for speeds not in the list are found as follows:
        //
        // * by linear interpolation, if the given speed lies in between two speeds in the list
        //
        // * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two
        // points in the list
        //
        // The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same
        // speed. If it only contains a single point, then the consumption rate of that point is used without further
        // processing.
        //
        // Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest
        // speed. This ensures that extrapolation does not lead to negative consumption rates.
        //
        // Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative
        // consumption rate for any smaller speed.
        //
        // The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
        //
        // Sensible Values : 50,6.3:130,11.5
        //
        // **Note** : This parameter is required for **The Combustion Consumption Model**.
        // currentFuelInLiters - specifies the current supply of fuel in liters.
        //
        // Sensible Values : 55
        // auxiliaryPowerInLitersPerHour - specifies the amount of fuel consumed for sustaining auxiliary systems of
        // the vehicle, in liters per hour.
        //
        // It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
        //
        // Sensible Values : 0.2
        // fuelEnergyDensityInMJoulesPerLiter - specifies the amount of chemical energy stored in one liter of fuel in
        // megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved
        // or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel
        // fuel.
        //
        // This parameter is required if any ***Efficiency** parameter is set.
        //
        // Sensible Values : 34.2
        // accelerationEfficiency - specifies the efficiency of converting chemical energy stored in fuel to kinetic
        // energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed).
        // ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using
        // **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **decelerationEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
        // decelerationEfficiency - specifies the efficiency of converting kinetic energy to saved (not consumed) fuel
        // when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained
        // by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **accelerationEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
        // uphillEfficiency - specifies the efficiency of converting chemical energy stored in fuel to potential energy
        // when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed).
        // ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using
        // **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **downhillEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**downhillEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
        // downhillEfficiency - specifies the efficiency of converting potential energy to saved (not consumed) fuel
        // when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is
        // obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
        //
        // Must be paired with **uphillEfficiency**.
        //
        // The range of values allowed are 0.0 to 1/**uphillEfficiency**.
        //
        // Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
        // constantSpeedConsumptionInkWhPerHundredkm - specifies the speed-dependent component of consumption.
        //
        // Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption
        // curve. Consumption rates for speeds not in the list are found as follows:
        //
        // * by linear interpolation, if the given speed lies in between two speeds in the list
        //
        // * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two
        // points in the list
        //
        // The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same
        // speed. If it only contains a single point, then the consumption rate of that point is used without further
        // processing.
        //
        // Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest
        // speed. This ensures that extrapolation does not lead to negative consumption rates.
        //
        // Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative
        // consumption rate for any smaller  speed.
        //
        // The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
        //
        // Sensible Values : 50,8.2:130,21.3
        //
        // This parameter is required for **Electric consumption model**.
        // currentChargeInkWh - specifies the current electric energy supply in kilowatt hours (kWh).
        //
        // This parameter co-exists with **maxChargeInkWh** parameter.
        //
        // The range of values allowed are 0.0 to **maxChargeInkWh**.
        //
        // Sensible Values : 43
        // maxChargeInkWh - specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in
        // the vehicle's battery.
        //
        // This parameter co-exists with **currentChargeInkWh** parameter.
        //
        // Minimum value has to be greater than or equal to **currentChargeInkWh**.
        //
        // Sensible Values : 85
        // auxiliaryPowerInkW - specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts
        // (kW).
        //
        // It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
        //
        // Sensible Values : 1.7
func (client RouteClient) PostRouteDirections(ctx context.Context, formatParameter TextFormat, query string, routeDirectionsRequestBody RouteDirectionsRequestBody, maxAlternatives *int32, alternativeType AlternativeRouteType, minDeviationDistance *int32, minDeviationTime *int32, instructionsType RouteInstructionsType, language string, computeBestOrder *bool, routeRepresentation RouteRepresentation, computeTravelTimeFor ComputeTravelTimeFor, vehicleHeading *int32, report string, sectionType SectionType, arriveAt *date.Time, departAt *date.Time, vehicleAxleWeight *int32, vehicleLength *float64, vehicleHeight *float64, vehicleWidth *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, vehicleCommercial *bool, windingness Windingness, hilliness Hilliness, travelMode TravelMode, avoid Avoid, traffic *bool, routeType RouteType, vehicleLoadType VehicleLoadType, vehicleEngineType VehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm *float64, currentFuelInLiters *float64, auxiliaryPowerInLitersPerHour *float64, fuelEnergyDensityInMJoulesPerLiter *float64, accelerationEfficiency *float64, decelerationEfficiency *float64, uphillEfficiency *float64, downhillEfficiency *float64, constantSpeedConsumptionInkWhPerHundredkm string, currentChargeInkWh string, maxChargeInkWh string, auxiliaryPowerInkW string) (result RouteDirectionsResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RouteClient.PostRouteDirections")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: maxAlternatives,
         Constraints: []validation.Constraint{	{Target: "maxAlternatives", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "maxAlternatives", Name: validation.InclusiveMaximum, Rule: int64(5), Chain: nil },
        	{Target: "maxAlternatives", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}},
        { TargetValue: vehicleHeading,
         Constraints: []validation.Constraint{	{Target: "vehicleHeading", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "vehicleHeading", Name: validation.InclusiveMaximum, Rule: int64(359), Chain: nil },
        	{Target: "vehicleHeading", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}},
        { TargetValue: routeDirectionsRequestBody,
         Constraints: []validation.Constraint{	{Target: "routeDirectionsRequestBody.SupportingPoints", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "routeDirectionsRequestBody.SupportingPoints.Geometries", Name: validation.Null, Rule: true, Chain: nil },
        }},
        	{Target: "routeDirectionsRequestBody.AvoidAreas", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "routeDirectionsRequestBody.AvoidAreas.Coordinates", Name: validation.Null, Rule: true, Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.RouteClient", "PostRouteDirections", err.Error())
        }

        req, err := client.PostRouteDirectionsPreparer(ctx, formatParameter, query, routeDirectionsRequestBody, maxAlternatives, alternativeType, minDeviationDistance, minDeviationTime, instructionsType, language, computeBestOrder, routeRepresentation, computeTravelTimeFor, vehicleHeading, report, sectionType, arriveAt, departAt, vehicleAxleWeight, vehicleLength, vehicleHeight, vehicleWidth, vehicleMaxSpeed, vehicleWeight, vehicleCommercial, windingness, hilliness, travelMode, avoid, traffic, routeType, vehicleLoadType, vehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm, currentFuelInLiters, auxiliaryPowerInLitersPerHour, fuelEnergyDensityInMJoulesPerLiter, accelerationEfficiency, decelerationEfficiency, uphillEfficiency, downhillEfficiency, constantSpeedConsumptionInkWhPerHundredkm, currentChargeInkWh, maxChargeInkWh, auxiliaryPowerInkW)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteDirections", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostRouteDirectionsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteDirections", resp, "Failure sending request")
        return
        }

        result, err = client.PostRouteDirectionsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteDirections", resp, "Failure responding to request")
        return
        }

    return
}

    // PostRouteDirectionsPreparer prepares the PostRouteDirections request.
    func (client RouteClient) PostRouteDirectionsPreparer(ctx context.Context, formatParameter TextFormat, query string, routeDirectionsRequestBody RouteDirectionsRequestBody, maxAlternatives *int32, alternativeType AlternativeRouteType, minDeviationDistance *int32, minDeviationTime *int32, instructionsType RouteInstructionsType, language string, computeBestOrder *bool, routeRepresentation RouteRepresentation, computeTravelTimeFor ComputeTravelTimeFor, vehicleHeading *int32, report string, sectionType SectionType, arriveAt *date.Time, departAt *date.Time, vehicleAxleWeight *int32, vehicleLength *float64, vehicleHeight *float64, vehicleWidth *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, vehicleCommercial *bool, windingness Windingness, hilliness Hilliness, travelMode TravelMode, avoid Avoid, traffic *bool, routeType RouteType, vehicleLoadType VehicleLoadType, vehicleEngineType VehicleEngineType, constantSpeedConsumptionInLitersPerHundredkm *float64, currentFuelInLiters *float64, auxiliaryPowerInLitersPerHour *float64, fuelEnergyDensityInMJoulesPerLiter *float64, accelerationEfficiency *float64, decelerationEfficiency *float64, uphillEfficiency *float64, downhillEfficiency *float64, constantSpeedConsumptionInkWhPerHundredkm string, currentChargeInkWh string, maxChargeInkWh string, auxiliaryPowerInkW string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if maxAlternatives != nil {
        queryParameters["maxAlternatives"] = autorest.Encode("query",*maxAlternatives)
            } else {
            queryParameters["maxAlternatives"] = autorest.Encode("query",0)
        }
        if len(string(alternativeType)) > 0 {
        queryParameters["alternativeType"] = autorest.Encode("query",alternativeType)
            } else {
            queryParameters["alternativeType"] = autorest.Encode("query","anyRoute")
        }
        if minDeviationDistance != nil {
        queryParameters["minDeviationDistance"] = autorest.Encode("query",*minDeviationDistance)
            } else {
            queryParameters["minDeviationDistance"] = autorest.Encode("query",0)
        }
        if minDeviationTime != nil {
        queryParameters["minDeviationTime"] = autorest.Encode("query",*minDeviationTime)
            } else {
            queryParameters["minDeviationTime"] = autorest.Encode("query",0)
        }
        if len(string(instructionsType)) > 0 {
        queryParameters["instructionsType"] = autorest.Encode("query",instructionsType)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if computeBestOrder != nil {
        queryParameters["computeBestOrder"] = autorest.Encode("query",*computeBestOrder)
            } else {
            queryParameters["computeBestOrder"] = autorest.Encode("query",false)
        }
        if len(string(routeRepresentation)) > 0 {
        queryParameters["routeRepresentation"] = autorest.Encode("query",routeRepresentation)
            } else {
            queryParameters["routeRepresentation"] = autorest.Encode("query","polyline")
        }
        if len(string(computeTravelTimeFor)) > 0 {
        queryParameters["computeTravelTimeFor"] = autorest.Encode("query",computeTravelTimeFor)
            } else {
            queryParameters["computeTravelTimeFor"] = autorest.Encode("query","none")
        }
        if vehicleHeading != nil {
        queryParameters["vehicleHeading"] = autorest.Encode("query",*vehicleHeading)
        }
        if len(report) > 0 {
        queryParameters["report"] = autorest.Encode("query",report)
        }
        if len(string(sectionType)) > 0 {
        queryParameters["sectionType"] = autorest.Encode("query",sectionType)
            } else {
            queryParameters["sectionType"] = autorest.Encode("query","travelMode")
        }
        if arriveAt != nil {
        queryParameters["arriveAt"] = autorest.Encode("query",*arriveAt)
        }
        if departAt != nil {
        queryParameters["departAt"] = autorest.Encode("query",*departAt)
        }
        if vehicleAxleWeight != nil {
        queryParameters["vehicleAxleWeight"] = autorest.Encode("query",*vehicleAxleWeight)
            } else {
            queryParameters["vehicleAxleWeight"] = autorest.Encode("query",0)
        }
        if vehicleLength != nil {
        queryParameters["vehicleLength"] = autorest.Encode("query",*vehicleLength)
            } else {
            queryParameters["vehicleLength"] = autorest.Encode("query",0)
        }
        if vehicleHeight != nil {
        queryParameters["vehicleHeight"] = autorest.Encode("query",*vehicleHeight)
            } else {
            queryParameters["vehicleHeight"] = autorest.Encode("query",0)
        }
        if vehicleWidth != nil {
        queryParameters["vehicleWidth"] = autorest.Encode("query",*vehicleWidth)
            } else {
            queryParameters["vehicleWidth"] = autorest.Encode("query",0)
        }
        if vehicleMaxSpeed != nil {
        queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",*vehicleMaxSpeed)
            } else {
            queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",0)
        }
        if vehicleWeight != nil {
        queryParameters["vehicleWeight"] = autorest.Encode("query",*vehicleWeight)
            } else {
            queryParameters["vehicleWeight"] = autorest.Encode("query",0)
        }
        if vehicleCommercial != nil {
        queryParameters["vehicleCommercial"] = autorest.Encode("query",*vehicleCommercial)
            } else {
            queryParameters["vehicleCommercial"] = autorest.Encode("query",false)
        }
        if len(string(windingness)) > 0 {
        queryParameters["windingness"] = autorest.Encode("query",windingness)
            } else {
            queryParameters["windingness"] = autorest.Encode("query","normal")
        }
        if len(string(hilliness)) > 0 {
        queryParameters["hilliness"] = autorest.Encode("query",hilliness)
            } else {
            queryParameters["hilliness"] = autorest.Encode("query","normal")
        }
        if len(string(travelMode)) > 0 {
        queryParameters["travelMode"] = autorest.Encode("query",travelMode)
            } else {
            queryParameters["travelMode"] = autorest.Encode("query","car")
        }
        if len(string(avoid)) > 0 {
        queryParameters["avoid"] = autorest.Encode("query",avoid)
        }
        if traffic != nil {
        queryParameters["traffic"] = autorest.Encode("query",*traffic)
            } else {
            queryParameters["traffic"] = autorest.Encode("query",true)
        }
        if len(string(routeType)) > 0 {
        queryParameters["routeType"] = autorest.Encode("query",routeType)
            } else {
            queryParameters["routeType"] = autorest.Encode("query","fastest")
        }
        if len(string(vehicleLoadType)) > 0 {
        queryParameters["vehicleLoadType"] = autorest.Encode("query",vehicleLoadType)
        }
        if len(string(vehicleEngineType)) > 0 {
        queryParameters["vehicleEngineType"] = autorest.Encode("query",vehicleEngineType)
            } else {
            queryParameters["vehicleEngineType"] = autorest.Encode("query","combustion")
        }
        if constantSpeedConsumptionInLitersPerHundredkm != nil {
        queryParameters["constantSpeedConsumptionInLitersPerHundredkm"] = autorest.Encode("query",*constantSpeedConsumptionInLitersPerHundredkm)
        }
        if currentFuelInLiters != nil {
        queryParameters["currentFuelInLiters"] = autorest.Encode("query",*currentFuelInLiters)
        }
        if auxiliaryPowerInLitersPerHour != nil {
        queryParameters["auxiliaryPowerInLitersPerHour"] = autorest.Encode("query",*auxiliaryPowerInLitersPerHour)
        }
        if fuelEnergyDensityInMJoulesPerLiter != nil {
        queryParameters["fuelEnergyDensityInMJoulesPerLiter"] = autorest.Encode("query",*fuelEnergyDensityInMJoulesPerLiter)
        }
        if accelerationEfficiency != nil {
        queryParameters["accelerationEfficiency"] = autorest.Encode("query",*accelerationEfficiency)
        }
        if decelerationEfficiency != nil {
        queryParameters["decelerationEfficiency"] = autorest.Encode("query",*decelerationEfficiency)
        }
        if uphillEfficiency != nil {
        queryParameters["uphillEfficiency"] = autorest.Encode("query",*uphillEfficiency)
        }
        if downhillEfficiency != nil {
        queryParameters["downhillEfficiency"] = autorest.Encode("query",*downhillEfficiency)
        }
        if len(constantSpeedConsumptionInkWhPerHundredkm) > 0 {
        queryParameters["constantSpeedConsumptionInkWhPerHundredkm"] = autorest.Encode("query",constantSpeedConsumptionInkWhPerHundredkm)
        }
        if len(currentChargeInkWh) > 0 {
        queryParameters["currentChargeInkWh"] = autorest.Encode("query",currentChargeInkWh)
        }
        if len(maxChargeInkWh) > 0 {
        queryParameters["maxChargeInkWh"] = autorest.Encode("query",maxChargeInkWh)
        }
        if len(auxiliaryPowerInkW) > 0 {
        queryParameters["auxiliaryPowerInkW"] = autorest.Encode("query",auxiliaryPowerInkW)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/route/directions/{format}",pathParameters),
autorest.WithJSON(routeDirectionsRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostRouteDirectionsSender sends the PostRouteDirections request. The method will close the
    // http.Response Body if it receives an error.
    func (client RouteClient) PostRouteDirectionsSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostRouteDirectionsResponder handles the response to the PostRouteDirections request. The method always
    // closes the http.Response Body.
    func (client RouteClient) PostRouteDirectionsResponder(resp *http.Response) (result RouteDirectionsResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostRouteDirectionsBatch **Route Directions Batch API**
//
//
// **Applies to**: S1 pricing tier.
//
//
//
// The Route Directions Batch API sends batches of queries to [Route Directions
// API](https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections) using just a single API call. You can
// call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows
// caller to batch up to **700** queries and sync API up to **100** queries.
// ### Submit Synchronous Batch Request
// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will
// respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later.
// The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The
// number of batch items is limited to **100** for this API.
// ```
// POST
// https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// ```
// ### Submit Asynchronous Batch Request
// The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
// - It allows the retrieval of results in a separate call (multiple downloads are possible).
// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// - The number of batch items is limited to **700** for this API.
//
// When you make a request by using async request, by default the service returns a 202 response code along a redirect
// URL in the Location field of the response header. This URL should be checked periodically until the response data or
// error information is available.
// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the
// expiration period.
//
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Route Directions Batch `POST` request to Azure Maps
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request has been accepted.
//
// > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any
// other `Error` status code.
//
// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to
// download the results of the batch request.
// This status URI looks like following:
//
// ``` GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0 ```
// Note:- Please remember to add AUTH information (subscription-key/azure_auth - See [Security](#security)) to the
// _status URI_ before running it. <br>
// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
//
// ### POST Body for Batch Request
// To send the _route directions_ queries you will use a `POST` request where the request body will contain the
// `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample
// request body containing 3 _route directions_ queries:
//
//
// ```json
// {
// "batchItems": [
// { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" },
// { "query": "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" },
// { "query": "?query=48.923159,-122.557362:32.621279,-116.840362" }
// ]
// }
// ```
//
// A _route directions_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and
// subscription-key. It can accept any of the supported _route directions_ [URI
// parameters](https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#uri-parameters). The string
// values in the _route directions_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it
// should also be properly URL-encoded.
//
//
// The async API allows caller to batch up to **700** queries and sync API up to **100** queries, and the batch should
// contain at least **1** query.
//
//
// ### Download Asynchronous Batch Results
// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download
// URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
//
// ```
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// ```
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a `GET` request using the _download URL_.
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
//
// > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
//
//
//
// ### Batch Response Model
// The returned data content is similar for async and sync requests. When downloading the results of an async batch
// request, if the batch has finished processing, the response body contains the batch response. This batch response
// contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and
// `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems`
// array which contains a response for each and every query in the batch request. The `batchItems` will contain the
// results in the exact same order the original queries were sent in the batch request. Each item in `batchItems`
// contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
//
// -
// [`RouteDirectionsResponse`](https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse)
// - If the query completed successfully.
//
// - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
//
//
// Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
//
//
// ```json
// {
// "summary": {
// "successfulRequests": 1,
// "totalRequests": 2
// },
// "batchItems": [
// {
// "statusCode": 200,
// "response": {
// "routes": [
// {
// "summary": {
// "lengthInMeters": 1758,
// "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0,
// "departureTime": "2018-07-17T00:49:56+00:00",
// "arrivalTime": "2018-07-17T00:56:22+00:00"
// },
// "legs": [
// {
// "summary": {
// "lengthInMeters": 1758,
// "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0,
// "departureTime": "2018-07-17T00:49:56+00:00",
// "arrivalTime": "2018-07-17T00:56:22+00:00"
// },
// "points": [
// {
// "latitude": 47.62094,
// "longitude": -122.34892
// },
// {
// "latitude": 47.62094,
// "longitude": -122.3485
// },
// {
// "latitude": 47.62095,
// "longitude": -122.3476
// }
// ]
// }
// ],
// "sections": [
// {
// "startPointIndex": 0,
// "endPointIndex": 40,
// "sectionType": "TRAVEL_MODE",
// "travelMode": "bicycle"
// }
// ]
// }
// ]
// }
// },
// {
// "statusCode": 400,
// "response":
// {
// "error":
// {
// "code": "400 BadRequest",
// "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
// }
// }
// }
// ]
// }
// ```
    // Parameters:
        // routeDirectionsBatchRequestBody - the list of route directions queries/requests to process. The list can
        // contain  a max of 700 queries for async and 100 queries for sync version and must contain at least 1 query.
func (client RouteClient) PostRouteDirectionsBatch(ctx context.Context, routeDirectionsBatchRequestBody BatchRequestBody) (result RoutePostRouteDirectionsBatchFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RouteClient.PostRouteDirectionsBatch")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.PostRouteDirectionsBatchPreparer(ctx, routeDirectionsBatchRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteDirectionsBatch", nil , "Failure preparing request")
    return
    }

        result, err = client.PostRouteDirectionsBatchSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteDirectionsBatch", nil , "Failure sending request")
        return
        }

    return
}

    // PostRouteDirectionsBatchPreparer prepares the PostRouteDirectionsBatch request.
    func (client RouteClient) PostRouteDirectionsBatchPreparer(ctx context.Context, routeDirectionsBatchRequestBody BatchRequestBody) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/route/directions/batch/{format}",pathParameters),
autorest.WithJSON(routeDirectionsBatchRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostRouteDirectionsBatchSender sends the PostRouteDirectionsBatch request. The method will close the
    // http.Response Body if it receives an error.
    func (client RouteClient) PostRouteDirectionsBatchSender(req *http.Request) (future RoutePostRouteDirectionsBatchFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // PostRouteDirectionsBatchResponder handles the response to the PostRouteDirectionsBatch request. The method always
    // closes the http.Response Body.
    func (client RouteClient) PostRouteDirectionsBatchResponder(resp *http.Response) (result BatchResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostRouteMatrix **Applies to**: S1 pricing tier.
//
// The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin
// and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given
// origin, the service calculates the cost of routing from that origin to every given destination. The set of origins
// and the set of destinations can be thought of as the column and row headers of a table and each cell in the table
// contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food
// delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the
// restaurant. To solve this use case, they can call Matrix Route API.
//
//
// For each route, the travel times and distances are returned. You can use the computed costs to determine which
// detailed routes to calculate using the Route Directions API.
//
//
// The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins
// multiplied by the number of destinations).
//
//
//
// ### Submit Synchronous Route Matrix Request
// If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you
// might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins
// multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are:
// 10x10, 6x8, 9x8 (it does not need to be square).
//
// ```
// POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
// ```
//
// ### Submit Asynchronous Route Matrix Request
// The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make
// a request by using async request, by default the service returns a 202 response code along a redirect URL in the
// Location field of the response header. This URL should be checked periodically until the response data or error
// information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response
// if the request is finished under 120 seconds.
//
//
// The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of
// destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70
// (it does not need to be square).
//
//
// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the
// expiration period.
//
//
//
//
// ```
// POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
// ```
//
// Here's a typical sequence of asynchronous operations:
// 1. Client sends a Route Matrix POST request to Azure Maps
//
// 2. The server will respond with one of the following:
//
// > HTTP `202 Accepted` -  Route Matrix request has been accepted.
//
// > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or
// any other Error status code.
//
//
// 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to
// download the results of the request. This status URI looks like the following:
//
// ```
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// ```
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
//
// ### Download Sync Results
// When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request
// and a response array. The response body will contain the data and there will be no possibility to retrieve the
// results later.
//
// ### Download Async Results
// When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will
// be given a URL to check the progress of your  async request in the location header of the response. This status URI
// looks like the following:
// ```
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// ```
//
// The URL provided by the location header will return the following responses when a `GET` request is issued.
//
// > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
//
// > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
    // Parameters:
        // routeMatrixBody - the matrix of origin and destination coordinates to compute the route distance, travel
        // time and other summary for each cell of the matrix based on the input parameters. The minimum and the
        // maximum cell count supported are 1 and **700** for async and **100** for sync respectively. For example, it
        // can be 35 origins and 20 destinations or 25 origins and 25 destinations for async API.
        // waitForResults - boolean to indicate whether to execute the request synchronously. If set to true, user will
        // get a 200 response if the request is finished under 120 seconds. Otherwise, user will get a 202 response
        // right away. Please refer to the API description for more details on 202 response. **Supported only for async
        // request**.
        // computeTravelTimeFor - specifies whether to return additional travel times using different types of traffic
        // information (none, historic, live) as well as the default best-estimate travel time.
        // sectionType - specifies which of the section types is reported in the route response. <br><br>For example if
        // sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can
        // be used. The default sectionType refers to the travelMode input. By default travelMode is set to car
        // arriveAt - the date and time of arrival at the destination point. It must be specified as a dateTime. When a
        // time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value
        // must be in the future. The arriveAt parameter cannot be used in conjunction with departAt,
        // minDeviationDistance or minDeviationTime.
        // departAt - the date and time of departure from the origin point. Departure times apart from now must be
        // specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the
        // origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00).
        // vehicleAxleWeight - weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per
        // axle are not considered.
        // vehicleLength - length of the vehicle in meters. A value of 0 means that length restrictions are not
        // considered.
        // vehicleHeight - height of the vehicle in meters. A value of 0 means that height restrictions are not
        // considered.
        // vehicleWidth - width of the vehicle in meters. A value of 0 means that width restrictions are not
        // considered.
        // vehicleMaxSpeed - maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to
        // check whether a vehicle is allowed on motorways.
        //
        // * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route
        // planning.
        //
        // * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60
        // km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as
        // this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the
        // current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
        // vehicleWeight - weight of the vehicle in kilograms.
        // windingness - level of turns for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // hilliness - degree of hilliness for thrilling route. This parameter can only be used in conjunction with
        // `routeType`=thrilling.
        // travelMode - the mode of travel for the requested route. If not defined, default is 'car'. Note that the
        // requested travelMode may not be available for the entire route. Where the requested travelMode is not
        // available for a particular section, the travelMode element of the response for that section will be "other".
        // Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not
        // available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not
        // be used.
        // avoid - specifies something that the route calculation should try to avoid when determining the route. Can
        // be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'.
        // In calculateReachableRange requests, the value alreadyUsedRoads must not be used.
        // traffic - possible values:
        // * true - Do consider all available traffic information during routing
        // * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
        // during routing, the effect of historic traffic on effective road speeds is still incorporated.
        // routeType - the type of route requested.
        // vehicleLoadType - types of cargo that may be classified as hazardous materials and restricted from some
        // roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for
        // use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used
        // for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only
        // considered for travelMode=truck.
func (client RouteClient) PostRouteMatrix(ctx context.Context, routeMatrixBody RouteMatrixRequestBody, waitForResults *bool, computeTravelTimeFor ComputeTravelTimeFor, sectionType SectionType, arriveAt *date.Time, departAt *date.Time, vehicleAxleWeight *int32, vehicleLength *float64, vehicleHeight *float64, vehicleWidth *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, windingness Windingness, hilliness Hilliness, travelMode TravelMode, avoid Avoid, traffic *bool, routeType RouteType, vehicleLoadType VehicleLoadType) (result RoutePostRouteMatrixFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RouteClient.PostRouteMatrix")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: routeMatrixBody,
         Constraints: []validation.Constraint{	{Target: "routeMatrixBody.Origins", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "routeMatrixBody.Origins.Coordinates", Name: validation.Null, Rule: true, Chain: nil },
        }},
        	{Target: "routeMatrixBody.Destinations", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "routeMatrixBody.Destinations.Coordinates", Name: validation.Null, Rule: true, Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.RouteClient", "PostRouteMatrix", err.Error())
        }

        req, err := client.PostRouteMatrixPreparer(ctx, routeMatrixBody, waitForResults, computeTravelTimeFor, sectionType, arriveAt, departAt, vehicleAxleWeight, vehicleLength, vehicleHeight, vehicleWidth, vehicleMaxSpeed, vehicleWeight, windingness, hilliness, travelMode, avoid, traffic, routeType, vehicleLoadType)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteMatrix", nil , "Failure preparing request")
    return
    }

        result, err = client.PostRouteMatrixSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.RouteClient", "PostRouteMatrix", nil , "Failure sending request")
        return
        }

    return
}

    // PostRouteMatrixPreparer prepares the PostRouteMatrix request.
    func (client RouteClient) PostRouteMatrixPreparer(ctx context.Context, routeMatrixBody RouteMatrixRequestBody, waitForResults *bool, computeTravelTimeFor ComputeTravelTimeFor, sectionType SectionType, arriveAt *date.Time, departAt *date.Time, vehicleAxleWeight *int32, vehicleLength *float64, vehicleHeight *float64, vehicleWidth *float64, vehicleMaxSpeed *int32, vehicleWeight *int32, windingness Windingness, hilliness Hilliness, travelMode TravelMode, avoid Avoid, traffic *bool, routeType RouteType, vehicleLoadType VehicleLoadType) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if waitForResults != nil {
        queryParameters["waitForResults"] = autorest.Encode("query",*waitForResults)
            } else {
            queryParameters["waitForResults"] = autorest.Encode("query",false)
        }
        if len(string(computeTravelTimeFor)) > 0 {
        queryParameters["computeTravelTimeFor"] = autorest.Encode("query",computeTravelTimeFor)
            } else {
            queryParameters["computeTravelTimeFor"] = autorest.Encode("query","none")
        }
        if len(string(sectionType)) > 0 {
        queryParameters["sectionType"] = autorest.Encode("query",sectionType)
            } else {
            queryParameters["sectionType"] = autorest.Encode("query","travelMode")
        }
        if arriveAt != nil {
        queryParameters["arriveAt"] = autorest.Encode("query",*arriveAt)
        }
        if departAt != nil {
        queryParameters["departAt"] = autorest.Encode("query",*departAt)
        }
        if vehicleAxleWeight != nil {
        queryParameters["vehicleAxleWeight"] = autorest.Encode("query",*vehicleAxleWeight)
            } else {
            queryParameters["vehicleAxleWeight"] = autorest.Encode("query",0)
        }
        if vehicleLength != nil {
        queryParameters["vehicleLength"] = autorest.Encode("query",*vehicleLength)
            } else {
            queryParameters["vehicleLength"] = autorest.Encode("query",0)
        }
        if vehicleHeight != nil {
        queryParameters["vehicleHeight"] = autorest.Encode("query",*vehicleHeight)
            } else {
            queryParameters["vehicleHeight"] = autorest.Encode("query",0)
        }
        if vehicleWidth != nil {
        queryParameters["vehicleWidth"] = autorest.Encode("query",*vehicleWidth)
            } else {
            queryParameters["vehicleWidth"] = autorest.Encode("query",0)
        }
        if vehicleMaxSpeed != nil {
        queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",*vehicleMaxSpeed)
            } else {
            queryParameters["vehicleMaxSpeed"] = autorest.Encode("query",0)
        }
        if vehicleWeight != nil {
        queryParameters["vehicleWeight"] = autorest.Encode("query",*vehicleWeight)
            } else {
            queryParameters["vehicleWeight"] = autorest.Encode("query",0)
        }
        if len(string(windingness)) > 0 {
        queryParameters["windingness"] = autorest.Encode("query",windingness)
            } else {
            queryParameters["windingness"] = autorest.Encode("query","normal")
        }
        if len(string(hilliness)) > 0 {
        queryParameters["hilliness"] = autorest.Encode("query",hilliness)
            } else {
            queryParameters["hilliness"] = autorest.Encode("query","normal")
        }
        if len(string(travelMode)) > 0 {
        queryParameters["travelMode"] = autorest.Encode("query",travelMode)
            } else {
            queryParameters["travelMode"] = autorest.Encode("query","car")
        }
        if len(string(avoid)) > 0 {
        queryParameters["avoid"] = autorest.Encode("query",avoid)
        }
        if traffic != nil {
        queryParameters["traffic"] = autorest.Encode("query",*traffic)
            } else {
            queryParameters["traffic"] = autorest.Encode("query",true)
        }
        if len(string(routeType)) > 0 {
        queryParameters["routeType"] = autorest.Encode("query",routeType)
            } else {
            queryParameters["routeType"] = autorest.Encode("query","fastest")
        }
        if len(string(vehicleLoadType)) > 0 {
        queryParameters["vehicleLoadType"] = autorest.Encode("query",vehicleLoadType)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/route/matrix/{format}",pathParameters),
autorest.WithJSON(routeMatrixBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostRouteMatrixSender sends the PostRouteMatrix request. The method will close the
    // http.Response Body if it receives an error.
    func (client RouteClient) PostRouteMatrixSender(req *http.Request) (future RoutePostRouteMatrixFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // PostRouteMatrixResponder handles the response to the PostRouteMatrix request. The method always
    // closes the http.Response Body.
    func (client RouteClient) PostRouteMatrixResponder(resp *http.Response) (result RouteMatrixResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

