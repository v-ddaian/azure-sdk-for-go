package azmaps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// ElevationClient is the client for the Elevation methods of the Azmaps service.
type ElevationClient struct {
    BaseClient
}
// NewElevationClient creates an instance of the ElevationClient client.
func NewElevationClient(subscriptionKey string, xMsClientID string) ElevationClient {
    return NewElevationClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewElevationClientWithBaseURI creates an instance of the ElevationClient client using a custom endpoint.  Use this
// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewElevationClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) ElevationClient {
        return ElevationClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetDataForBoundingBox **Applies to**: S1 pricing tier.
//
// The Get Data for Bounding Box API provides elevation data at equally-spaced locations within a bounding box.  A
// bounding box is defined by the coordinates for two corners (southwest, northeast) and then subsequently  divided
// into rows and columns. Elevations are returned for the vertices of the grid created by the rows and  columns. Up to
// 2000 elevations can be returned in a single request. The returned elevation values are ordered,  starting at the
// southwest corner, and then proceeding west to east along the row. At the end of the row,  it moves north to the next
// row, and repeats the process until it reaches the far northeast corner.
    // Parameters:
        // bounds - the string that represents the rectangular area of a bounding box. The bounds parameter is defined
        // by the 4 bounding box coordinates, with WGS84 longitude and latitude of the southwest corner followed by
        // WGS84 longitude and latitude of the northeast corner. The string is presented in the following  format:
        // [SouthwestCorner_Longitude, SouthwestCorner_Latitude, NortheastCorner_Longitude,  NortheastCorner_Latitude].
        // rows - specifies the number of rows to use to divide the bounding box area into a grid. The number of
        // vertices  in the grid should be less than 2000.
        // columns - specifies the number of columns to use to divide the bounding box area into a grid. The number of
        // vertices  in the grid should be less than 2000.
func (client ElevationClient) GetDataForBoundingBox(ctx context.Context, bounds []string, rows float64, columns float64) (result BoundingBoxResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ElevationClient.GetDataForBoundingBox")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: bounds,
         Constraints: []validation.Constraint{	{Target: "bounds", Name: validation.Null, Rule: true, Chain: nil }}},
        { TargetValue: rows,
         Constraints: []validation.Constraint{	{Target: "rows", Name: validation.InclusiveMaximum, Rule: float64(1000), Chain: nil },
        	{Target: "rows", Name: validation.InclusiveMinimum, Rule: float64(2), Chain: nil }}},
        { TargetValue: columns,
         Constraints: []validation.Constraint{	{Target: "columns", Name: validation.InclusiveMaximum, Rule: float64(1000), Chain: nil },
        	{Target: "columns", Name: validation.InclusiveMinimum, Rule: float64(2), Chain: nil }}}}); err != nil {
        return result, validation.NewError("azmaps.ElevationClient", "GetDataForBoundingBox", err.Error())
        }

        req, err := client.GetDataForBoundingBoxPreparer(ctx, bounds, rows, columns)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForBoundingBox", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetDataForBoundingBoxSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForBoundingBox", resp, "Failure sending request")
        return
        }

        result, err = client.GetDataForBoundingBoxResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForBoundingBox", resp, "Failure responding to request")
        return
        }

    return
}

    // GetDataForBoundingBoxPreparer prepares the GetDataForBoundingBox request.
    func (client ElevationClient) GetDataForBoundingBoxPreparer(ctx context.Context, bounds []string, rows float64, columns float64) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "bounds": autorest.Encode("query",bounds,","),
    "columns": autorest.Encode("query",columns),
    "rows": autorest.Encode("query",rows),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/elevation/lattice/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDataForBoundingBoxSender sends the GetDataForBoundingBox request. The method will close the
    // http.Response Body if it receives an error.
    func (client ElevationClient) GetDataForBoundingBoxSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetDataForBoundingBoxResponder handles the response to the GetDataForBoundingBox request. The method always
    // closes the http.Response Body.
    func (client ElevationClient) GetDataForBoundingBoxResponder(resp *http.Response) (result BoundingBoxResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetDataForPoints **Applies to**: S1 pricing tier.
// The Get Data for Points API provides elevation data for one or more points.  A point is defined in lat,long
// coordinate format. Due to the URL character  length limit of 2048, it's not possible to pass more than 100
// coordinates  as a pipeline delimited string in a URL GET request. If you intend to pass  more than 100 coordinates
// as a pipeline delimited string, use the [POST Data
// For Points](https://docs.microsoft.com/en-us/rest/api/maps/elevation/postdataforpoints).
    // Parameters:
        // points - the string representation of a list of points. A point is defined in lat/lon WGS84 coordinate
        // reference system format.  If multiple points are requested, each of the points in a list should be separated
        // by the pipe ('|') character.  The maximum number of points that can be requested in a single request is
        // 2,000. The resolution of the elevation  data will be the highest for a single point and will decrease if
        // multiple points are spread further apart.
func (client ElevationClient) GetDataForPoints(ctx context.Context, points [][]string) (result PointsResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ElevationClient.GetDataForPoints")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: points,
         Constraints: []validation.Constraint{	{Target: "points", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("azmaps.ElevationClient", "GetDataForPoints", err.Error())
        }

        req, err := client.GetDataForPointsPreparer(ctx, points)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForPoints", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetDataForPointsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForPoints", resp, "Failure sending request")
        return
        }

        result, err = client.GetDataForPointsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForPoints", resp, "Failure responding to request")
        return
        }

    return
}

    // GetDataForPointsPreparer prepares the GetDataForPoints request.
    func (client ElevationClient) GetDataForPointsPreparer(ctx context.Context, points [][]string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "points": autorest.Encode("query",points,"|"),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/elevation/point/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDataForPointsSender sends the GetDataForPoints request. The method will close the
    // http.Response Body if it receives an error.
    func (client ElevationClient) GetDataForPointsSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetDataForPointsResponder handles the response to the GetDataForPoints request. The method always
    // closes the http.Response Body.
    func (client ElevationClient) GetDataForPointsResponder(resp *http.Response) (result PointsResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetDataForPolyline **Applies to**: S1 pricing tier.
//
// The Get Data for Polyline API provides elevation data along a polyline. A polyline is defined by  passing in between
// 2 and N endpoint coordinates separated by a pipe ('|') character. In addition  to passing in endpoints, customers
// can specify number of sample points that will be used to divide  polyline into equally spaced segments. Elevation
// data at both start and end points and equally spaced  points along the polyline will be returned. A line between two
// endpoints is a straight Cartesian line, the  shortest line between those two points in the coordinate reference
// system. Note that the point is  chosen based on Euclidean distance and may markedly differ from the geodesic path
// along the curved  surface of the reference ellipsoid.
    // Parameters:
        // lines - the string representation of a polyline path. A polyline is defined by endpoint coordinates,  with
        // each endpoint separated by a pipe ('|') character. The polyline should be defined in the  following format:
        // [longitude_point1, latitude_point1 | longitude_point2, latitude_point2, ...,  longitude_pointN,
        // latitude_pointN]. The longitude and latitude values refer to the World Geodetic  System (WGS84) coordinate
        // reference system. The resolution of the data used to compute the  elevation will depend on the distance
        // between the endpoints.
        // samples - the samples parameter specifies the number of equally spaced points at which elevation values
        // should be provided along a polyline path. The number of samples should range from 2 to 2,000. Default value
        // is 10 if not provided.
func (client ElevationClient) GetDataForPolyline(ctx context.Context, lines [][]string, samples *float64) (result LinesResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ElevationClient.GetDataForPolyline")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: lines,
         Constraints: []validation.Constraint{	{Target: "lines", Name: validation.Null, Rule: true, Chain: nil }}},
        { TargetValue: samples,
         Constraints: []validation.Constraint{	{Target: "samples", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "samples", Name: validation.InclusiveMaximum, Rule: float64(2000), Chain: nil },
        	{Target: "samples", Name: validation.InclusiveMinimum, Rule: float64(2), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.ElevationClient", "GetDataForPolyline", err.Error())
        }

        req, err := client.GetDataForPolylinePreparer(ctx, lines, samples)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForPolyline", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetDataForPolylineSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForPolyline", resp, "Failure sending request")
        return
        }

        result, err = client.GetDataForPolylineResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "GetDataForPolyline", resp, "Failure responding to request")
        return
        }

    return
}

    // GetDataForPolylinePreparer prepares the GetDataForPolyline request.
    func (client ElevationClient) GetDataForPolylinePreparer(ctx context.Context, lines [][]string, samples *float64) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "lines": autorest.Encode("query",lines,"|"),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if samples != nil {
        queryParameters["samples"] = autorest.Encode("query",*samples)
            } else {
            queryParameters["samples"] = autorest.Encode("query",10)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/elevation/line/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDataForPolylineSender sends the GetDataForPolyline request. The method will close the
    // http.Response Body if it receives an error.
    func (client ElevationClient) GetDataForPolylineSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetDataForPolylineResponder handles the response to the GetDataForPolyline request. The method always
    // closes the http.Response Body.
    func (client ElevationClient) GetDataForPolylineResponder(resp *http.Response) (result LinesResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostDataForPoints **Applies to**: S1 pricing tier.
// The Post Data for Points API provides elevation data for multiple points.  A point is defined in lat/lon coordinate
// format. Use the POST endpoint only  if you intend to pass multiple points in the request. If you intend to pass  a
// single coordinate into the API, use the [GET Data For Points
// API](https://docs.microsoft.com/en-us/rest/api/maps/elevation/getdataforpoints).
    // Parameters:
        // pointsRequestBody - the string representation of a list of points. A point is defined in lat/lon WGS84
        // coordinate reference system format.  Each points in a list should be separated by the pipe ('|') character.
        // The number of points that can be requested in  a POST request ranges from 2 to 2,000. The resolution of the
        // elevation data will be the highest for a single point  and will decrease if multiple points are spread
        // further apart.
func (client ElevationClient) PostDataForPoints(ctx context.Context, pointsRequestBody []CoordinateAbbreviated) (result PointsResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ElevationClient.PostDataForPoints")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: pointsRequestBody,
         Constraints: []validation.Constraint{	{Target: "pointsRequestBody", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("azmaps.ElevationClient", "PostDataForPoints", err.Error())
        }

        req, err := client.PostDataForPointsPreparer(ctx, pointsRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "PostDataForPoints", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostDataForPointsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "PostDataForPoints", resp, "Failure sending request")
        return
        }

        result, err = client.PostDataForPointsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "PostDataForPoints", resp, "Failure responding to request")
        return
        }

    return
}

    // PostDataForPointsPreparer prepares the PostDataForPoints request.
    func (client ElevationClient) PostDataForPointsPreparer(ctx context.Context, pointsRequestBody []CoordinateAbbreviated) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/elevation/point/{format}",pathParameters),
autorest.WithJSON(pointsRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostDataForPointsSender sends the PostDataForPoints request. The method will close the
    // http.Response Body if it receives an error.
    func (client ElevationClient) PostDataForPointsSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostDataForPointsResponder handles the response to the PostDataForPoints request. The method always
    // closes the http.Response Body.
    func (client ElevationClient) PostDataForPointsResponder(resp *http.Response) (result PointsResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostDataForPolyline **Applies to**: S1 pricing tier.
// The Post Data for Polyline API provides elevation data along a polyline. A polyline is defined by  passing in
// between 2 and N endpoint coordinates separated by a pipe ('|') character. In addition  to passing in endpoints,
// customers can specify number of sample points that will be used to divide  polyline into equally spaced segments.
// Elevation data at both start and end points and equally spaced  points along the polyline will be returned. A line
// between two endpoints is a straight Cartesian line, the  shortest line between those two points in the coordinate
// reference system. Note that the point is  chosen based on Euclidean distance and may markedly differ from the
// geodesic path along the curved  surface of the reference ellipsoid.
    // Parameters:
        // linesRequestBody - the string representation of a polyline path. A polyline is defined by endpoint
        // coordinates,  with each endpoint separated by a pipe ('|') character. The polyline should be defined in the
        // following format: [longitude_point1, latitude_point1 | longitude_point2, latitude_point2, ...,
        // longitude_pointN, latitude_pointN]. The longitude and latitude values refer to the World Geodetic  System
        // (WGS84) coordinate reference system. The resolution of the data used to compute the  elevation will depend
        // on the distance between the endpoints.
        // samples - the samples parameter specifies the number of equally spaced points at which elevation values
        // should be provided along a polyline path. The number of samples should range from 2 to 2,000. Default value
        // is 10 if not provided.
func (client ElevationClient) PostDataForPolyline(ctx context.Context, linesRequestBody []CoordinateAbbreviated, samples *float64) (result LinesResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ElevationClient.PostDataForPolyline")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: linesRequestBody,
         Constraints: []validation.Constraint{	{Target: "linesRequestBody", Name: validation.Null, Rule: true, Chain: nil }}},
        { TargetValue: samples,
         Constraints: []validation.Constraint{	{Target: "samples", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "samples", Name: validation.InclusiveMaximum, Rule: float64(2000), Chain: nil },
        	{Target: "samples", Name: validation.InclusiveMinimum, Rule: float64(2), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("azmaps.ElevationClient", "PostDataForPolyline", err.Error())
        }

        req, err := client.PostDataForPolylinePreparer(ctx, linesRequestBody, samples)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "PostDataForPolyline", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostDataForPolylineSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "PostDataForPolyline", resp, "Failure sending request")
        return
        }

        result, err = client.PostDataForPolylineResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.ElevationClient", "PostDataForPolyline", resp, "Failure responding to request")
        return
        }

    return
}

    // PostDataForPolylinePreparer prepares the PostDataForPolyline request.
    func (client ElevationClient) PostDataForPolylinePreparer(ctx context.Context, linesRequestBody []CoordinateAbbreviated, samples *float64) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if samples != nil {
        queryParameters["samples"] = autorest.Encode("query",*samples)
            } else {
            queryParameters["samples"] = autorest.Encode("query",10)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/elevation/line/{format}",pathParameters),
autorest.WithJSON(linesRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostDataForPolylineSender sends the PostDataForPolyline request. The method will close the
    // http.Response Body if it receives an error.
    func (client ElevationClient) PostDataForPolylineSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostDataForPolylineResponder handles the response to the PostDataForPolyline request. The method always
    // closes the http.Response Body.
    func (client ElevationClient) PostDataForPolylineResponder(resp *http.Response) (result LinesResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

