package azmaps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// MobilityClient is the client for the Mobility methods of the Azmaps service.
type MobilityClient struct {
    BaseClient
}
// NewMobilityClient creates an instance of the MobilityClient client.
func NewMobilityClient(subscriptionKey string, xMsClientID string) MobilityClient {
    return NewMobilityClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewMobilityClientWithBaseURI creates an instance of the MobilityClient client using a custom endpoint.  Use this
// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewMobilityClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) MobilityClient {
        return MobilityClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetMetroAreaInfoPreview **Metro Area Info API**
//
// **Applies to**: S1 pricing tier.
//
// Service allows users to request additional information for metro areas in which the Azure Maps Mobility services are
// available. Information such as supported transit types, transit agencies and active alerts is available, depending
// on the options selected. Also, the service returns information if the public transit fare information is available
// for the requested metro area.
    // Parameters:
        // query - metroId. The unique id of the metro area. Required parameter specifying the required metro area to
        // search in. Can be retrieved via [Get Metro Area API](https://aka.ms/AzureMapsMobilityTransitRoute).
        // detailType - specify details requested respective to the metro area as a comma separated list. Supported
        // values are:
        // * `agencies` - Return a list of all public transit agencies operating in the given metro area.
        // * `alerts` - Returns a list of all active service alerts, that are defined in the metro or agency level, and
        // are not connected to a specific line or stop.
        // * `alertDetails` - Applicable only when alerts are requested. Returns details of the alerts.
        // * `transitTypes` - Returns a list of all supported transit types in the given metro area.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetMetroAreaInfoPreview(ctx context.Context, query int32, detailType []MetroAreaDetailType, language string) (result MetroAreaInfoResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetMetroAreaInfoPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: detailType,
         Constraints: []validation.Constraint{	{Target: "detailType", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("azmaps.MobilityClient", "GetMetroAreaInfoPreview", err.Error())
        }

        req, err := client.GetMetroAreaInfoPreviewPreparer(ctx, query, detailType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetMetroAreaInfoPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetMetroAreaInfoPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetMetroAreaInfoPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetMetroAreaInfoPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetMetroAreaInfoPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetMetroAreaInfoPreviewPreparer prepares the GetMetroAreaInfoPreview request.
    func (client MobilityClient) GetMetroAreaInfoPreviewPreparer(ctx context.Context, query int32, detailType []MetroAreaDetailType, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "detailType": autorest.Encode("query",detailType,","),
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/metroArea/info/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetMetroAreaInfoPreviewSender sends the GetMetroAreaInfoPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetMetroAreaInfoPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMetroAreaInfoPreviewResponder handles the response to the GetMetroAreaInfoPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetMetroAreaInfoPreviewResponder(resp *http.Response) (result MetroAreaInfoResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetMetroAreaPreview **Metro Area API**
//
// **Applies to**: S1 pricing tier.
//
// Service allows users to request metro areas in which the Azure Maps Mobility Service is available. The service
// supports filtering results by country or coordinate location. Information returned includes Metro Area  details such
// as metro Id, name and a representation of the metro area geometry in GeoJSON format.
    // Parameters:
        // query - the applicable location input. Can be position (specified as a comma  separated string composed by
        // latitude followed by longitude e.g. "47.641268,-122.125679") or  countryCode (2-character ISO country code).
        // queryType - the type of the query. By default originType=position, specified as a comma separated string
        // composed by latitude followed by longitude, e.g. "47.641268,-122.125679”.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetMetroAreaPreview(ctx context.Context, query string, queryType MetroAreaQueryType, language string) (result MetroAreaResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetMetroAreaPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetMetroAreaPreviewPreparer(ctx, query, queryType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetMetroAreaPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetMetroAreaPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetMetroAreaPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetMetroAreaPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetMetroAreaPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetMetroAreaPreviewPreparer prepares the GetMetroAreaPreview request.
    func (client MobilityClient) GetMetroAreaPreviewPreparer(ctx context.Context, query string, queryType MetroAreaQueryType, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(queryType)) > 0 {
        queryParameters["queryType"] = autorest.Encode("query",queryType)
            } else {
            queryParameters["queryType"] = autorest.Encode("query","position")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/metroArea/id/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetMetroAreaPreviewSender sends the GetMetroAreaPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetMetroAreaPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMetroAreaPreviewResponder handles the response to the GetMetroAreaPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetMetroAreaPreviewResponder(resp *http.Response) (result MetroAreaResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetNearbyTransitPreview **Find Nearby Transit API**
//
// **Applies to**: S1 pricing tier.
//
// Get Nearby Transit service allows you to search public transit stops around a given location  returning the transit
// object details. Service allows users to search for public transit stops within a given radius returning a set of
// stops with stop details. Additional  information such as transit operator information is returned depending on the
// options selected. The returned information can be used for further processing such as requesting [real-time
// arrivals](https://aka.ms/AzureMapsMobilityRealTimeArrivals) for the stop or [transit stop
// details](https://aka.ms/AzureMapsMobilityTransitStop) such as main transit type of most lines stopping for a given
// public, active service alerts or main transport agency.
    // Parameters:
        // query - location input from user. The applicable location query specified as a comma separated string
        // composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        // metroID - the unique id of the metro area. Can be retrieved via [Get Metro Area
        // API](https://aka.ms/AzureMapsMobilityMetro).
        // limit - maximum number of responses that will be returned. Default is 3, minimum 1 and maximum 100. Sort
        // order is based on distance from input location.
        // radius - specifies the search area to constrain a search. The radius in meters  to for the results to be
        // constrained to the defined area. Default value is 30 meters, minimum 1 meter and maximum 5000 meters (5km).
        // objectType - the transit object type. By default, objectType is set to `stop`
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetNearbyTransitPreview(ctx context.Context, query string, metroID *int32, limit *int32, radius *int32, objectType string, language string) (result NearbyTransitResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetNearbyTransitPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetNearbyTransitPreviewPreparer(ctx, query, metroID, limit, radius, objectType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetNearbyTransitPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetNearbyTransitPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetNearbyTransitPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetNearbyTransitPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetNearbyTransitPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetNearbyTransitPreviewPreparer prepares the GetNearbyTransitPreview request.
    func (client MobilityClient) GetNearbyTransitPreviewPreparer(ctx context.Context, query string, metroID *int32, limit *int32, radius *int32, objectType string, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if metroID != nil {
        queryParameters["metroId"] = autorest.Encode("query",*metroID)
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
        }
        if radius != nil {
        queryParameters["radius"] = autorest.Encode("query",*radius)
        }
        if len(objectType) > 0 {
        queryParameters["objectType"] = autorest.Encode("query",objectType)
            } else {
            queryParameters["objectType"] = autorest.Encode("query","stop")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/transit/nearby/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetNearbyTransitPreviewSender sends the GetNearbyTransitPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetNearbyTransitPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetNearbyTransitPreviewResponder handles the response to the GetNearbyTransitPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetNearbyTransitPreviewResponder(resp *http.Response) (result NearbyTransitResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetRealTimeArrivalsPreview **Real-time Arrivals API**
//
// **Applies to**: S1 pricing tier.
//
// Get Real Time Arrivals API returns for a given a stop, line or location the requested number of real-time arrivals.
// Endpoint support different modes to request real-time arrivals such as number of live arrivals for all lines
// arriving at the specified stop or all arrivals of a line to stops near the user’s location. The API supports
// parameters to request one or multiple public transit types such as bus, tram and subway, maximum number if arrivals,
// and prefer a specific transit agency operating in the area. In some cases real-time arrivals may not be available,
// for example, if arrival is too far in the future or transit vehicle does not have capability to share the real-time
// location. This is symbolized in a scheduleType field present in all responses.
    // Parameters:
        // query - stop, line or location identifier.
        // metroID - the unique id of the metro area. Can be retrieved via [Get Metro Area
        // API](https://aka.ms/AzureMapsMobilityMetro).
        // queryType - the type of the query parameter. Defines the mode of the request. Only one mode per request is
        // supported. By default queryType is set to be ‘stops’ returning the requested number of Live Arrivals for all
        // lines arriving at the specified stop.
        // stopQueryType - the type of the unique query parameter of the stop. By default stopQueryType=stopId. This
        // parameter can only be used in conjunction with queryType=stops or queryType=lineAndStop.
        // limit - the maximum arrivals to return. If not specified, the system default will be used. For stops max
        // number of arrivals per stop. For lines max arrivals per stop on the line. For everything else max arrivals
        // overall.
        // maxMinutesInFuture - the maximum time (in minutes) in the future to return arrivals for. If not specified,
        // the system default (30 minutes) will be used.  The minimum value is 0 and maximum value is 60 minutes.
        // transitType - type of public transit user is requesting respective transit stop, as a comma separated list.
        // For example, transitType=Bus,Subway. If not specified, all will be allowed. This parameter can only be used
        // in conjunction with queryType=stops. Supported values are:
        // * `bus` - Bus
        // * `cableCar` - Cable car
        // * `ferry` - Ferry
        // * `funicular` - Funicular
        // * `gondola` - Gondola
        // * `rail` - Rail
        // * `tram` - Tram
        // * `subway` - Subway/Metro
        // agency - in case you prefer routes from a specific set of agencies to be returned. Specified as a comma
        // separated string.
        // agencyType - specifies the agency identifier to request routes from a specific set of agencies to be
        // returned. By default the agencyType=agencyId.
        // timeoutInSeconds - time in seconds within which if the provider doesn’t respond, end point will return
        // static data.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetRealTimeArrivalsPreview(ctx context.Context, query string, metroID *int32, queryType RealTimeArrivalsQueryType, stopQueryType StopQueryType, limit *int32, maxMinutesInFuture *int32, transitType []TransitTypeFilter, agency []string, agencyType AgencyType, timeoutInSeconds *int32, language string) (result RealTimeArrivalsResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetRealTimeArrivalsPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetRealTimeArrivalsPreviewPreparer(ctx, query, metroID, queryType, stopQueryType, limit, maxMinutesInFuture, transitType, agency, agencyType, timeoutInSeconds, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetRealTimeArrivalsPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetRealTimeArrivalsPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetRealTimeArrivalsPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetRealTimeArrivalsPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetRealTimeArrivalsPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetRealTimeArrivalsPreviewPreparer prepares the GetRealTimeArrivalsPreview request.
    func (client MobilityClient) GetRealTimeArrivalsPreviewPreparer(ctx context.Context, query string, metroID *int32, queryType RealTimeArrivalsQueryType, stopQueryType StopQueryType, limit *int32, maxMinutesInFuture *int32, transitType []TransitTypeFilter, agency []string, agencyType AgencyType, timeoutInSeconds *int32, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if metroID != nil {
        queryParameters["metroId"] = autorest.Encode("query",*metroID)
        }
        if len(string(queryType)) > 0 {
        queryParameters["queryType"] = autorest.Encode("query",queryType)
            } else {
            queryParameters["queryType"] = autorest.Encode("query","stops")
        }
        if len(string(stopQueryType)) > 0 {
        queryParameters["stopQueryType"] = autorest.Encode("query",stopQueryType)
            } else {
            queryParameters["stopQueryType"] = autorest.Encode("query","stopId")
        }
        if limit != nil {
        queryParameters["limit"] = autorest.Encode("query",*limit)
        }
        if maxMinutesInFuture != nil {
        queryParameters["maxMinutesInFuture"] = autorest.Encode("query",*maxMinutesInFuture)
        }
        if transitType != nil && len(transitType) > 0 {
        queryParameters["transitType"] = autorest.Encode("query",transitType,",")
        }
        if agency != nil && len(agency) > 0 {
        queryParameters["agency"] = autorest.Encode("query",agency,",")
        }
        if len(string(agencyType)) > 0 {
        queryParameters["agencyType"] = autorest.Encode("query",agencyType)
            } else {
            queryParameters["agencyType"] = autorest.Encode("query","agencyId")
        }
        if timeoutInSeconds != nil {
        queryParameters["timeoutInSeconds"] = autorest.Encode("query",*timeoutInSeconds)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/realtime/arrivals/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetRealTimeArrivalsPreviewSender sends the GetRealTimeArrivalsPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetRealTimeArrivalsPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRealTimeArrivalsPreviewResponder handles the response to the GetRealTimeArrivalsPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetRealTimeArrivalsPreviewResponder(resp *http.Response) (result RealTimeArrivalsResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTransitItineraryPreview **Transit Itinerary API**
//
// **Applies to**: S1 pricing tier.
//
// Returns data according to an itinerary Id previously returned by [Transit Route
// API](https://aka.ms/AzureMapsMobilityTransitRoute). The basic info contains data as to the various legs comprising
// the itinerary, including the locations, public transit lines, start and end times and fare information. Users can
// request additional routing information such as the  shape of the itinerary and detailed itinerary schedules is also
// available, depending on the options selected. An itinerary is available up to 24  hours following a search request.
    // Parameters:
        // query - the unique id (itineraryId) of an itinerary previously returned by [Transit Route
        // API](https://aka.ms/AzureMapsMobilityTransitRoute).
        // detailType - specify additional details returned in the transit route itinerary response, as a comma
        // separated list. Supported values are:
        // * `geometry` - Shape of an in GeoJSON format. For public transit legs will return also the stops that the
        // leg passes through. For walk and bike legs, will return also the turn-by-turn navigation data.
        // * `schedule` - Static schedule data as to all departures of Public Transit legs from the current time of the
        // day to the end of the current day.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetTransitItineraryPreview(ctx context.Context, query string, detailType []TransitItineraryDetailType, language string) (result TransitItineraryResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetTransitItineraryPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTransitItineraryPreviewPreparer(ctx, query, detailType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitItineraryPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTransitItineraryPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitItineraryPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetTransitItineraryPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitItineraryPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTransitItineraryPreviewPreparer prepares the GetTransitItineraryPreview request.
    func (client MobilityClient) GetTransitItineraryPreviewPreparer(ctx context.Context, query string, detailType []TransitItineraryDetailType, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if detailType != nil && len(detailType) > 0 {
        queryParameters["detailType"] = autorest.Encode("query",detailType,",")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/transit/itinerary/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTransitItineraryPreviewSender sends the GetTransitItineraryPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetTransitItineraryPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTransitItineraryPreviewResponder handles the response to the GetTransitItineraryPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetTransitItineraryPreviewResponder(resp *http.Response) (result TransitItineraryResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTransitLineInfoPreview **Transit Line Info API**
//
// **Applies to**: S1 pricing tier.
//
// Your scenario might require requesting transit line specific data such as stops and line geometry. Transit Line Info
// service  allows you to request line group by line group id returning a line group comprised a set of lines.
// Additional information such  as 24 hours static schedule, active alerts for the line group and line patterns is also
// available, depending on the options  selected. Mobility services uses a parallel data model for public transit lines
// and line groups. Usually line group contains  2 lines, one going from A to B, and the other returning from B to A,
// both operating by the same Public Transport Agency having  the same line number. We recommend you review our
// guidance [article](https://aka.ms/AMapsPublicTRansitConcepts) to understand  the concepts of lines and line groups.
    // Parameters:
        // query - lineGroupId, for example,'666074'. Typically contains 2 lines having the same agency and line, one
        // going from A to B, and the other from B to A.
        // metroID - the unique id of the metro area. Can be retrieved via [Get Metro Area
        // API](https://aka.ms/AzureMapsMobilityMetro).
        // detailType - specify additional details requested respective to the line group as a comma separated list. As
        // a default service returns line basic info. Supported values are:
        // * `alerts` - Return any active service alerts for the specified stop. Response provides brief information
        // for disruption in service and all basic data associated with the alert.
        // * `alertDetails` - Can only be used in conjunction with detailType=alerts.Return additional details
        // associated with the active service alerts.
        // * `lines` - Return transit lines that stops at the specified stop.
        // * `stops` - Return list of stops the line group goes through.
        // * `schedule` - Return a 24h static schedule for the specified line group from the current time of the day to
        // the end of the current day.
        // * `patterns` - Return list of patterns this group is comprised of. A pattern consists of a stop sequence and
        // shape per line.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetTransitLineInfoPreview(ctx context.Context, query string, metroID *int32, detailType []TransitLineDetailType, language string) (result TransitLineInfoResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetTransitLineInfoPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTransitLineInfoPreviewPreparer(ctx, query, metroID, detailType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitLineInfoPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTransitLineInfoPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitLineInfoPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetTransitLineInfoPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitLineInfoPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTransitLineInfoPreviewPreparer prepares the GetTransitLineInfoPreview request.
    func (client MobilityClient) GetTransitLineInfoPreviewPreparer(ctx context.Context, query string, metroID *int32, detailType []TransitLineDetailType, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if metroID != nil {
        queryParameters["metroId"] = autorest.Encode("query",*metroID)
        }
        if detailType != nil && len(detailType) > 0 {
        queryParameters["detailType"] = autorest.Encode("query",detailType,",")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/transit/line/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTransitLineInfoPreviewSender sends the GetTransitLineInfoPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetTransitLineInfoPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTransitLineInfoPreviewResponder handles the response to the GetTransitLineInfoPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetTransitLineInfoPreviewResponder(resp *http.Response) (result TransitLineInfoResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTransitRoutePreview **Transit Route API**
//
// **Applies to**: S1 pricing tier.
//
// Get Transit Route API will allow trip planning returning the best possible route options between an origin and
// destination by using multi-modal search. Service provides a variety of travel modes, including walk, bike, and
// public transit.  The API supports parameters to request one or multiple public transit types such as bus, tram and
// subway, and prefer a specific transit agency operating in the area. Also, service provides transit fare details and
// options to choose optimal route with least walk or transfers and specify arrival or departure times when user need
// to be at a specific destination by a certain time.
    // Parameters:
        // origin - the origin of the route. By default originType=position, specified as a comma separated string
        // composed by latitude followed by longitude, e.g. "47.641268,-122.125679”.
        // destination - the destination of the route. By default the destinationType=position, specified as a comma
        // separated string composed by latitude followed by longitude, e.g. "47.641268,-122.125679”.
        // metroID - the unique id of the metro area. Can be retrieved via [Get Metro Area
        // API](https://aka.ms/AzureMapsMobilityMetro).
        // originType - the type of the origin. By default originType=position, specified as a comma separated string
        // composed by latitude followed by longitude, e.g., "47.641268,-122.125679”.
        // destinationType - the type of the destination.
        // modeType - the mode of travel for the requested route; as comma separated list. If not specified, all modes
        // will be allowed. All modes might not be available in all metro areas. If valid trip is not found, empty
        // result will be returned. Supported values are:
        // * `walk` - Walk (pedestrian)
        // * `bike` - Bike
        // * `publicTransit` - Public transit
        // transitType - applicable only with modeType = publicTransit. Allow only a specific set of public transit
        // types (as a comma separated list) to be returned for the route.  Note that the requested transitType may not
        // be available for the entire route. If not specified, all modes will be allowed. Supported values are:
        // * `bus` - Bus
        // * `cableCar` - Cable car
        // * `ferry` - Ferry
        // * `funicular` - Funicular
        // * `gondola` - Gondola
        // * `rail` - Rail
        // * `tram` - Tram
        // * `subway` - Subway/Metro
        // agency - specifies whether to prefer routes from a specific set of agencies if possible; as a comma
        // separated list. If valid trip isn’t found with the preferred agency, or only one with very long trips or
        // with large number of transfers, itineraries with other agencies will be returned.
        // agencyType - specifies the agency identifier to request routes from preferred agencies. By default the
        // agencyType=agencyId.
        // timeParameter - the time of departure or arrival in the local time in ISO format
        // (2019-04-05T14:24:18-04:00). If timeType is not specified, it will be assumed to be 'departure' and time is
        // the current local time at the origin point.
        // timeType - specifies whether the time signifies departure time or arrival time. If not defined, default
        // value is 'departure'.
        // routeType - the type of route requested. If not specified, 'optimal' will be used.
        // bikeType - bike type of the bike. Specifies which type of bikes will be used. Only private bikes are
        // supported.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetTransitRoutePreview(ctx context.Context, origin string, destination string, metroID *int32, originType OriginType, destinationType DestinationType, modeType []ModeType, transitType []TransitTypeFilter, agency []string, agencyType AgencyType, timeParameter string, timeType TimeType, routeType TransitRouteType, bikeType string, language string) (result TransitRouteResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetTransitRoutePreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTransitRoutePreviewPreparer(ctx, origin, destination, metroID, originType, destinationType, modeType, transitType, agency, agencyType, timeParameter, timeType, routeType, bikeType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitRoutePreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTransitRoutePreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitRoutePreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetTransitRoutePreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitRoutePreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTransitRoutePreviewPreparer prepares the GetTransitRoutePreview request.
    func (client MobilityClient) GetTransitRoutePreviewPreparer(ctx context.Context, origin string, destination string, metroID *int32, originType OriginType, destinationType DestinationType, modeType []ModeType, transitType []TransitTypeFilter, agency []string, agencyType AgencyType, timeParameter string, timeType TimeType, routeType TransitRouteType, bikeType string, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "destination": autorest.Encode("query",destination),
    "origin": autorest.Encode("query",origin),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if metroID != nil {
        queryParameters["metroId"] = autorest.Encode("query",*metroID)
        }
        if len(string(originType)) > 0 {
        queryParameters["originType"] = autorest.Encode("query",originType)
            } else {
            queryParameters["originType"] = autorest.Encode("query","position")
        }
        if len(string(destinationType)) > 0 {
        queryParameters["destinationType"] = autorest.Encode("query",destinationType)
            } else {
            queryParameters["destinationType"] = autorest.Encode("query","position")
        }
        if modeType != nil && len(modeType) > 0 {
        queryParameters["modeType"] = autorest.Encode("query",modeType,",")
        }
        if transitType != nil && len(transitType) > 0 {
        queryParameters["transitType"] = autorest.Encode("query",transitType,",")
        }
        if agency != nil && len(agency) > 0 {
        queryParameters["agency"] = autorest.Encode("query",agency,",")
        }
        if len(string(agencyType)) > 0 {
        queryParameters["agencyType"] = autorest.Encode("query",agencyType)
            } else {
            queryParameters["agencyType"] = autorest.Encode("query","agencyId")
        }
        if len(timeParameter) > 0 {
        queryParameters["time"] = autorest.Encode("query",timeParameter)
        }
        if len(string(timeType)) > 0 {
        queryParameters["timeType"] = autorest.Encode("query",timeType)
            } else {
            queryParameters["timeType"] = autorest.Encode("query","departure")
        }
        if len(string(routeType)) > 0 {
        queryParameters["routeType"] = autorest.Encode("query",routeType)
            } else {
            queryParameters["routeType"] = autorest.Encode("query","optimal")
        }
        if len(bikeType) > 0 {
        queryParameters["bikeType"] = autorest.Encode("query",bikeType)
            } else {
            queryParameters["bikeType"] = autorest.Encode("query","privateBike")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/transit/route/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTransitRoutePreviewSender sends the GetTransitRoutePreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetTransitRoutePreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTransitRoutePreviewResponder handles the response to the GetTransitRoutePreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetTransitRoutePreviewResponder(resp *http.Response) (result TransitRouteResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTransitStopInfoPreview **Transit Stop Info API**
//
// **Applies to**: S1 pricing tier.
//
// Get Transit Stop Info service allows you to request information for a given public transit stop. Basic information
// returned includes  details such as main transit type of most lines stopping for a given public and main transport
// agency. Additional details such as stop  lines and active service alerts for specified stop are also available,
// depending on the options selected.
    // Parameters:
        // query - the stopId or stopKey for which the user is requesting transit stop details.
        // metroID - the unique id of the metro area. Can be retrieved via [Get Metro Area
        // API](https://aka.ms/AzureMapsMobilityMetro).
        // queryType - the type of the unique query parameter of the stop. By default queryType=stopId.
        // detailType - specify additional details requested respective to the transit stop as a comma separated list.
        // Supported values are:
        // * `alerts` - Return any active service alerts for the specified stop. Response provides brief information
        // for disruption in service and all basic data associated with the alert.
        // * `alertDetails` - Can only be used in conjunction with detailType=alerts.Return additional details
        // associated with the active service alerts.
        // * `lines` - Return transit lines that stops at the specified stop.
        // * `lineGroups` - Return line groups that stops at the specified stop.
        // language - language in which search results will be returned.  Only NGT is supported. Please refer to
        // [Supported languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
func (client MobilityClient) GetTransitStopInfoPreview(ctx context.Context, query string, metroID *int32, queryType TransitStopQueryType, detailType []TransitStopDetailType, language string) (result TransitStopInfoResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/MobilityClient.GetTransitStopInfoPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTransitStopInfoPreviewPreparer(ctx, query, metroID, queryType, detailType, language)
    if err != nil {
    err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitStopInfoPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTransitStopInfoPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitStopInfoPreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetTransitStopInfoPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azmaps.MobilityClient", "GetTransitStopInfoPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTransitStopInfoPreviewPreparer prepares the GetTransitStopInfoPreview request.
    func (client MobilityClient) GetTransitStopInfoPreviewPreparer(ctx context.Context, query string, metroID *int32, queryType TransitStopQueryType, detailType []TransitStopDetailType, language string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if metroID != nil {
        queryParameters["metroId"] = autorest.Encode("query",*metroID)
        }
        if len(string(queryType)) > 0 {
        queryParameters["queryType"] = autorest.Encode("query",queryType)
            } else {
            queryParameters["queryType"] = autorest.Encode("query","stopId")
        }
        if detailType != nil && len(detailType) > 0 {
        queryParameters["detailType"] = autorest.Encode("query",detailType,",")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mobility/transit/stop/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTransitStopInfoPreviewSender sends the GetTransitStopInfoPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client MobilityClient) GetTransitStopInfoPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTransitStopInfoPreviewResponder handles the response to the GetTransitStopInfoPreview request. The method always
    // closes the http.Response Body.
    func (client MobilityClient) GetTransitStopInfoPreviewResponder(resp *http.Response) (result TransitStopInfoResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

