package maps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// TrafficClient is the client for the Traffic methods of the Maps service.
type TrafficClient struct {
    BaseClient
}
// NewTrafficClient creates an instance of the TrafficClient client.
func NewTrafficClient(subscriptionKey string, xMsClientID string) TrafficClient {
    return NewTrafficClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewTrafficClientWithBaseURI creates an instance of the TrafficClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewTrafficClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) TrafficClient {
        return TrafficClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetTrafficFlowSegment __Traffic Flow Segment__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
// This service provides information about the speeds and travel times of the road fragment closest to the given
// coordinates. It is designed to work alongside the Flow layer of the Render Service to support clickable  flow data
// visualizations. With this API, the client side can connect any place in the map with flow data on the  closest road
// and present it to the user.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // style - the style to be used to render the tile. Valid values are absolute which returns colors reflecting
        // the absolute speed measured, relative which returns the speed relative to free-flow, Relative-delay which
        // displays relative speeds only where they are different from the freeflow speeds
        // zoom - zoom level for the desired tile. Zoom value must be in the range: 0-22 (inclusive).
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // query - coordinates of the point close to the road segment. They have to be comma-separated and calculated
        // using EPSG4326 projection.
        // unit - unit of speed in KMPH or MPH
        // thickness - the value of the width of the line representing traffic. This value is a multiplier and the
        // accepted values range from 1 - 20. The default value is 10.
        // openLr - boolean on whether the response should include OpenLR code
func (client TrafficClient) GetTrafficFlowSegment(ctx context.Context, formatParameter TextFormat, style TrafficFlowSegmentStyle, zoom int32, query string, unit SpeedUnit, thickness *int32, openLr *bool) (result TrafficFlowSegmentResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TrafficClient.GetTrafficFlowSegment")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: thickness,
         Constraints: []validation.Constraint{	{Target: "thickness", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "thickness", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil },
        	{Target: "thickness", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("maps.TrafficClient", "GetTrafficFlowSegment", err.Error())
        }

        req, err := client.GetTrafficFlowSegmentPreparer(ctx, formatParameter, style, zoom, query, unit, thickness, openLr)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficFlowSegment", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTrafficFlowSegmentSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficFlowSegment", resp, "Failure sending request")
        return
        }

        result, err = client.GetTrafficFlowSegmentResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficFlowSegment", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTrafficFlowSegmentPreparer prepares the GetTrafficFlowSegment request.
    func (client TrafficClient) GetTrafficFlowSegmentPreparer(ctx context.Context, formatParameter TextFormat, style TrafficFlowSegmentStyle, zoom int32, query string, unit SpeedUnit, thickness *int32, openLr *bool) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    "style": autorest.Encode("query",style),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(unit)) > 0 {
        queryParameters["unit"] = autorest.Encode("query",unit)
            } else {
            queryParameters["unit"] = autorest.Encode("query","KMPH")
        }
        if thickness != nil {
        queryParameters["thickness"] = autorest.Encode("query",*thickness)
            } else {
            queryParameters["thickness"] = autorest.Encode("query",10)
        }
        if openLr != nil {
        queryParameters["openLr"] = autorest.Encode("query",*openLr)
            } else {
            queryParameters["openLr"] = autorest.Encode("query",false)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/traffic/flow/segment/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTrafficFlowSegmentSender sends the GetTrafficFlowSegment request. The method will close the
    // http.Response Body if it receives an error.
    func (client TrafficClient) GetTrafficFlowSegmentSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTrafficFlowSegmentResponder handles the response to the GetTrafficFlowSegment request. The method always
    // closes the http.Response Body.
    func (client TrafficClient) GetTrafficFlowSegmentResponder(resp *http.Response) (result TrafficFlowSegmentResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTrafficFlowTile __Traffic Flow Tile__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
// The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow. All tiles use the same grid system.
// Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound
// display. The Flow tiles use colors to indicate either the speed of traffic on different road segments, or the
// difference between that speed and the free-flow speed on the road segment in question.
    // Parameters:
        // formatParameter - desired format of the response. Possible values are png & pbf.
        // style - <p>The style to be used to render the tile.</p>
        // zoom - zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive).
        // For _vector_ tiles, value must be in the range: 0-22 (inclusive).
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // xTileIndex - x coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // yTileIndex - y coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // thickness - the value of the width of the line representing traffic. This value is a multiplier and the
        // accepted values range from 1 - 20. The default value is 10. This parameter is not valid when format is pbf.
func (client TrafficClient) GetTrafficFlowTile(ctx context.Context, formatParameter TileFormat, style TrafficFlowTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, thickness *int32) (result String, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TrafficClient.GetTrafficFlowTile")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: thickness,
         Constraints: []validation.Constraint{	{Target: "thickness", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "thickness", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil },
        	{Target: "thickness", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("maps.TrafficClient", "GetTrafficFlowTile", err.Error())
        }

        req, err := client.GetTrafficFlowTilePreparer(ctx, formatParameter, style, zoom, xTileIndex, yTileIndex, thickness)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficFlowTile", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTrafficFlowTileSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficFlowTile", resp, "Failure sending request")
        return
        }

        result, err = client.GetTrafficFlowTileResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficFlowTile", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTrafficFlowTilePreparer prepares the GetTrafficFlowTile request.
    func (client TrafficClient) GetTrafficFlowTilePreparer(ctx context.Context, formatParameter TileFormat, style TrafficFlowTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, thickness *int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "style": autorest.Encode("query",style),
    "x": autorest.Encode("query",xTileIndex),
    "y": autorest.Encode("query",yTileIndex),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if thickness != nil {
        queryParameters["thickness"] = autorest.Encode("query",*thickness)
            } else {
            queryParameters["thickness"] = autorest.Encode("query",10)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/traffic/flow/tile/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTrafficFlowTileSender sends the GetTrafficFlowTile request. The method will close the
    // http.Response Body if it receives an error.
    func (client TrafficClient) GetTrafficFlowTileSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTrafficFlowTileResponder handles the response to the GetTrafficFlowTile request. The method always
    // closes the http.Response Body.
    func (client TrafficClient) GetTrafficFlowTileResponder(resp *http.Response) (result String, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTrafficIncidentDetail __Traffic Incident Detail__
//
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
// This API provides information on traffic incidents inside a given bounding box, based on the current Traffic  Model
// ID. The Traffic Model ID is available to grant synchronization of data between calls and API's. The  Traffic Model
// ID is a key value for determining the currency of traffic incidents. It is updated every minute,  and is valid for
// two minutes before it times out. It is used in rendering  [incident
// tiles](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile). It can be  obtained from the
// [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport).
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // style - the style that will be used to render the tile in Traffic [Incident Tile
        // API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile).  This will have an
        // effect on the coordinates of traffic incidents in the reply.
        // boundingbox - the `boundingbox` is represented by two value pairs describing it's corners (first pair for
        // lower left corner and second for upper right). The pairs can either be specified using any of the
        // `projection`'s specified below (e.g., _minY,minX,maxY,maxX_) or by two latitude-longitude pairs (e.g.,
        // _minLat,minLon,maxLat,maxLon_).<br><br>NOTE: If latitude/longitude pairs are used, then the `projection`
        // parameter must be set to "EPSG4326".
        // boundingZoom - zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for vector tiles
        // trafficmodelid - number referencing traffic model. This can be obtained from the [Viewport
        // API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport). It is updated every
        // minute, and is valid for two minutes before it times out. If the wrong Traffic Model ID is specified, the
        // correct one will be returned by the interface. A value of -1 will always invoke the most recent traffic
        // model
        // language - [ISO 639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the output language.
        // Supported languages are ar, ca, cs, da, de, el, en, en-GB, en-US, es, et, fi, fr, he, hu, id, in*, it, lt,
        // lv, nb, nl, no, pl, pt, ro, ru, sk, sv, th, tr, zh.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details. When invalid language code is provided response is returned in English. When incident cause or
        // description does not have translation, English description is returned.
        // projection - the projection used to specify the coordinates in the request and response.
        // [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) (default) or
        // [EPSG4326](http://spatialreference.org/ref/epsg/4326/)
        // geometries - the type of vector geometry added to incidents (returned in the <v> element of the response).
        // expandCluster - boolean to indicate whether to list all traffic incidents in a cluster separately
        // originalPosition - boolean on whether to return the original position of the incident (<op>) as well as the
        // one shifted to the beginning of the traffic tube (<op>)
func (client TrafficClient) GetTrafficIncidentDetail(ctx context.Context, formatParameter TextFormat, style TrafficIncidentDetailStyle, boundingbox string, boundingZoom int32, trafficmodelid string, language string, projection string, geometries IncidentGeometryType, expandCluster *bool, originalPosition *bool) (result TrafficIncidentDetailResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TrafficClient.GetTrafficIncidentDetail")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: boundingZoom,
         Constraints: []validation.Constraint{	{Target: "boundingZoom", Name: validation.InclusiveMaximum, Rule: int64(22), Chain: nil },
        	{Target: "boundingZoom", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil }}}}); err != nil {
        return result, validation.NewError("maps.TrafficClient", "GetTrafficIncidentDetail", err.Error())
        }

        req, err := client.GetTrafficIncidentDetailPreparer(ctx, formatParameter, style, boundingbox, boundingZoom, trafficmodelid, language, projection, geometries, expandCluster, originalPosition)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentDetail", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTrafficIncidentDetailSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentDetail", resp, "Failure sending request")
        return
        }

        result, err = client.GetTrafficIncidentDetailResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentDetail", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTrafficIncidentDetailPreparer prepares the GetTrafficIncidentDetail request.
    func (client TrafficClient) GetTrafficIncidentDetailPreparer(ctx context.Context, formatParameter TextFormat, style TrafficIncidentDetailStyle, boundingbox string, boundingZoom int32, trafficmodelid string, language string, projection string, geometries IncidentGeometryType, expandCluster *bool, originalPosition *bool) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "boundingbox": autorest.Encode("query",boundingbox),
    "boundingZoom": autorest.Encode("query",boundingZoom),
    "style": autorest.Encode("query",style),
    "trafficmodelid": autorest.Encode("query",trafficmodelid),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(string(projection)) > 0 {
        queryParameters["projection"] = autorest.Encode("query",projection)
        }
        if len(string(geometries)) > 0 {
        queryParameters["geometries"] = autorest.Encode("query",geometries)
        }
        if expandCluster != nil {
        queryParameters["expandCluster"] = autorest.Encode("query",*expandCluster)
            } else {
            queryParameters["expandCluster"] = autorest.Encode("query",false)
        }
        if originalPosition != nil {
        queryParameters["originalPosition"] = autorest.Encode("query",*originalPosition)
            } else {
            queryParameters["originalPosition"] = autorest.Encode("query",false)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/traffic/incident/detail/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTrafficIncidentDetailSender sends the GetTrafficIncidentDetail request. The method will close the
    // http.Response Body if it receives an error.
    func (client TrafficClient) GetTrafficIncidentDetailSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTrafficIncidentDetailResponder handles the response to the GetTrafficIncidentDetail request. The method always
    // closes the http.Response Body.
    func (client TrafficClient) GetTrafficIncidentDetailResponder(resp *http.Response) (result TrafficIncidentDetailResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTrafficIncidentTile __Traffic Incident Tile__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
// This service serves 256 x 256 pixel tiles showing traffic incidents. All tiles use the same grid system. Because the
// traffic tiles use transparent images, they can be layered on top of map tiles to create a compound display. Traffic
// tiles render graphics to indicate traffic on the roads in the specified area.
    // Parameters:
        // formatParameter - desired format of the response. Possible values are png & pbf.
        // style - the style to be used to render the tile. This parameter is not valid when format is pbf.
        // zoom - zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive).
        // For _vector_ tiles, value must be in the range: 0-22 (inclusive).
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // xTileIndex - x coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // yTileIndex - y coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // trafficState - reference value for the state of traffic at a particular time, obtained from the Viewport API
        // call, trafficModelId attribute in trafficState field. It is updated every minute, and is valid for two
        // minutes before it times out. Use -1 to  get the most recent traffic information. Default: most recent
        // traffic information.
func (client TrafficClient) GetTrafficIncidentTile(ctx context.Context, formatParameter TileFormat, style TrafficIncidentTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, trafficState string) (result TrafficIncidentTileResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TrafficClient.GetTrafficIncidentTile")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTrafficIncidentTilePreparer(ctx, formatParameter, style, zoom, xTileIndex, yTileIndex, trafficState)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentTile", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTrafficIncidentTileSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentTile", resp, "Failure sending request")
        return
        }

        result, err = client.GetTrafficIncidentTileResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentTile", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTrafficIncidentTilePreparer prepares the GetTrafficIncidentTile request.
    func (client TrafficClient) GetTrafficIncidentTilePreparer(ctx context.Context, formatParameter TileFormat, style TrafficIncidentTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, trafficState string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "style": autorest.Encode("query",style),
    "x": autorest.Encode("query",xTileIndex),
    "y": autorest.Encode("query",yTileIndex),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(trafficState) > 0 {
        queryParameters["t"] = autorest.Encode("query",trafficState)
            } else {
            queryParameters["t"] = autorest.Encode("query","-1")
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/traffic/incident/tile/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTrafficIncidentTileSender sends the GetTrafficIncidentTile request. The method will close the
    // http.Response Body if it receives an error.
    func (client TrafficClient) GetTrafficIncidentTileSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTrafficIncidentTileResponder handles the response to the GetTrafficIncidentTile request. The method always
    // closes the http.Response Body.
    func (client TrafficClient) GetTrafficIncidentTileResponder(resp *http.Response) (result TrafficIncidentTileResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTrafficIncidentViewport __Traffic Incident Viewport__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
// This API returns legal and technical information for the viewport described in the request. It should be called  by
// client applications whenever the viewport changes (for instance, through zooming, panning, going to a  location, or
// displaying a route). The request should contain the bounding box and zoom level of the viewport  whose information
// is needed. The return will contain map version information, as well as the current Traffic  Model ID and copyright
// IDs. The Traffic Model ID returned by the Viewport Description is used by other APIs to  retrieve last traffic
// information for further processing.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // boundingbox - bounding box of the map viewport in
        // [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection. The `boundingbox` is
        // represented by two value pairs describing it's corners (first pair for lower left corner and second for
        // upper right). All values should be separated by commas (e.g., _minY,minX,maxY,maxX_). The maximum size of
        // the bounding box that can be passed is dependent on the requested zoom level. The width and height cannot
        // exceed 4092 pixels when rendered on the given zoom level.<br><br>NOTE: Bounding boxes that cross the 180°
        // meridian require special treatment. For such boxes, the eastern _maxX_ value will be negative, and thus less
        // than the _minX_ value west of the 180° meridian. To address that, the value 40075016.6855874 should be added
        // to the true _maxX_ value before it is passed in the request.
        // boundingzoom - zoom level of the map viewport. Used to determine whether the view can be zoomed in.
        // overviewbox - bounding box of the overview map in
        // [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection.<br><br>Used in case the
        // overview box/mini map has different copyright data than the main map. If there is no mini map, the same
        // coordinates as `boundingBox` is used.
        // overviewzoom - zoom level of the overview map. If there is no mini map, use the same zoom level as
        // boundingZoom.
        // copyright - determines what copyright information to return. When true the copyright text is returned; when
        // false only the copyright index is returned.
func (client TrafficClient) GetTrafficIncidentViewport(ctx context.Context, formatParameter TextFormat, boundingbox string, boundingzoom int32, overviewbox string, overviewzoom int32, copyright bool) (result TrafficIncidentViewportResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TrafficClient.GetTrafficIncidentViewport")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: boundingzoom,
         Constraints: []validation.Constraint{	{Target: "boundingzoom", Name: validation.InclusiveMaximum, Rule: int64(22), Chain: nil },
        	{Target: "boundingzoom", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil }}},
        { TargetValue: overviewzoom,
         Constraints: []validation.Constraint{	{Target: "overviewzoom", Name: validation.InclusiveMaximum, Rule: int64(22), Chain: nil },
        	{Target: "overviewzoom", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil }}}}); err != nil {
        return result, validation.NewError("maps.TrafficClient", "GetTrafficIncidentViewport", err.Error())
        }

        req, err := client.GetTrafficIncidentViewportPreparer(ctx, formatParameter, boundingbox, boundingzoom, overviewbox, overviewzoom, copyright)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentViewport", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTrafficIncidentViewportSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentViewport", resp, "Failure sending request")
        return
        }

        result, err = client.GetTrafficIncidentViewportResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TrafficClient", "GetTrafficIncidentViewport", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTrafficIncidentViewportPreparer prepares the GetTrafficIncidentViewport request.
    func (client TrafficClient) GetTrafficIncidentViewportPreparer(ctx context.Context, formatParameter TextFormat, boundingbox string, boundingzoom int32, overviewbox string, overviewzoom int32, copyright bool) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "boundingbox": autorest.Encode("query",boundingbox),
    "boundingzoom": autorest.Encode("query",boundingzoom),
    "copyright": autorest.Encode("query",copyright),
    "overviewbox": autorest.Encode("query",overviewbox),
    "overviewzoom": autorest.Encode("query",overviewzoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/traffic/incident/viewport/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTrafficIncidentViewportSender sends the GetTrafficIncidentViewport request. The method will close the
    // http.Response Body if it receives an error.
    func (client TrafficClient) GetTrafficIncidentViewportSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTrafficIncidentViewportResponder handles the response to the GetTrafficIncidentViewport request. The method always
    // closes the http.Response Body.
    func (client TrafficClient) GetTrafficIncidentViewportResponder(resp *http.Response) (result TrafficIncidentViewportResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

