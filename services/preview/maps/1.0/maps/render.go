package maps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// RenderClient is the client for the Render methods of the Maps service.
type RenderClient struct {
    BaseClient
}
// NewRenderClient creates an instance of the RenderClient client.
func NewRenderClient(subscriptionKey string, xMsClientID string) RenderClient {
    return NewRenderClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewRenderClientWithBaseURI creates an instance of the RenderClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewRenderClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) RenderClient {
        return RenderClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetCopyrightCaption **Applies to**: S0 and S1 pricing tiers.
//
//
//
// Copyrights API is designed to serve copyright information for Render Tile
// service. In addition to basic copyright for the whole map, API is serving
// specific groups of copyrights for some countries.
//
// As an alternative to copyrights for map request, one can receive captions
// for displaying the map provider information on the map.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
func (client RenderClient) GetCopyrightCaption(ctx context.Context, formatParameter TextFormat) (result CopyrightCaptionResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetCopyrightCaption")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetCopyrightCaptionPreparer(ctx, formatParameter)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightCaption", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetCopyrightCaptionSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightCaption", resp, "Failure sending request")
        return
        }

        result, err = client.GetCopyrightCaptionResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightCaption", resp, "Failure responding to request")
        return
        }

    return
}

    // GetCopyrightCaptionPreparer prepares the GetCopyrightCaption request.
    func (client RenderClient) GetCopyrightCaptionPreparer(ctx context.Context, formatParameter TextFormat) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/copyright/caption/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetCopyrightCaptionSender sends the GetCopyrightCaption request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetCopyrightCaptionSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetCopyrightCaptionResponder handles the response to the GetCopyrightCaption request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetCopyrightCaptionResponder(resp *http.Response) (result CopyrightCaptionResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetCopyrightForTile **Applies to**: S0 and S1 pricing tiers.
//
//
//
// Copyrights API is designed to serve copyright information for Render Tile  service. In addition to basic copyright
// for the whole map, API is serving  specific groups of copyrights for some countries.
// Returns the copyright information for a given tile. To obtain the copyright information for a particular tile, the
// request should specify the tile's zoom level and x and y coordinates (see: Zoom Levels and Tile Grid).
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // zoom - zoom level for the desired tile. Zoom value must be in the range: 0-18 (inclusive).
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // xTileIndex - x coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // yTileIndex - y coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // textParameter - yes/no value to exclude textual data from response. Only images and country names will be in
        // response.
func (client RenderClient) GetCopyrightForTile(ctx context.Context, formatParameter TextFormat, zoom int32, xTileIndex int32, yTileIndex int32, textParameter string) (result CopyrightTileResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetCopyrightForTile")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetCopyrightForTilePreparer(ctx, formatParameter, zoom, xTileIndex, yTileIndex, textParameter)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightForTile", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetCopyrightForTileSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightForTile", resp, "Failure sending request")
        return
        }

        result, err = client.GetCopyrightForTileResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightForTile", resp, "Failure responding to request")
        return
        }

    return
}

    // GetCopyrightForTilePreparer prepares the GetCopyrightForTile request.
    func (client RenderClient) GetCopyrightForTilePreparer(ctx context.Context, formatParameter TextFormat, zoom int32, xTileIndex int32, yTileIndex int32, textParameter string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "x": autorest.Encode("query",xTileIndex),
    "y": autorest.Encode("query",yTileIndex),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(textParameter)) > 0 {
        queryParameters["text"] = autorest.Encode("query",textParameter)
            } else {
            queryParameters["text"] = autorest.Encode("query","yes")
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/copyright/tile/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetCopyrightForTileSender sends the GetCopyrightForTile request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetCopyrightForTileSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetCopyrightForTileResponder handles the response to the GetCopyrightForTile request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetCopyrightForTileResponder(resp *http.Response) (result CopyrightTileResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetCopyrightForWorld **Applies to**: S0 and S1 pricing tiers.
//
//
// Copyrights API is designed to serve copyright information for Render Tile  service. In addition to basic copyright
// for the whole map, API is serving  specific groups of copyrights for some countries.
// Returns the copyright information for the world. To obtain the default copyright information for the whole world, do
// not specify a tile or bounding box.
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // textParameter - yes/no value to exclude textual data from response. Only images and country names will be in
        // response.
func (client RenderClient) GetCopyrightForWorld(ctx context.Context, formatParameter TextFormat, textParameter string) (result CopyrightWorldResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetCopyrightForWorld")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetCopyrightForWorldPreparer(ctx, formatParameter, textParameter)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightForWorld", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetCopyrightForWorldSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightForWorld", resp, "Failure sending request")
        return
        }

        result, err = client.GetCopyrightForWorldResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightForWorld", resp, "Failure responding to request")
        return
        }

    return
}

    // GetCopyrightForWorldPreparer prepares the GetCopyrightForWorld request.
    func (client RenderClient) GetCopyrightForWorldPreparer(ctx context.Context, formatParameter TextFormat, textParameter string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(textParameter)) > 0 {
        queryParameters["text"] = autorest.Encode("query",textParameter)
            } else {
            queryParameters["text"] = autorest.Encode("query","yes")
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/copyright/world/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetCopyrightForWorldSender sends the GetCopyrightForWorld request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetCopyrightForWorldSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetCopyrightForWorldResponder handles the response to the GetCopyrightForWorld request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetCopyrightForWorldResponder(resp *http.Response) (result CopyrightWorldResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetCopyrightFromBoundingBox **Applies to**: S0 and S1 pricing tiers.
//
//
// Returns copyright information for a given bounding box. Bounding-box requests should specify the minimum and maximum
// longitude and latitude (EPSG-3857) coordinates
    // Parameters:
        // formatParameter - desired format of the response. Value can be either _json_ or _xml_.
        // mincoordinates - minimum coordinates of bounding box in latitude longitude coordinate system. E.g.
        // 52.41064,4.84228
        // maxcoordinates - maximum coordinates of bounding box in latitude longitude coordinate system. E.g.
        // 52.41064,4.84228
        // textParameter - yes/no value to exclude textual data from response. Only images and country names will be in
        // response.
func (client RenderClient) GetCopyrightFromBoundingBox(ctx context.Context, formatParameter TextFormat, mincoordinates string, maxcoordinates string, textParameter string) (result CopyrightBoundingResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetCopyrightFromBoundingBox")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetCopyrightFromBoundingBoxPreparer(ctx, formatParameter, mincoordinates, maxcoordinates, textParameter)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightFromBoundingBox", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetCopyrightFromBoundingBoxSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightFromBoundingBox", resp, "Failure sending request")
        return
        }

        result, err = client.GetCopyrightFromBoundingBoxResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetCopyrightFromBoundingBox", resp, "Failure responding to request")
        return
        }

    return
}

    // GetCopyrightFromBoundingBoxPreparer prepares the GetCopyrightFromBoundingBox request.
    func (client RenderClient) GetCopyrightFromBoundingBoxPreparer(ctx context.Context, formatParameter TextFormat, mincoordinates string, maxcoordinates string, textParameter string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "maxcoordinates": autorest.Encode("query",maxcoordinates),
    "mincoordinates": autorest.Encode("query",mincoordinates),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(textParameter)) > 0 {
        queryParameters["text"] = autorest.Encode("query",textParameter)
            } else {
            queryParameters["text"] = autorest.Encode("query","yes")
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/copyright/bounding/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetCopyrightFromBoundingBoxSender sends the GetCopyrightFromBoundingBox request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetCopyrightFromBoundingBoxSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetCopyrightFromBoundingBoxResponder handles the response to the GetCopyrightFromBoundingBox request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetCopyrightFromBoundingBoxResponder(resp *http.Response) (result CopyrightBoundingResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetMapImage **Applies to**: S0 and S1 pricing tiers.
//
//
// The static image service renders a user-defined, rectangular image containing a map section using a zoom level from
// 0 to 20. The static image service renders a user-defined, rectangular image containing a map section using a zoom
// level from 0 to 20. The supported resolution range for the map image is from 1x1 to 8192x8192. If you are deciding
// when to use the static image service over the map tile service, you may want to consider how you would like to
// interact with the rendered map. If the map contents will be relatively unchanging, a static map is a good choice. If
// you want to support a lot of zooming, panning and changing of the map content, the map tile service would be a
// better choice.
//
// Service also provides Image Composition functionality to get a static image back with additional data like; pushpins
// and geometry overlays with following S0 and S1 capabilities.
//
// In S0 you can:
// - Render up to 5 pushpins specified in the request
// - Provide one custom image for the pins referenced in the request
// - Add labels to the pushpins
//
// In S1 you can:
// - Render pushpins through [Azure Maps Data Service](https://aka.ms/AzureMapsMapDataService)
// - Specify multiple pushpin styles
// - Provide custom pushpin images stored in [Azure Maps Data Service](https://aka.ms/AzureMapsMapDataService)
// - Render circle, polyline and polygon geometry types.
// - Render of supported GeoJSON geometry types uploaded through [Azure Maps Data
// Service](https://aka.ms/AzureMapsMapDataService)
//
// Please see [How-to-Guide](https://aka.ms/AzureMapsHowToGuideImageCompositor) for detailed examples.
//
// _Note_ : Either **center** or **bbox** parameter must be supplied to the
// API.
// <br><br>
// The supported Lat and Lon ranges when using the **bbox** parameter, are as follows:
// <br><br>
//
// |Zoom Level | Max Lon Range   | Max Lat Range|
// |:----------|:----------------|:-------------|
// |0          | 360.0           | 170.0        |
// |1          | 360.0           | 170.0        |
// |2          | 360.0           | 170.0        |
// |3          | 360.0           | 170.0        |
// |4          | 360.0           | 170.0        |
// |5          | 180.0           | 85.0         |
// |6          | 90.0            | 42.5         |
// |7          | 45.0            | 21.25        |
// |8          | 22.5            | 10.625       |
// |9          | 11.25           | 5.3125       |
// |10         | 5.625           | 2.62625      |
// |11         | 2.8125          | 1.328125     |
// |12         | 1.40625         | 0.6640625    |
// |13         | 0.703125        | 0.33203125   |
// |14         | 0.3515625       | 0.166015625  |
// |15         | 0.17578125      | 0.0830078125 |
// |16         | 0.087890625     | 0.0415039063 |
// |17         | 0.0439453125    | 0.0207519531 |
// |18         | 0.0219726563    | 0.0103759766 |
// |19         | 0.0109863281    | 0.0051879883 |
// |20         | 0.0054931641    | 0.0025939941 |
    // Parameters:
        // layer - map layer requested. If layer is set to labels or hybrid, the format should be png.
        // style - map style to be returned. Possible values are main and dark.
        // zoom - desired zoom level of the map. Zoom value must be in the range: 0-20 (inclusive). Default value is
        // 12.<br><br>Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // center - coordinates of the center point. Format: 'lon,lat'. Projection used
        // - EPSG:3857. Longitude range: -180 to 180. Latitude range: -85 to 85.
        //
        // Note: Either center or bbox are required parameters. They are
        // mutually exclusive.
        // bbox - bounding box. Projection used - EPSG:3857. Format : 'minLon, minLat,
        // maxLon, maxLat'.
        //
        // Note: Either bbox or center are required
        // parameters. They are mutually exclusive. It shouldn’t be used with
        // height or width.
        //
        // The maximum allowed ranges for Lat and Lon are defined for each zoom level
        // in the table at the top of this page.
        // height - height of the resulting image in pixels. Range is 1 to 8192. Default
        // is 512. It shouldn’t be used with bbox.
        // width - width of the resulting image in pixels. Range is 1 to 8192. Default is 512. It shouldn’t be used
        // with bbox.
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
        // pins - pushpin style and instances. Use this parameter to optionally add pushpins to the image.
        // The pushpin style describes the appearance of the pushpins, and the instances specify
        // the coordinates of the pushpins and optional labels for each pin. (Be sure to properly URL-encode values of
        // this
        // parameter since it will contain reserved characters such as pipes and punctuation.)
        //
        // The Azure Maps account S0 SKU only supports a single instance of the pins parameter. Other SKUs
        // allow multiple instances of the pins parameter to specify multiple pin styles.
        //
        // To render a pushpin at latitude 45°N and longitude 122°W using the default built-in pushpin style, add the
        // querystring parameter
        //
        // `pins=default||-122 45`
        //
        // Note that the longitude comes before the latitude.
        // After URL encoding this will look like
        //
        // `pins=default%7C%7C-122+45`
        //
        // All of the examples here show the pins
        // parameter without URL encoding, for clarity.
        //
        // To render a pin at multiple locations, separate each location with a pipe character. For example, use
        //
        // `pins=default||-122 45|-119.5 43.2|-121.67 47.12`
        //
        // The S0 Azure Maps account SKU only allows five pushpins. Other account SKUs do not have this limitation.
        //
        // ### Style Modifiers
        //
        // You can modify the appearance of the pins by adding style modifiers. These are added after the style but
        // before
        // the locations and labels. Style modifiers each have a two-letter name. These abbreviated names are used to
        // help
        // reduce the length of the URL.
        //
        // To change the color of the pushpin, use the 'co' style modifier and specify the color using the HTML/CSS RGB
        // color
        // format which is a six-digit hexadecimal number (the three-digit form is not supported). For example, to use
        // a deep pink color which you would specify as #FF1493 in CSS, use
        //
        // `pins=default|coFF1493||-122 45`
        //
        // ### Pushpin Labels
        //
        // To add a label to the pins, put the label in single quotes just before the coordinates. For example, to
        // label
        // three pins with the values '1', '2', and '3', use
        //
        // `pins=default||'1'-122 45|'2'-119.5 43.2|'3'-121.67 47.12`
        //
        // There is a built in pushpin style called 'none' that does not display a pushpin image. You can use this if
        // you want to display labels without any pin image. For example,
        //
        // `pins=none||'A'-122 45|'B'-119.5 43.2`
        //
        // To change the color of the pushpin labels, use the 'lc' label color style modifier. For example, to use pink
        // pushpins with black labels, use
        //
        // `pins=default|coFF1493|lc000000||-122 45`
        //
        // To change the size of the labels, use the 'ls' label size style modifier. The label size represents the
        // approximate
        // height of the label text in pixels. For example, to increase the label size to 12, use
        //
        // `pins=default|ls12||'A'-122 45|'B'-119 43`
        //
        // The labels are centered at the pushpin 'label anchor.' The anchor location is predefined for built-in
        // pushpins and
        // is at the top center of custom pushpins (see below). To override the label anchor, using the 'la' style
        // modifier
        // and provide X and Y pixel coordinates for the anchor. These coordinates are relative to the top left corner
        // of the
        // pushpin image. Positive X values move the anchor to the right, and positive Y values move the anchor down.
        // For example,
        // to position the label anchor 10 pixels right and 4 pixels above the top left corner of the pushpin image,
        // use
        //
        // `pins=default|la10 -4||'A'-122 45|'B'-119 43`
        //
        // ### Custom Pushpins
        //
        // To use a custom pushpin image, use the word 'custom' as the pin style name, and then specify a URL after the
        // location and label information. Use two pipe characters to indicate that you're done specifying locations
        // and are
        // starting the URL. For example,
        //
        // `pins=custom||-122 45||http://contoso.com/pushpins/red.png`
        //
        // After URL encoding, this would look like
        //
        // `pins=custom%7C%7C-122+45%7C%7Chttp%3A%2F%2Fcontoso.com%2Fpushpins%2Fred.png`
        //
        // By default, custom pushpin images are drawn centered at the pin coordinates. This usually isn't ideal as it
        // obscures
        // the location that you're trying to highlight. To override the anchor location of the pin image, use the 'an'
        // style modifier. This uses the same format as the 'la' label anchor style modifier. For example, if your
        // custom
        // pin image has the tip of the pin at the top left corner of the image, you can set the anchor to that spot by
        // using
        //
        // `pins=custom|an0 0||-122 45||http://contoso.com/pushpins/red.png`
        //
        // Note: If you use the 'co' color modifier with a custom pushpin image, the specified color will replace the
        // RGB
        // channels of the pixels in the image but will leave the alpha (opacity) channel unchanged. This would usually
        // only be done with a solid-color custom image.
        //
        // ### Getting Pushpins from Azure Maps Data Storage
        //
        // For all Azure Maps account SKUs other than S0,
        // the pushpin image and location information can be obtained from Azure Maps Data Storage. After uploading a
        // pushpin image
        // or a GeoJSON document containing pin locations, the Data Storage service returns a Unique Data ID (UDID)
        // that you can use
        // to reference the data in the pins parameter.
        //
        // To use a custom pushpin image from Azure Maps Data Storage, specify the UDID prefixed by 'udid-' as the name
        // of the
        // pushpin style. For example,
        //
        // `pins=udid-fe22c504-3a81-4fcd-adc6-a3507ce866c1||-122 45`
        //
        // To use the point geometry from an uploaded GeoJSON document as the pin locations, specify the UDID in the
        // locations
        // section of the pins parameter. For example,
        //
        // `pins=default||udid-29dc105a-dee7-409f-a3f9-22b066ae4713`
        //
        // Note that
        // only point and multipoint geometry, points and multipoints from geometry collections, and point geometry
        // from features
        // will be used. Linestring and polygon geometry will be ignored. If the point comes from a feature and the
        // feature
        // has a string property called "label", the value of that property will be used as the label for the pin.
        //
        // You can mix pin locations from Data Storage and pin locations specified in the pins parameter. Any of the
        // pipe-delimited
        // pin locations can be a longitude and latitude or a UDID. For example,
        //
        // `pins=default||-122 45|udid-29dc105a-dee7-409f-a3f9-22b066ae4713|-119 43`
        //
        // ### Scale, Rotation, and Opacity
        //
        // You can make pushpins and their labels larger or smaller by using the 'sc' scale style modifier. This is a
        // value greater than zero. A value of 1 is the standard scale. Values larger than 1 will make the pins larger,
        // and
        // values smaller than 1 will make them smaller. For example, to draw the pushpins 50% larger than normal, use
        //
        // `pins=default|sc1.5||-122 45`
        //
        // You can rotate pushpins and their labels by using the 'ro' rotation style modifier. This is a number of
        // degrees
        // of clockwise rotation. Use a negative number to rotate counter-clockwise. For example, to rotate the
        // pushpins
        // 90 degrees clockwise and double their size, use
        //
        // `pins=default|ro90|sc2||-122 45`
        //
        // You can make pushpins and their labels partially transparent by specifying the 'al' alpha style modifier.
        // This is a number between 0 and 1 indicating the opacity of the pushpins. Zero makes them completely
        // transparent
        // (and not visible) and 1 makes them completely opaque (which is the default). For example, to make pushpins
        // and their labels only 67% opaque, use
        //
        // `pins=default|al.67||-122 45`
        //
        // ### Style Modifier Summary
        //
        // Modifier  | Description     | Range
        // :--------:|-----------------|------------------
        // al        | Alpha (opacity) | 0 to 1
        // an        | Pin anchor      | *
        // co        | Pin color       | 000000 to FFFFFF
        // la        | Label anchor    | *
        // lc        | Label color     | 000000 to FFFFFF
        // ls        | Label size      | Greater than 0
        // ro        | Rotation        | -360 to 360
        // sc        | Scale           | Greater than 0
        //
        // * X and Y coordinates can be anywhere within pin image or a margin around it.
        // The margin size is the minimum of the pin width and height.
        // pathParameter - path style and locations. Use this parameter to optionally add lines, polygons or circles to
        // the image.
        // The path style describes the appearance of the line and fill. (Be sure to properly URL-encode values of this
        // parameter since it will contain reserved characters such as pipes and punctuation.)
        //
        // Path parameter is supported in Azure Maps account SKU starting with S1. Multiple instances of the path
        // parameter
        // allow to specify multiple geometries with their styles. Number of parameters per request is limited to 10
        // and
        // number of locations is limited to 100 per path.
        //
        // To render a circle with radius 100 meters and center point at latitude 45°N and longitude 122°W using the
        // default style, add the
        // querystring parameter
        //
        // `path=ra100||-122 45`
        //
        // Note that the longitude comes before the latitude.
        // After URL encoding this will look like
        //
        // `path=ra100%7C%7C-122+45`
        //
        // All of the examples here show the path parameter without URL encoding, for clarity.
        //
        // To render a line, separate each location with a pipe character. For example, use
        //
        // `path=||-122 45|-119.5 43.2|-121.67 47.12`
        //
        // To render a polygon, last location must be equal to the start location. For example, use
        //
        // `path=||-122 45|-119.5 43.2|-121.67 47.12|-122 45`
        //
        // Longitude and latitude values for locations of lines and polygons can be in the range from -360 to 360 to
        // allow for rendering of geometries crossing the anti-meridian.
        //
        // ### Style Modifiers
        //
        // You can modify the appearance of the path by adding style modifiers. These are added before the locations.
        // Style modifiers each have a two-letter name. These abbreviated names are used to help reduce the length
        // of the URL.
        //
        // To change the color of the outline, use the 'lc' style modifier and specify the color using the HTML/CSS RGB
        // color
        // format which is a six-digit hexadecimal number (the three-digit form is not supported). For example, to use
        // a deep pink color which you would specify as #FF1493 in CSS, use
        //
        // `path=lcFF1493||-122 45|-119.5 43.2`
        //
        // Multiple style modifiers may be combined together to create a more complex visual style.
        //
        // `lc0000FF|lw3|la0.60|fa0.50||-122.2 47.6|-122.2 47.7|-122.3 47.7|-122.3 47.6|-122.2 47.6`
        //
        // ### Getting Path locations from Azure Maps Data Storage
        //
        // For all Azure Maps account SKUs other than S0, the path location information can be obtained from Azure Maps
        // Data Storage.
        // After uploading a GeoJSON document containing path locations, the Data Storage service returns a Unique Data
        // ID (UDID) that you can use
        // to reference the data in the path parameter.
        //
        // To use the point geometry from an uploaded GeoJSON document as the path locations, specify the UDID in the
        // locations
        // section of the path parameter. For example,
        //
        // `path=||udid-29dc105a-dee7-409f-a3f9-22b066ae4713`
        //
        // Note the it is not allowed to mix path locations from Data Storage with locations specified in the path
        // parameter.
        //
        // ### Style Modifier Summary
        //
        // Modifier  | Description            | Range
        // :--------:|------------------------|------------------
        // lc        | Line color             | 000000 to FFFFFF
        // fc        | Fill color             | 000000 to FFFFFF
        // la        | Line alpha (opacity)   | 0 to 1
        // fa        | Fill alpha (opacity)   | 0 to 1
        // lw        | Line width             | Greater than 0
        // ra        | Circle radius (meters) | Greater than 0
func (client RenderClient) GetMapImage(ctx context.Context, layer StaticMapLayer, style MapImageStyle, zoom *int32, center string, bbox string, height *int32, width *int32, language string, view string, pins []string, pathParameter []string) (result ReadCloser, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetMapImage")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: zoom,
         Constraints: []validation.Constraint{	{Target: "zoom", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "zoom", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil },
        	{Target: "zoom", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil },
        }}}},
        { TargetValue: height,
         Constraints: []validation.Constraint{	{Target: "height", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "height", Name: validation.InclusiveMaximum, Rule: int64(8192), Chain: nil },
        	{Target: "height", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}},
        { TargetValue: width,
         Constraints: []validation.Constraint{	{Target: "width", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "width", Name: validation.InclusiveMaximum, Rule: int64(8192), Chain: nil },
        	{Target: "width", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("maps.RenderClient", "GetMapImage", err.Error())
        }

        req, err := client.GetMapImagePreparer(ctx, layer, style, zoom, center, bbox, height, width, language, view, pins, pathParameter)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapImage", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetMapImageSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapImage", resp, "Failure sending request")
        return
        }

        result, err = client.GetMapImageResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapImage", resp, "Failure responding to request")
        return
        }

    return
}

    // GetMapImagePreparer prepares the GetMapImage request.
    func (client RenderClient) GetMapImagePreparer(ctx context.Context, layer StaticMapLayer, style MapImageStyle, zoom *int32, center string, bbox string, height *int32, width *int32, language string, view string, pins []string, pathParameter []string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "png"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(layer)) > 0 {
        queryParameters["layer"] = autorest.Encode("query",layer)
            } else {
            queryParameters["layer"] = autorest.Encode("query","basic")
        }
        if len(string(style)) > 0 {
        queryParameters["style"] = autorest.Encode("query",style)
            } else {
            queryParameters["style"] = autorest.Encode("query","main")
        }
        if zoom != nil {
        queryParameters["zoom"] = autorest.Encode("query",*zoom)
            } else {
            queryParameters["zoom"] = autorest.Encode("query",12)
        }
        if len(center) > 0 {
        queryParameters["center"] = autorest.Encode("query",center)
        }
        if len(bbox) > 0 {
        queryParameters["bbox"] = autorest.Encode("query",bbox)
        }
        if height != nil {
        queryParameters["height"] = autorest.Encode("query",*height)
            } else {
            queryParameters["height"] = autorest.Encode("query",512)
        }
        if width != nil {
        queryParameters["width"] = autorest.Encode("query",*width)
            } else {
            queryParameters["width"] = autorest.Encode("query",512)
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }
        if pins != nil && len(pins) > 0 {
        queryParameters["pins"] = pins
        }
        if pathParameter != nil && len(pathParameter) > 0 {
        queryParameters["path"] = pathParameter
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/static/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetMapImageSender sends the GetMapImage request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetMapImageSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMapImageResponder handles the response to the GetMapImage request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetMapImageResponder(resp *http.Response) (result ReadCloser, err error) {
                result.Value = &resp.Body
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK))
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetMapImageryTile **Applies to:** S1 pricing tier.
//
//
// This service returns a map image tile with size 256x256, given the x and y coordinates and zoom
// level. Zoom level ranges from 1 to 19. The current available style value is 'satellite' which provides satellite
// imagery alone.
//
//
// **Note**: We recommend to start to use the new [Get Map Tile V2 API](https://aka.ms/GetMapTileV2).
    // Parameters:
        // zoom - zoom level for the desired tile. Zoom value must be in the range: 1-19 (inclusive).
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // xTileIndex - x coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // yTileIndex - y coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
func (client RenderClient) GetMapImageryTile(ctx context.Context, zoom int32, xTileIndex int32, yTileIndex int32) (result ReadCloser, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetMapImageryTile")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetMapImageryTilePreparer(ctx, zoom, xTileIndex, yTileIndex)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapImageryTile", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetMapImageryTileSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapImageryTile", resp, "Failure sending request")
        return
        }

        result, err = client.GetMapImageryTileResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapImageryTile", resp, "Failure responding to request")
        return
        }

    return
}

    // GetMapImageryTilePreparer prepares the GetMapImageryTile request.
    func (client RenderClient) GetMapImageryTilePreparer(ctx context.Context, zoom int32, xTileIndex int32, yTileIndex int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "png"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "style": autorest.Encode("query", "satellite"),
    "x": autorest.Encode("query",xTileIndex),
    "y": autorest.Encode("query",yTileIndex),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/imagery/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetMapImageryTileSender sends the GetMapImageryTile request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetMapImageryTileSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMapImageryTileResponder handles the response to the GetMapImageryTile request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetMapImageryTileResponder(resp *http.Response) (result ReadCloser, err error) {
                result.Value = &resp.Body
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK))
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetMapStateTilePreview **Applies to**: S0 and S1 pricing tiers.
//
//
// Fetches state tiles in vector format typically to be integrated into indoor maps module of map control or SDK. The
// map control will call this API after user turns on dynamic styling (see [Zoom Levels and Tile
// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid))
    // Parameters:
        // zoom - zoom level for the desired tile. Zoom value must be in the range: 0-20 (inclusive).
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // xTileIndex - x coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // yTileIndex - y coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // statesetID - the stateset id.
func (client RenderClient) GetMapStateTilePreview(ctx context.Context, zoom int32, xTileIndex int32, yTileIndex int32, statesetID string) (result ReadCloser, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetMapStateTilePreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetMapStateTilePreviewPreparer(ctx, zoom, xTileIndex, yTileIndex, statesetID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapStateTilePreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetMapStateTilePreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapStateTilePreview", resp, "Failure sending request")
        return
        }

        result, err = client.GetMapStateTilePreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapStateTilePreview", resp, "Failure responding to request")
        return
        }

    return
}

    // GetMapStateTilePreviewPreparer prepares the GetMapStateTilePreview request.
    func (client RenderClient) GetMapStateTilePreviewPreparer(ctx context.Context, zoom int32, xTileIndex int32, yTileIndex int32, statesetID string) (*http.Request, error) {
        const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "statesetId": autorest.Encode("query",statesetID),
    "x": autorest.Encode("query",xTileIndex),
    "y": autorest.Encode("query",yTileIndex),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPath("/map/statetile"),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetMapStateTilePreviewSender sends the GetMapStateTilePreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetMapStateTilePreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMapStateTilePreviewResponder handles the response to the GetMapStateTilePreview request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetMapStateTilePreviewResponder(resp *http.Response) (result ReadCloser, err error) {
                result.Value = &resp.Body
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK))
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetMapTile **Applies to**: S0 and S1 pricing tiers.
//
//
// Fetches map tiles in vector or raster format typically to be integrated into a new map control or SDK. By default,
// Azure uses vector map tiles for its web map control (see [Zoom Levels and Tile
// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid))
//
// **Note**: Weather tiles are only available via [Get Map Tile V2 API](https://aka.ms/AzureMapsWeatherTiles). We
// recommend to start to use the new [Get Map Tile V2 API](https://aka.ms/GetMapTileV2).
    // Parameters:
        // formatParameter - desired format of the response. Possible values are png & pbf.
        // layer - map layer requested. Possible values are basic, hybrid, labels and terra.
        // style - map style to be returned. Possible values are main, dark, and shaded_relief.
        // zoom - zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-18 (inclusive).
        // Terra raster tiles, values must be in the range 0-6 (inclusive). For _vector_ tiles, value must be in the
        // range: 0-22 (inclusive).
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // xTileIndex - x coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // yTileIndex - y coordinate of the tile on zoom grid. Value must be in the range [0, 2<sup>`zoom`</sup> -1].
        //
        // Please see [Zoom Levels and Tile
        // Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        // tileSize - the size of the returned map tile in pixels.
        // language - language in which search results should be returned. Should be one of supported IETF language
        // tags, case insensitive. When data in specified language is not available for a specific field, default
        // language is used.
        //
        // Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        // for details.
        // view - the View parameter specifies which set of geopolitically disputed content is returned via Azure Maps
        // services, including  borders and labels displayed on the map. The View parameter (also referred to as “user
        // region parameter”) will show the  correct maps for that country/region. By default, the View parameter is
        // set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the
        // location of your users, and then set the View parameter correctly  for that location. Alternatively, you
        // have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request.
        // The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding
        // mapping, of the country where maps, images and other data and third party content that you are authorized to
        // access via Azure Maps is made available. Example: view=IN.
        //
        // Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the
        // available Views.
func (client RenderClient) GetMapTile(ctx context.Context, formatParameter TileFormat, layer MapTileLayer, style MapTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, tileSize MapTileSize, language string, view string) (result ReadCloser, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/RenderClient.GetMapTile")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetMapTilePreparer(ctx, formatParameter, layer, style, zoom, xTileIndex, yTileIndex, tileSize, language, view)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapTile", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetMapTileSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapTile", resp, "Failure sending request")
        return
        }

        result, err = client.GetMapTileResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.RenderClient", "GetMapTile", resp, "Failure responding to request")
        return
        }

    return
}

    // GetMapTilePreparer prepares the GetMapTile request.
    func (client RenderClient) GetMapTilePreparer(ctx context.Context, formatParameter TileFormat, layer MapTileLayer, style MapTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, tileSize MapTileSize, language string, view string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path",formatParameter),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "layer": autorest.Encode("query",layer),
    "style": autorest.Encode("query",style),
    "x": autorest.Encode("query",xTileIndex),
    "y": autorest.Encode("query",yTileIndex),
    "zoom": autorest.Encode("query",zoom),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(tileSize)) > 0 {
        queryParameters["tileSize"] = autorest.Encode("query",tileSize)
            } else {
            queryParameters["tileSize"] = autorest.Encode("query","256")
        }
        if len(language) > 0 {
        queryParameters["language"] = autorest.Encode("query",language)
        }
        if len(view) > 0 {
        queryParameters["view"] = autorest.Encode("query",view)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/map/tile/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetMapTileSender sends the GetMapTile request. The method will close the
    // http.Response Body if it receives an error.
    func (client RenderClient) GetMapTileSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMapTileResponder handles the response to the GetMapTile request. The method always
    // closes the http.Response Body.
    func (client RenderClient) GetMapTileResponder(resp *http.Response) (result ReadCloser, err error) {
                result.Value = &resp.Body
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK))
            result.Response = autorest.Response{Response: resp}
            return
    }

