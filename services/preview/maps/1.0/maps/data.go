package maps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
)

// DataClient is the client for the Data methods of the Maps service.
type DataClient struct {
    BaseClient
}
// NewDataClient creates an instance of the DataClient client.
func NewDataClient(subscriptionKey string, xMsClientID string) DataClient {
    return NewDataClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewDataClientWithBaseURI creates an instance of the DataClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewDataClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) DataClient {
        return DataClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// DeletePreview **Data Delete API**
//
// **Applies to:** S1 pricing tier.
// <br>
//
// This API allows the caller to delete a previously uploaded data content.<br>
// You can use this API in a scenario like removing geofences previously uploaded using the [Data Upload
// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) for use in our [Azure Maps Geofencing
// Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
// uploaded content and create space for new content.
//
//
// ### Submit Delete Request
//
// To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
// delete.<br>
// For example, to delete a collection of geofences previously uploaded using the Upload API, set the `udid` parameter
// in the path to the `udid` of the data received previously in the upload API response.
//
//
// ### Delete Data Response
//
// The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was deleted
// successfully.<br>
// A HTTP `400 Bad Request` error response will be returned if the data resource with the passed-in `udid` is not
// found.
    // Parameters:
        // udid - the unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
func (client DataClient) DeletePreview(ctx context.Context, udid string) (result SetObject, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DataClient.DeletePreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.DeletePreviewPreparer(ctx, udid)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.DataClient", "DeletePreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.DeletePreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.DataClient", "DeletePreview", resp, "Failure sending request")
        return
        }

        result, err = client.DeletePreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.DataClient", "DeletePreview", resp, "Failure responding to request")
        return
        }

    return
}

    // DeletePreviewPreparer prepares the DeletePreview request.
    func (client DataClient) DeletePreviewPreparer(ctx context.Context, udid string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "udid": autorest.Encode("path",udid),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsDelete(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mapData/{udid}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeletePreviewSender sends the DeletePreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client DataClient) DeletePreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeletePreviewResponder handles the response to the DeletePreview request. The method always
    // closes the http.Response Body.
    func (client DataClient) DeletePreviewResponder(resp *http.Response) (result SetObject, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// DownloadPreview **Data Download API**
//
// **Applies to:** S1 pricing tier.
// <br>
//
// This API allows the caller to download a previously uploaded data content.<br>
// You can use this API in a scenario like downloading an existing collection of geofences uploaded previously using
// the [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) for use in our [Azure Maps
// Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
//
//
// ### Submit Download Request
//
// To download your content you will use a `GET` request where the path will contain the `udid` of the data to
// download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of the
// data response. <br>
// For example, to download a collection of geofences previously uploaded using the Upload API, set the `udid`
// parameter in the path to the `udid` of the data received previously in the upload API response and set the `Accept`
// header to either one of the following media types:
//
// - `application/json`
// - `application/vnd.geo+json`
// - `application/octet-stream`
//
//
// ### Download Data Response
//
// The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found, where
// the response body will contain the content of the data resource.<br>
// A HTTP `400 Bad Request` error response will be returned if the data resource with the passed-in `udid` is not
// found.<br>
//
// Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the Upload
// API:
// <br>
//
// ```json
// {
// "type": "FeatureCollection",
// "features": [{
// "type": "Feature",
// "geometry": {
// "type": "Point",
// "coordinates": [-122.126986, 47.639754]
// },
// "properties": {
// "geometryId": "001",
// "radius": 500
// }
// }]
// }
// ```
    // Parameters:
        // udid - the unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
func (client DataClient) DownloadPreview(ctx context.Context, udid string) (result SetObject, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DataClient.DownloadPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.DownloadPreviewPreparer(ctx, udid)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.DataClient", "DownloadPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.DownloadPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.DataClient", "DownloadPreview", resp, "Failure sending request")
        return
        }

        result, err = client.DownloadPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.DataClient", "DownloadPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // DownloadPreviewPreparer prepares the DownloadPreview request.
    func (client DataClient) DownloadPreviewPreparer(ctx context.Context, udid string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "udid": autorest.Encode("path",udid),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mapData/{udid}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DownloadPreviewSender sends the DownloadPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client DataClient) DownloadPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DownloadPreviewResponder handles the response to the DownloadPreview request. The method always
    // closes the http.Response Body.
    func (client DataClient) DownloadPreviewResponder(resp *http.Response) (result SetObject, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// ListPreview **Data List API**
//
// **Applies to:** S1 pricing tier.
// <br>
//
// This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview).
//
//
// ### Submit List Request
//
// To list all your map data content you will issue a `GET` request with no additional parameters.
//
//
// ### List Data Response
//
// The Data List API returns the complete list of all data in `json` format. The response contains the following
// details for each data resource:
//
// > udid - The unique data id for the data resource.
//
// > location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
//
//
// Here's a sample response returning the `udid` and `location` of 3 data resources:
//
// <br>
//
// ```json
// {
// "mapDataList":
// [
// {
// "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c",
// "location": "https://atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0",
// "sizeInBytes": 29920,
// "uploadStatus": "Completed"
// },
// {
// "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c",
// "location": "https://atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0",
// "sizeInBytes": 1339,
// "uploadStatus": "Completed"
// },
// {
// "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c",
// "location": "https://atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0",
// "sizeInBytes": 1650,
// "uploadStatus": "Pending"
// }]
// }
// ```
//
// <br>
func (client DataClient) ListPreview(ctx context.Context) (result DataListResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DataClient.ListPreview")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.ListPreviewPreparer(ctx)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.DataClient", "ListPreview", nil , "Failure preparing request")
    return
    }

        resp, err := client.ListPreviewSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.DataClient", "ListPreview", resp, "Failure sending request")
        return
        }

        result, err = client.ListPreviewResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.DataClient", "ListPreview", resp, "Failure responding to request")
        return
        }

    return
}

    // ListPreviewPreparer prepares the ListPreview request.
    func (client DataClient) ListPreviewPreparer(ctx context.Context) (*http.Request, error) {
        const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPath("/mapData"),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ListPreviewSender sends the ListPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client DataClient) ListPreviewSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ListPreviewResponder handles the response to the ListPreview request. The method always
    // closes the http.Response Body.
    func (client DataClient) ListPreviewResponder(resp *http.Response) (result DataListResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// UpdatePreview **Data Update API**
//
// **Applies to:** S1 pricing tier.
//
// The Data Update API allows the caller to update a previously uploaded data content.
//
// You can use this API in a scenario like adding or removing geofences to or from an existing collection of geofences.
// Geofences are uploaded using the [Data Upload API](https://docs.microsoft.com/rest/api/maps/data/uploadpreview), for
// use in the [Azure Maps Geofencing Service](https://docs.microsoft.com/rest/api/maps/spatial).
//
// Please note that the Update API will *replace* and *override* the existing data content.
//
// ## Submit Update Request
//
// To update your content you will use a `PUT` request. The request body will contain the new data that will replace
// the existing data. The `Content-Type` header will be set to the content type of the data, and the path will contain
// the `udid` of the data to be update.
//
// For example, to update a collection of geofences that were previously uploaded using the Upload API, place the new
// geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
// previously in the upload API response. And set the `Content-Type` header to one of the following media types:
//
// - `application/json`
// - `application/vnd.geo+json`
// - `application/octet-stream`
//
// Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a center
// point and a radius. The sample below is in `GeoJSON`:
//
// ```json
// {
// "type": "FeatureCollection",
// "features": [{
// "type": "Feature",
// "geometry": {
// "type": "Point",
// "coordinates": [-122.126986, 47.639754]
// },
// "properties": {
// "geometryId": "001",
// "radius": 500
// }
// }]
// }
// ```
//
// The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
//
// The Data Update API performs a
// [long-running request](https://docs.microsoft.com/azure/azure-maps/private-atlas-long-running-operation).
//
// ## Data Update Limits
//
// Please, be aware that currently every Azure Maps account has a [data storage
// limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
// Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
// You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data/deletepreview) to
// delete old/unused content and create space for new uploads.
    // Parameters:
        // udid - the unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
        // updateContent - the new content that will update/replace the previously uploaded content.
func (client DataClient) UpdatePreview(ctx context.Context, udid string, updateContent interface{}) (result DataUpdatePreviewFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DataClient.UpdatePreview")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.UpdatePreviewPreparer(ctx, udid, updateContent)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.DataClient", "UpdatePreview", nil , "Failure preparing request")
    return
    }

        result, err = client.UpdatePreviewSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.DataClient", "UpdatePreview", nil , "Failure sending request")
        return
        }

    return
}

    // UpdatePreviewPreparer prepares the UpdatePreview request.
    func (client DataClient) UpdatePreviewPreparer(ctx context.Context, udid string, updateContent interface{}) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "udid": autorest.Encode("path",udid),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPut(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/mapData/{udid}",pathParameters),
autorest.WithJSON(updateContent),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdatePreviewSender sends the UpdatePreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client DataClient) UpdatePreviewSender(req *http.Request) (future DataUpdatePreviewFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // UpdatePreviewResponder handles the response to the UpdatePreview request. The method always
    // closes the http.Response Body.
    func (client DataClient) UpdatePreviewResponder(resp *http.Response) (result LongRunningOperationResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusCreated,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// UploadPreview **Data Upload API**
//
// **Applies to:** S1 pricing tier.
//
// The Data Upload API allows the caller to upload data content to the Azure Maps service.
// You can use this API in a scenario like uploading a collection of Geofences in `GeoJSON`
// format, for use in our [Azure Maps Geofencing Service](https://docs.microsoft.com/rest/api/maps/spatial).
//
// ## Submit Upload Request
//
// To upload your content you will use a `POST` request. The request body will contain the data to upload. The
// `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter
// can contain the sharing level for the data. The `Content-Type` header will be set to the content type of the
// data.
//
// For example, to upload a collection of geofences  in `GeoJSON` format, set the request body to the geofence
// content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one
// of the following media types:
//
// - `application/json`
// - `application/vnd.geo+json`
// - `application/octet-stream`
//
// Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
// point and a radius. The sample below is in `GeoJSON`:
//
// ```json
// {
// "type": "FeatureCollection",
// "features": [{
// "type": "Feature",
// "geometry": {
// "type": "Point",
// "coordinates": [-122.126986, 47.639754]
// },
// "properties": {
// "geometryId": "001",
// "radius": 500
// }
// }]
// }
// ```
//
// The Data Upload API performs a
// [long-running request](https://docs.microsoft.com/azure/azure-maps/private-atlas-long-running-operation).
//
// ## Data Upload Limits
//
// Please, be aware that currently every Azure Maps account has a [data storage
// limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
// Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
// You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data/deletepreview) to
// delete old/unused content and create space for new uploads.
    // Parameters:
        // dataFormat - data format of the content being uploaded.
        // uploadContent - the content to upload.
func (client DataClient) UploadPreview(ctx context.Context, dataFormat UploadDataFormat, uploadContent interface{}) (result DataUploadPreviewFuture, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/DataClient.UploadPreview")
        defer func() {
            sc := -1
        if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
        sc = result.FutureAPI.Response().StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.UploadPreviewPreparer(ctx, dataFormat, uploadContent)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.DataClient", "UploadPreview", nil , "Failure preparing request")
    return
    }

        result, err = client.UploadPreviewSender(req)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.DataClient", "UploadPreview", nil , "Failure sending request")
        return
        }

    return
}

    // UploadPreviewPreparer prepares the UploadPreview request.
    func (client DataClient) UploadPreviewPreparer(ctx context.Context, dataFormat UploadDataFormat, uploadContent interface{}) (*http.Request, error) {
        const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "dataFormat": autorest.Encode("query",dataFormat),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPath("/mapData/upload"),
autorest.WithJSON(uploadContent),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UploadPreviewSender sends the UploadPreview request. The method will close the
    // http.Response Body if it receives an error.
    func (client DataClient) UploadPreviewSender(req *http.Request) (future DataUploadPreviewFuture, err error) {
            var resp *http.Response
            resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if err != nil {
            return
            }
            var azf azure.Future
            azf, err = azure.NewFutureFromResponse(resp)
            future.FutureAPI = &azf
            future.Result = future.result
            return
                }

    // UploadPreviewResponder handles the response to the UploadPreview request. The method always
    // closes the http.Response Body.
    func (client DataClient) UploadPreviewResponder(resp *http.Response) (result LongRunningOperationResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusCreated,http.StatusAccepted),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

