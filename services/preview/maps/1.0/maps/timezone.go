package maps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/date"
)

// TimezoneClient is the client for the Timezone methods of the Maps service.
type TimezoneClient struct {
    BaseClient
}
// NewTimezoneClient creates an instance of the TimezoneClient client.
func NewTimezoneClient(subscriptionKey string, xMsClientID string) TimezoneClient {
    return NewTimezoneClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewTimezoneClientWithBaseURI creates an instance of the TimezoneClient client using a custom endpoint.  Use this
// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewTimezoneClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) TimezoneClient {
        return TimezoneClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetTimezoneByCoordinates __Time Zone by Coordinates__
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// This API returns current, historical, and future time zone information for a specified latitude-longitude pair. In
// addition, the API provides sunset and sunrise times for a given location.
    // Parameters:
        // query - coordinates of the point for which time zone information is requested. The applicable query is
        // specified as a comma separated string composed by latitude followed by longitude e.g.
        // "47.641268,-122.125679".
        // acceptLanguage - specifies the language code in which the timezone names should be returned. If no language
        // code is provided, the response will be in "EN". Please refer to [Supported
        // Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        // options - alternatively, use alias "o". Options available for types of information returned in the result.
        // timeStamp - alternatively, use alias "stamp", or "s". Reference time, if omitted, the API will use the
        // machine time serving the request.
        // transitionsFrom - alternatively, use alias "tf". The start date from which daylight savings time (DST)
        // transitions are requested, only applies when "options" = all or "options" = transitions.
        // transitionsYears - alternatively, use alias "ty". The number of years from "transitionsFrom" for which DST
        // transitions are requested, only applies when "options" = all or "options" = transitions.
func (client TimezoneClient) GetTimezoneByCoordinates(ctx context.Context, query string, acceptLanguage string, options TimezoneOptions, timeStamp *date.Time, transitionsFrom *date.Time, transitionsYears *int32) (result TimezoneByCoordinatesResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TimezoneClient.GetTimezoneByCoordinates")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTimezoneByCoordinatesPreparer(ctx, query, acceptLanguage, options, timeStamp, transitionsFrom, transitionsYears)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneByCoordinates", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTimezoneByCoordinatesSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneByCoordinates", resp, "Failure sending request")
        return
        }

        result, err = client.GetTimezoneByCoordinatesResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneByCoordinates", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTimezoneByCoordinatesPreparer prepares the GetTimezoneByCoordinates request.
    func (client TimezoneClient) GetTimezoneByCoordinatesPreparer(ctx context.Context, query string, acceptLanguage string, options TimezoneOptions, timeStamp *date.Time, transitionsFrom *date.Time, transitionsYears *int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(options)) > 0 {
        queryParameters["options"] = autorest.Encode("query",options)
        }
        if timeStamp != nil {
        queryParameters["timeStamp"] = autorest.Encode("query",*timeStamp)
        }
        if transitionsFrom != nil {
        queryParameters["transitionsFrom"] = autorest.Encode("query",*transitionsFrom)
        }
        if transitionsYears != nil {
        queryParameters["transitionsYears"] = autorest.Encode("query",*transitionsYears)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/timezone/byCoordinates/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
        if len(acceptLanguage) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("Accept-Language",autorest.String(acceptLanguage)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTimezoneByCoordinatesSender sends the GetTimezoneByCoordinates request. The method will close the
    // http.Response Body if it receives an error.
    func (client TimezoneClient) GetTimezoneByCoordinatesSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTimezoneByCoordinatesResponder handles the response to the GetTimezoneByCoordinates request. The method always
    // closes the http.Response Body.
    func (client TimezoneClient) GetTimezoneByCoordinatesResponder(resp *http.Response) (result TimezoneByCoordinatesResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTimezoneByID __Time Zone by Id__
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// This API returns current, historical, and future time zone information for the specified IANA time zone ID.
    // Parameters:
        // query - the IANA time zone ID.
        // acceptLanguage - specifies the language code in which the timezone names should be returned. If no language
        // code is provided, the response will be in "EN". Please refer to [Supported
        // Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        // options - alternatively, use alias "o". Options available for types of information returned in the result.
        // timeStamp - alternatively, use alias "stamp", or "s". Reference time, if omitted, the API will use the
        // machine time serving the request.
        // transitionsFrom - alternatively, use alias "tf". The start date from which daylight savings time (DST)
        // transitions are requested, only applies when "options" = all or "options" = transitions.
        // transitionsYears - alternatively, use alias "ty". The number of years from "transitionsFrom" for which DST
        // transitions are requested, only applies when "options" = all or "options" = transitions.
func (client TimezoneClient) GetTimezoneByID(ctx context.Context, query string, acceptLanguage string, options TimezoneOptions, timeStamp *date.Time, transitionsFrom *date.Time, transitionsYears *int32) (result TimezoneByIDResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TimezoneClient.GetTimezoneByID")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTimezoneByIDPreparer(ctx, query, acceptLanguage, options, timeStamp, transitionsFrom, transitionsYears)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneByID", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTimezoneByIDSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneByID", resp, "Failure sending request")
        return
        }

        result, err = client.GetTimezoneByIDResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneByID", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTimezoneByIDPreparer prepares the GetTimezoneByID request.
    func (client TimezoneClient) GetTimezoneByIDPreparer(ctx context.Context, query string, acceptLanguage string, options TimezoneOptions, timeStamp *date.Time, transitionsFrom *date.Time, transitionsYears *int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(string(options)) > 0 {
        queryParameters["options"] = autorest.Encode("query",options)
        }
        if timeStamp != nil {
        queryParameters["timeStamp"] = autorest.Encode("query",*timeStamp)
        }
        if transitionsFrom != nil {
        queryParameters["transitionsFrom"] = autorest.Encode("query",*transitionsFrom)
        }
        if transitionsYears != nil {
        queryParameters["transitionsYears"] = autorest.Encode("query",*transitionsYears)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/timezone/byId/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
        if len(acceptLanguage) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("Accept-Language",autorest.String(acceptLanguage)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTimezoneByIDSender sends the GetTimezoneByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client TimezoneClient) GetTimezoneByIDSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTimezoneByIDResponder handles the response to the GetTimezoneByID request. The method always
    // closes the http.Response Body.
    func (client TimezoneClient) GetTimezoneByIDResponder(resp *http.Response) (result TimezoneByIDResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTimezoneEnumIANA __Enumerate IANA Time Zones__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// This API returns a full list of IANA time zone IDs. Updates to the IANA service will be reflected in the system
// within one day.
func (client TimezoneClient) GetTimezoneEnumIANA(ctx context.Context) (result ListIanaID, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TimezoneClient.GetTimezoneEnumIANA")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTimezoneEnumIANAPreparer(ctx)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneEnumIANA", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTimezoneEnumIANASender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneEnumIANA", resp, "Failure sending request")
        return
        }

        result, err = client.GetTimezoneEnumIANAResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneEnumIANA", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTimezoneEnumIANAPreparer prepares the GetTimezoneEnumIANA request.
    func (client TimezoneClient) GetTimezoneEnumIANAPreparer(ctx context.Context) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/timezone/enumIana/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTimezoneEnumIANASender sends the GetTimezoneEnumIANA request. The method will close the
    // http.Response Body if it receives an error.
    func (client TimezoneClient) GetTimezoneEnumIANASender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTimezoneEnumIANAResponder handles the response to the GetTimezoneEnumIANA request. The method always
    // closes the http.Response Body.
    func (client TimezoneClient) GetTimezoneEnumIANAResponder(resp *http.Response) (result ListIanaID, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTimezoneEnumWindows __Enumerate Windows Time Zones__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// This API returns a full list of Windows Time Zone IDs.
func (client TimezoneClient) GetTimezoneEnumWindows(ctx context.Context) (result ListTimezoneEnumWindow, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TimezoneClient.GetTimezoneEnumWindows")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTimezoneEnumWindowsPreparer(ctx)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneEnumWindows", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTimezoneEnumWindowsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneEnumWindows", resp, "Failure sending request")
        return
        }

        result, err = client.GetTimezoneEnumWindowsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneEnumWindows", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTimezoneEnumWindowsPreparer prepares the GetTimezoneEnumWindows request.
    func (client TimezoneClient) GetTimezoneEnumWindowsPreparer(ctx context.Context) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/timezone/enumWindows/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTimezoneEnumWindowsSender sends the GetTimezoneEnumWindows request. The method will close the
    // http.Response Body if it receives an error.
    func (client TimezoneClient) GetTimezoneEnumWindowsSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTimezoneEnumWindowsResponder handles the response to the GetTimezoneEnumWindows request. The method always
    // closes the http.Response Body.
    func (client TimezoneClient) GetTimezoneEnumWindowsResponder(resp *http.Response) (result ListTimezoneEnumWindow, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTimezoneIANAVersion __Time Zone IANA Version__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// This API returns the current IANA version number.
func (client TimezoneClient) GetTimezoneIANAVersion(ctx context.Context) (result TimezoneIanaVersionResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TimezoneClient.GetTimezoneIANAVersion")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTimezoneIANAVersionPreparer(ctx)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneIANAVersion", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTimezoneIANAVersionSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneIANAVersion", resp, "Failure sending request")
        return
        }

        result, err = client.GetTimezoneIANAVersionResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneIANAVersion", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTimezoneIANAVersionPreparer prepares the GetTimezoneIANAVersion request.
    func (client TimezoneClient) GetTimezoneIANAVersionPreparer(ctx context.Context) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/timezone/ianaVersion/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTimezoneIANAVersionSender sends the GetTimezoneIANAVersion request. The method will close the
    // http.Response Body if it receives an error.
    func (client TimezoneClient) GetTimezoneIANAVersionSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTimezoneIANAVersionResponder handles the response to the GetTimezoneIANAVersion request. The method always
    // closes the http.Response Body.
    func (client TimezoneClient) GetTimezoneIANAVersionResponder(resp *http.Response) (result TimezoneIanaVersionResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetTimezoneWindowsToIANA __Windows to IANA Time Zone__
//
//
// **Applies to**: S0 and S1 pricing tiers.
//
//
// This API returns a corresponding IANA ID, given a valid Windows Time Zone ID. Multiple IANA IDs may be returned for
// a single Windows ID. It is possible to narrow these results by adding an optional territory parameter.
    // Parameters:
        // query - the Windows time zone ID.
        // territory - windows Time Zone territory code.
func (client TimezoneClient) GetTimezoneWindowsToIANA(ctx context.Context, query string, territory string) (result ListIanaID, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/TimezoneClient.GetTimezoneWindowsToIANA")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetTimezoneWindowsToIANAPreparer(ctx, query, territory)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneWindowsToIANA", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetTimezoneWindowsToIANASender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneWindowsToIANA", resp, "Failure sending request")
        return
        }

        result, err = client.GetTimezoneWindowsToIANAResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.TimezoneClient", "GetTimezoneWindowsToIANA", resp, "Failure responding to request")
        return
        }

    return
}

    // GetTimezoneWindowsToIANAPreparer prepares the GetTimezoneWindowsToIANA request.
    func (client TimezoneClient) GetTimezoneWindowsToIANAPreparer(ctx context.Context, query string, territory string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if len(territory) > 0 {
        queryParameters["territory"] = autorest.Encode("query",territory)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/timezone/windowsToIana/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTimezoneWindowsToIANASender sends the GetTimezoneWindowsToIANA request. The method will close the
    // http.Response Body if it receives an error.
    func (client TimezoneClient) GetTimezoneWindowsToIANASender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTimezoneWindowsToIANAResponder handles the response to the GetTimezoneWindowsToIANA request. The method always
    // closes the http.Response Body.
    func (client TimezoneClient) GetTimezoneWindowsToIANAResponder(resp *http.Response) (result ListIanaID, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

