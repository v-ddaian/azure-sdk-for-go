package maps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "encoding/json"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/date"
    "io"
    "net/http"
)

// The package's fully qualified name.
const fqdn = "$(go-sdk-folder)/services/preview/maps/1.0/maps"

            // Agency details of the agency. Returned if specified in the request.
            type Agency struct {
            // AgencyID - The Id of the relevant transit agency, for example, '5872'
            AgencyID *string `json:"agencyId,omitempty"`
            // AgencyKey - The agency’s GTFS Id.
            AgencyKey *string `json:"agencyKey,omitempty"`
            // AgencyName - Name of the relevant transit agency, e.g. Metro Transit.
            AgencyName *string `json:"agencyName,omitempty"`
            // TransitType - Supported public transit type. One of Tram, Subway, Rail, Bus, Ferry, CableCar, Gondola, Funicular.
            TransitType *TransitTypeResult `json:"transitType,omitempty"`
            }

            // AirAndPollen ...
            type AirAndPollen struct {
            // Name - Name of the pollen or pollutant. For example, grass, mold, weed, air quality, tree and UV index.
            Name *string `json:"name,omitempty"`
            // Value - Value of the given type above. Values associated with mold, grass, weed and tree are in units of parts per cubic meter. Both air quality and UV are indices, so they are unitless.
            Value *int32 `json:"value,omitempty"`
            // Category - Category of the air quality or pollution type. For example, low, high, good, moderate, unhealthy, hazardous.
            Category *string `json:"category,omitempty"`
            // CategoryValue - Value associated with the air quality or pollution category. These values range from 1 to 6. 1 implying good conditions, 6 implying hazardous conditions.
            CategoryValue *int32 `json:"categoryValue,omitempty"`
            // Type - Only exists for air quality. Examples include ozone and particle pollution.
            Type *string `json:"type,omitempty"`
            }

            // AirQuality information about the air quality in a specific location at a specific time.
            type AirQuality struct {
            // DateTime - Date and time of the current observation displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            DateTime *string `json:"dateTime,omitempty"`
            // Index - Air quality rating on a scale set by local regulating bodies. Scales can vary widely based on location. See [Wikipedia](https://en.wikipedia.org/wiki/Air_quality_index) for more information.
            Index *float64 `json:"index,omitempty"`
            // GlobalIndex - Internationally normalized air quality rating on a scale from 0 to 300 and up, with higher numbers representing worse air quality.
            GlobalIndex *float64 `json:"globalIndex,omitempty"`
            // DominantPollutant - The pollutant with the highest concentration.
            DominantPollutant *string `json:"dominantPollutant,omitempty"`
            // Category - One-word description of the air quality in the requested language. For example, "Excellent".
            Category *string `json:"category,omitempty"`
            // CategoryColor - A unique color corresponding to the category of this air quality result.
            CategoryColor *string `json:"categoryColor,omitempty"`
            // Description - A textual explanation of this air quality result in the requested language.
            Description *string `json:"description,omitempty"`
            // Pollutants - Information about individual pollutants.
            Pollutants *[]Pollutant `json:"pollutants,omitempty"`
            }

            // Alert basic information associated with the active alert. Returned if specified in the request and there
            // is an active alert in the metro area.
            type Alert struct {
            // AlertSummary - Text summarizing the alert.
            AlertSummary *string `json:"alertSummary,omitempty"`
            // PublicationDate - The date and time in ISO 8601 format, e.g. 2019-04-05T14:24:18-04:00.
            PublicationDate *date.Time `json:"publicationDate,omitempty"`
            // Category - The category of the alert. One of None, Regular, Info, Modified, Critical.
            Category *string `json:"category,omitempty"`
            // AlertLevel - The level at which the respective alert extents to. One of Metro, Agency, Line, Stop.
            AlertLevel *string `json:"alertLevel,omitempty"`
            Details *AlertDetail `json:"details,omitempty"`
            }

            // AlertArea information about a severe weather alert issued within an affected area(s). If multiple alerts
            // are active for the same location, the alerts will be returned in order of `priority` within the API
            // response, with the highest priority alert being returned at the top of the response.
            type AlertArea struct {
            // Name - The name of an area which is affected by the alert. The location that was requested falls under the alert area.
            Name *string `json:"name,omitempty"`
            // Summary - Text summarizing the alert in the returned area.
            Summary *string `json:"summary,omitempty"`
            // StartTime - The start date and time of the alert in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00. If the alert crosses multiple time zones the returned time in the response is the local time to the requested coordinate location.
            StartTime *string `json:"startTime,omitempty"`
            // EndTime - The end date and time of the alert in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00. If the alert crosses multiple time zones the returned time in the response is the local time to the requested coordinate location.
            EndTime *string `json:"endTime,omitempty"`
            // LatestStatus - The latest status of the alert in the current area.
            LatestStatus *LatestStatus `json:"latestStatus,omitempty"`
            // AlertDetails - Full details associated with the alert. Returned if `details`=True. This field is always returned in the language(s) of choice by the issuing provider and Azure Maps only returns what is created by the provider. Please note, some countries/regions may offer their native language and English. Language parameter won’t apply to this field.
            AlertDetails *string `json:"alertDetails,omitempty"`
            // AlertDetailsLanguageCode - Language of the `alertDetails`. This field  helps to point out that the language of the `alertDetails` may differ from the requested language parameter. Returned if `details`=True. Language code has been derived from the ISO 639-1 Alpha-2 codes.
            AlertDetailsLanguageCode *string `json:"alertDetailsLanguageCode,omitempty"`
            }

            // AlertDescription ...
            type AlertDescription struct {
            // Data - Description of the alert.
            Data *string `json:"data,omitempty"`
            // Format - Format of the alert description.
            Format *string `json:"format,omitempty"`
            // SourceURL - Source URL.
            SourceURL *string `json:"sourceUrl,omitempty"`
            }

            // AlertDetail a list of alert details.
            type AlertDetail struct {
            // AgencyID - The Id of the relevant transit agency, for example, '5872'.
            AgencyID *string `json:"agencyId,omitempty"`
            // AgencyName - Name of the relevant transit agency, e.g. Metro Transit.
            AgencyName *string `json:"agencyName,omitempty"`
            // Title - The title of the alert.
            Title *string `json:"title,omitempty"`
            // Description - A short description of the alert.
            Description *AlertDescription `json:"description,omitempty"`
            // ActiveFrom - The start time of the alert in the local time in ISO format (2019-04-05T14:24:18-04:00).
            ActiveFrom *date.Time `json:"activeFrom,omitempty"`
            // ActiveTo - The estimated end time of the alert in the local time in ISO format (2019-04-05T14:24:18-04:00).
            ActiveTo *date.Time `json:"activeTo,omitempty"`
            // Effect - Service Alert effect - one of SA_NO_SERVICE, SA_REDUCED_SERVICE, SA_SIGNIFICANT_DELAYS, SA_DETOUR, SA_ADDITIONAL_SERVICE, SA_MODIFIED_SERVICE, SA_OTHER_EFFECT, SA_STOP_MOVED, SA_GOOD_SERVICE, SA_SLEEPING, SA_OTHER_EFFECT
            Effect *string `json:"effect,omitempty"`
            }

            // AliasCreateResponse the response model for the Alias Create API for the case when the alias was
            // successfully created.
            type AliasCreateResponse struct {
            autorest.Response `json:"-"`
            // AliasID - READ-ONLY; An alias id `aliasId` for the created alias.
            AliasID *string `json:"aliasId,omitempty"`
            }

            // AliasListItem detailed information for the alias.
            type AliasListItem struct {
            // CreatedTimestamp - READ-ONLY; The created timestamp for the alias.
            CreatedTimestamp *string `json:"createdTimestamp,omitempty"`
            // AliasID - READ-ONLY; The id for the alias.
            AliasID *string `json:"aliasId,omitempty"`
            // ResourceID - READ-ONLY; The id for the resource that this alias references (could be null if the alias has not been assigned).
            ResourceID *string `json:"resourceId,omitempty"`
            // LastUpdatedTimestamp - READ-ONLY; The timestamp of the last time the alias was assigned.
            LastUpdatedTimestamp *string `json:"lastUpdatedTimestamp,omitempty"`
            }

            // AliasListResponse the response model for the List API. Returns a list of all the previously created
            // aliases.
            type AliasListResponse struct {
            autorest.Response `json:"-"`
            // Aliases - READ-ONLY; A list of all the previously created aliases.
            Aliases *[]AliasListItem `json:"aliases,omitempty"`
            }

            // BatchRequestBody this type represents the request body for the Batch service.
            type BatchRequestBody struct {
            // BatchItems - The list of queries/requests to process
            BatchItems *[]BatchRequestBodyBatchItemsItem `json:"batchItems,omitempty"`
            }

            // BatchRequestBodyBatchItemsItem batch Query object
            type BatchRequestBodyBatchItemsItem struct {
            // Query - Partial query string
            Query *string `json:"query,omitempty"`
            }

            // BatchResponse this object is returned from a successful Batch service call
            type BatchResponse struct {
            autorest.Response `json:"-"`
            // Summary - READ-ONLY; Summary for the batch request
            Summary *BatchResponseSummary `json:"summary,omitempty"`
            // BatchItems - READ-ONLY; Array containing the batch results
            BatchItems *[]interface{} `json:"batchItems,omitempty"`
            }

            // BatchResponseSummary summary for the batch request
            type BatchResponseSummary struct {
            // SuccessfulRequests - READ-ONLY; Number of successful requests in the batch
            SuccessfulRequests *int32 `json:"successfulRequests,omitempty"`
            // TotalRequests - READ-ONLY; Total number of requests in the batch
            TotalRequests *int32 `json:"totalRequests,omitempty"`
            }

            // BooleanRuleObject the boolean rule
            type BooleanRuleObject struct {
            // True - The color when value is true.
            True *string `json:"true,omitempty"`
            // False - The color when value is false.
            False *string `json:"false,omitempty"`
            }

            // BooleanTypeStyleRule the boolean type style rule object.
            type BooleanTypeStyleRule struct {
            // Rules - Boolean style rules.
            Rules *[]BooleanRuleObject `json:"rules,omitempty"`
            // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
            KeyName *string `json:"keyName,omitempty"`
            // Type - Possible values include: 'TypeStyleRuleBase', 'TypeBooleanTypeStyleRule', 'TypeNumberTypeStyleRule', 'TypeStringTypeStyleRule'
            Type TypeBasicStyleRuleBase `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for BooleanTypeStyleRule.
        func (btsr BooleanTypeStyleRule)MarshalJSON() ([]byte, error){
            btsr.Type = TypeBooleanTypeStyleRule
            objectMap := make(map[string]interface{})
                if(btsr.Rules != nil) {
                objectMap["rules"] = btsr.Rules
                }
                if(btsr.KeyName != nil) {
                objectMap["keyName"] = btsr.KeyName
                }
                if(btsr.Type != "") {
                objectMap["type"] = btsr.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleRuleBase implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return &btsr, true
            }

            // AsNumberTypeStyleRule is the BasicStyleRuleBase implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return nil, false
            }

            // AsStringTypeStyleRule is the BasicStyleRuleBase implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return nil, false
            }

            // AsStyleRuleBase is the BasicStyleRuleBase implementation for BooleanTypeStyleRule.
            func (btsr BooleanTypeStyleRule) AsStyleRuleBase() (*StyleRuleBase, bool) {
                return nil, false
            }

                // AsBasicStyleRuleBase is the BasicStyleRuleBase implementation for BooleanTypeStyleRule.
                func(btsr BooleanTypeStyleRule) AsBasicStyleRuleBase()(BasicStyleRuleBase, bool) {
                    return &btsr, true
                }


            // BoundingBoxResponse this object is returned from a successful Spatial BoundingBox call.
            type BoundingBoxResponse struct {
            // Summary - READ-ONLY; Summary of the call.
            Summary *BoundingBoxResponseSummary `json:"summary,omitempty"`
            // Result - READ-ONLY; The bounding box of the input feature collection.
            Result *BoundingBoxResponseResult `json:"result,omitempty"`
            }

            // BoundingBoxResponseResult the bounding box of the input feature collection.
            type BoundingBoxResponseResult struct {
            // Feature - READ-ONLY; The resulting feature with bounding box geometry
            Feature interface{} `json:"feature,omitempty"`
            }

            // BoundingBoxResponseSummary summary of the call.
            type BoundingBoxResponseSummary struct {
            // Udid - READ-ONLY; The udid for the user data if one exists
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; The information about what happened during the call.
            Information *string `json:"information,omitempty"`
            }

            // BoundingBoxResult the response from a successful Get Data for Bounding Box API.
            type BoundingBoxResult struct {
            autorest.Response `json:"-"`
            Data *[]PointElevationResult `json:"data,omitempty"`
            }

            // BufferRequestBody an object with a FeatureCollection and a list of distances.  All the feature's
            // properties should contain `geometryId`, which is used for identifying the geometry and is
            // case-sensitive.
            type BufferRequestBody struct {
            Geometries *GeoJSONFeatureCollection `json:"geometries,omitempty"`
            // Distances - List of the distances to compute the buffer for, one-to-one per Feature in the collection, or one for all Features in the collection.
            Distances *[]float64 `json:"distances,omitempty"`
            }

            // BufferResponse this object is returned from a successful Spatial Buffer call.
            type BufferResponse struct {
            autorest.Response `json:"-"`
            // Summary - READ-ONLY; Summary of the call.
            Summary *BufferResponseSummary `json:"summary,omitempty"`
            // Result - The FeatureCollection of buffers for the input.
            Result *GeoJSONFeatureCollection `json:"result,omitempty"`
            }

        // MarshalJSON is the custom marshaler for BufferResponse.
        func (br BufferResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(br.Result != nil) {
                objectMap["result"] = br.Result
                }
                return json.Marshal(objectMap)
        }

            // BufferResponseSummary summary of the call.
            type BufferResponseSummary struct {
            // Udid - READ-ONLY; The udid for the user data if one exists
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; The information about what happened during the call.
            Information *string `json:"information,omitempty"`
            }

            // ClosestPointResultEntry closest Point Result Entry Object
            type ClosestPointResultEntry struct {
            // DistanceInMeters - READ-ONLY; The distance in meters from the source point to the closest point
            DistanceInMeters *float64 `json:"distanceInMeters,omitempty"`
            Position *SpatialCoordinate `json:"position,omitempty"`
            // GeometryID - READ-ONLY; The unique id identifies a geometry
            GeometryID *string `json:"geometryId,omitempty"`
            }

        // MarshalJSON is the custom marshaler for ClosestPointResultEntry.
        func (cpre ClosestPointResultEntry)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(cpre.Position != nil) {
                objectMap["position"] = cpre.Position
                }
                return json.Marshal(objectMap)
        }

            // CollectionDefinition collection of GeoJSON features
            type CollectionDefinition struct {
            autorest.Response `json:"-"`
            // Description - describes the collection
            Description *string `json:"description,omitempty"`
            // IDPrefix - prefix of the collection used
            IDPrefix *string `json:"idPrefix,omitempty"`
            // Name - identifier of the collection used, for example, in URIs
            Name *string `json:"name,omitempty"`
            // Title - title of collection
            Title *string `json:"title,omitempty"`
            // GeometryType - type of geometry returned. Possible values include: 'GeometryTypePoint', 'GeometryTypeMultiPoint', 'GeometryTypeLineString', 'GeometryTypeMultiLineString', 'GeometryTypePolygon', 'GeometryTypeMultiPolygon', 'GeometryTypeGeometryCollection'
            GeometryType GeometryType `json:"geometryType,omitempty"`
            // FeatureTypes - type of features returned
            FeatureTypes *[]string `json:"featureTypes,omitempty"`
            // Properties - attributes of the collection used
            Properties *[]DefinitionProperties `json:"properties,omitempty"`
            Links *[]Link `json:"links,omitempty"`
            }

            // CollectionInfo ...
            type CollectionInfo struct {
            autorest.Response `json:"-"`
            // Name - identifier of the collection used, for example, in URIs
            Name *string `json:"name,omitempty"`
            // Title - human readable title of the collection
            Title *string `json:"title,omitempty"`
            // Description - a description of the features in the collection
            Description *string `json:"description,omitempty"`
            Links *[]Link `json:"links,omitempty"`
            }

            // Color ...
            type Color struct {
            // Red - Red component of the RGB value.
            Red *int32 `json:"red,omitempty"`
            // Green - Green component of the RGB value.
            Green *int32 `json:"green,omitempty"`
            // Blue - Blue component of the RGB value
            Blue *int32 `json:"blue,omitempty"`
            // Hex - Hexadecimal color value.
            Hex *string `json:"hex,omitempty"`
            }

            // Concentration an object containing the number of pollutant particles per volume of air.
            type Concentration struct {
            // Value - The numerical value indicating the concentration of the corresponding pollutant.
            Value *float64 `json:"value,omitempty"`
            // Unit - Type of unit for the concentration of the pollutant.
            Unit *string `json:"unit,omitempty"`
            // UnitType - Numeric ID value associated with the type of unit being displayed. Can be used for unit translation. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            UnitType *int32 `json:"unitType,omitempty"`
            }

            // Content ...
            type Content struct {
            autorest.Response `json:"-"`
            Links *[]Link `json:"links,omitempty"`
            Collections *[]CollectionInfo `json:"collections,omitempty"`
            }

            // ConversionConvertPreviewFuture an abstraction for monitoring and retrieving the results of a
            // long-running operation.
            type ConversionConvertPreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(ConversionClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *ConversionConvertPreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for ConversionConvertPreviewFuture.Result.
        func (future *ConversionConvertPreviewFuture) result(client ConversionClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.ConversionConvertPreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.ConversionConvertPreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.ConvertPreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.ConversionConvertPreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // ConversionListDetailInfo detail information for the conversion requests.
            type ConversionListDetailInfo struct {
            // ConversionID - READ-ONLY; A unique id that represents the artifact of a _successfully_ completed conversion process.
            ConversionID *string `json:"conversionId,omitempty"`
            // Udid - READ-ONLY; The unique id of the content provided to create this conversion.
            Udid *string `json:"udid,omitempty"`
            // Created - READ-ONLY; The date and time of this conversion.
            Created *string `json:"created,omitempty"`
            // Description - READ-ONLY; User provided description of the content being converted.
            Description *string `json:"description,omitempty"`
            // FeatureCounts - READ-ONLY; A summary of feature counts in this conversion.
            FeatureCounts interface{} `json:"featureCounts,omitempty"`
            }

            // ConversionListResponse the response model for the Conversion List API.
            type ConversionListResponse struct {
            autorest.Response `json:"-"`
            // Conversions - READ-ONLY; A list of all the previously submitted conversion requests.
            Conversions *[]ConversionListDetailInfo `json:"conversions,omitempty"`
            }

            // Coordinate a location represented as a latitude and longitude.
            type Coordinate struct {
            // Latitude - Latitude property
            Latitude *float64 `json:"latitude,omitempty"`
            // Longitude - Longitude property
            Longitude *float64 `json:"longitude,omitempty"`
            }

            // CoordinateAbbreviated a location represented as a latitude and longitude.
            type CoordinateAbbreviated struct {
            // Lat - Latitude property
            Lat *float64 `json:"lat,omitempty"`
            // Lon - Longitude property
            Lon *float64 `json:"lon,omitempty"`
            }

            // CopyrightBoundingResult this object is returned from a successful Copyright Bounding call
            type CopyrightBoundingResult struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            // GeneralCopyrights - READ-ONLY; General Copyrights array
            GeneralCopyrights *[]string `json:"generalCopyrights,omitempty"`
            // Regions - READ-ONLY; Regions array
            Regions *[]Region `json:"regions,omitempty"`
            }

            // CopyrightCaptionResult this object is returned from a successful Copyright Caption call
            type CopyrightCaptionResult struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            // CopyrightsCaption - READ-ONLY; Copyrights Caption property
            CopyrightsCaption *string `json:"copyrightsCaption,omitempty"`
            }

            // CopyrightTileResult this object is returned from a successful Copyright Tile call
            type CopyrightTileResult struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            // GeneralCopyrights - READ-ONLY; General Copyrights array
            GeneralCopyrights *[]string `json:"generalCopyrights,omitempty"`
            // Regions - READ-ONLY; Regions array
            Regions *[]Region `json:"regions,omitempty"`
            }

            // CopyrightWorldResult this object is returned from a successful Copyright World call
            type CopyrightWorldResult struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            // GeneralCopyrights - READ-ONLY; General Copyrights array
            GeneralCopyrights *[]string `json:"generalCopyrights,omitempty"`
            // Regions - READ-ONLY; Regions array
            Regions *[]Region `json:"regions,omitempty"`
            }

            // Country a country record.
            type Country struct {
            // Name - READ-ONLY; Country Name
            Name *string `json:"Name,omitempty"`
            // Code - READ-ONLY; ISO-3166 2-letter country code for the country.
            Code *string `json:"Code,omitempty"`
            }

            // CountryRegion the object containing the country/region information.
            type CountryRegion struct {
            // IsoCode - READ-ONLY; The IP Address's 2-character code [(ISO 3166-1)](https://www.iso.org/iso-3166-country-codes.html) of the country or region as assigned by IANA and regional internet authorities. Please note, IP address in ranges reserved for special purpose will return Null for country/region.
            IsoCode *string `json:"isoCode,omitempty"`
            }

            // CurrentAirQualityResponse this object is returned from a successful Get Current Air Quality call.
            type CurrentAirQualityResponse struct {
            // Results - A list of all air quality results for the queried location.
            Results *[]AirQuality `json:"results,omitempty"`
            }

            // CurrentConditions ...
            type CurrentConditions struct {
            // DateTime - Date and time of the current observation displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            DateTime *string `json:"dateTime,omitempty"`
            // Phrase - Phrase description of the current weather condition.  Displayed in specified language.
            Phrase *string `json:"phrase,omitempty"`
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            // HasPrecipitation - Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates the absence of precipitation.
            HasPrecipitation *bool `json:"hasPrecipitation,omitempty"`
            // IsDayTime - Indicates the time of the day. True indicates 'day',', false indicates 'night.
            IsDayTime *bool `json:"isDayTime,omitempty"`
            // Temperature - Temperature being returned.
            Temperature *WeatherUnit `json:"temperature,omitempty"`
            // RealFeelTemperature - RealFeel™ Temperature being returned.
            RealFeelTemperature *WeatherUnit `json:"realFeelTemperature,omitempty"`
            // RealFeelTemperatureShade - RealFeel™ Temperature being returned. Describes what the temperature really feels like in the shade.
            RealFeelTemperatureShade *WeatherUnit `json:"realFeelTemperatureShade,omitempty"`
            // RelativeHumidity - Relative humidity is the amount of water vapor present in air expressed as a percentage of the amount needed for saturation at the same temperature.
            RelativeHumidity *int32 `json:"relativeHumidity,omitempty"`
            // DewPoint - The dewpoint temperature in specified unit. The dewpoint temperature is the temperature that the air must be cooled to in order to reach saturation.
            DewPoint *WeatherUnit `json:"dewPoint,omitempty"`
            // Wind - Wind details being returned including speed and direction.
            Wind *Wind `json:"wind,omitempty"`
            // WindGust - Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
            WindGust *Wind `json:"windGust,omitempty"`
            UvIndex *int32 `json:"uvIndex,omitempty"`
            // UvIndexPhrase - Phrase associated with the `uvIndex`.
            UvIndexPhrase *string `json:"uvIndexPhrase,omitempty"`
            // Visibility - Visibility in specified unit. A measure of the distance at which an object or light can be clearly discerned.
            Visibility *WeatherUnit `json:"visibility,omitempty"`
            // ObstructionsToVisibility - Cause of limited visibility.
            ObstructionsToVisibility *string `json:"obstructionsToVisibility,omitempty"`
            // CloudCover - Percent representing cloud cover.
            CloudCover *int32 `json:"cloudCover,omitempty"`
            // Ceiling - Cloud ceiling in specified unit. The ceiling is a measurement of the height of the base of the lowest clouds.
            Ceiling *WeatherUnit `json:"ceiling,omitempty"`
            // Pressure - Atmospheric pressure in specified unit.
            Pressure *WeatherUnit `json:"pressure,omitempty"`
            // PressureTendency - Atmospheric pressure change.
            PressureTendency *PressureTendency `json:"pressureTendency,omitempty"`
            // Past24HourTemperatureDeparture - Departure from the temperature observed 24 hours ago in specified unit.
            Past24HourTemperatureDeparture *WeatherUnit `json:"past24HourTemperatureDeparture,omitempty"`
            // ApparentTemperature - Perceived outdoor temperature caused by the combination of air temperature, relative humidity, and wind speed in specified unit.
            ApparentTemperature *WeatherUnit `json:"apparentTemperature,omitempty"`
            // WindChillTemperature - Perceived air temperature on exposed skin due to wind.
            WindChillTemperature *WeatherUnit `json:"windChillTemperature,omitempty"`
            // WetBulbTemperature - The temperature to which air may be cooled by evaporating water into it at constant pressure until it reaches saturation.
            WetBulbTemperature *WeatherUnit `json:"wetBulbTemperature,omitempty"`
            // PrecipitationSummary - Summary of precipitation amounts over the past 24 hours.
            PrecipitationSummary *PrecipitationSummary `json:"precipitationSummary,omitempty"`
            // TemperatureSummary - Summary of temperature fluctuations over the past 6, 12, and 24 hours.
            TemperatureSummary *TemperatureSummary `json:"temperatureSummary,omitempty"`
            }

            // CurrentConditionsResponse ...
            type CurrentConditionsResponse struct {
            autorest.Response `json:"-"`
            Results *[]CurrentConditions `json:"results,omitempty"`
            }

            // DailyAirQuality information about the air quality in a specific location at a specific time.
            type DailyAirQuality struct {
            // DateTime - Date and time of the current observation displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            DateTime *string `json:"dateTime,omitempty"`
            // Index - Air quality rating on a scale set by local regulating bodies. Scales can vary widely based on location. See [Wikipedia](https://en.wikipedia.org/wiki/Air_quality_index) for more information.
            Index *float64 `json:"index,omitempty"`
            // GlobalIndex - Internationally normalized air quality rating on a scale from 0 to 300 and up, with higher numbers representing worse air quality.
            GlobalIndex *float64 `json:"globalIndex,omitempty"`
            // DominantPollutant - The pollutant with the highest concentration. Possible values include: 'CarbonMonoxide', 'NitrogenDioxide', 'Ozone', 'ParticulateMatter25', 'ParticulateMatter10', 'SulfurDioxide'
            DominantPollutant DominantPollutant `json:"dominantPollutant,omitempty"`
            // Category - One-word description of the air quality in the requested language. For example, "Excellent".
            Category *string `json:"category,omitempty"`
            // CategoryColor - A unique color corresponding to the category of this air quality result.
            CategoryColor *string `json:"categoryColor,omitempty"`
            // Description - A textual explanation of this air quality result in the requested language.
            Description *string `json:"description,omitempty"`
            }

            // DailyAirQualityForecastResponse this object is returned from a successful Get Daily Air Quality Forecast
            // call.
            type DailyAirQualityForecastResponse struct {
            // Forecasts - A list of all daily air quality forecasts for the queried location.
            Forecasts *[]DailyAirQuality `json:"forecasts,omitempty"`
            }

            // DailyForecast ...
            type DailyForecast struct {
            // Date - Date and time of the current observation displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            Date *string `json:"date,omitempty"`
            // Temperature - Temperature values for the day.
            Temperature *WeatherUnitRange `json:"temperature,omitempty"`
            // RealFeelTemperature - RealFeel™ Temperature being returned.
            RealFeelTemperature *WeatherUnitRange `json:"realFeelTemperature,omitempty"`
            // RealFeelTemperatureShade - RealFeel™ Temperature being returned. Describes what the temperature really feels like in the shade.
            RealFeelTemperatureShade *WeatherUnitRange `json:"realFeelTemperatureShade,omitempty"`
            // HoursOfSun - Hours of sun.
            HoursOfSun *float64 `json:"hoursOfSun,omitempty"`
            // DegreeDaySummary - Summary of Heating Degree Day or Cooling Degree Day information
            DegreeDaySummary *DegreeDaySummary `json:"degreeDaySummary,omitempty"`
            // AirAndPollen - airAndPollen
            AirAndPollen *[]AirAndPollen `json:"airAndPollen,omitempty"`
            // Day - Day
            Day *DayOrNight `json:"day,omitempty"`
            // Night - Night
            Night *DayOrNight `json:"night,omitempty"`
            Sources *[]string `json:"sources,omitempty"`
            }

            // DailyForecastResponse ...
            type DailyForecastResponse struct {
            autorest.Response `json:"-"`
            Summary *DailyForecastSummary `json:"summary,omitempty"`
            // Forecasts - Forecast data for each requested day.
            Forecasts *[]DailyForecast `json:"forecasts,omitempty"`
            }

            // DailyForecastSummary summary for the main conditions for the requested time period. Notice that summary
            // can cover only part of the time period.
            type DailyForecastSummary struct {
            // StartDate - Date and time that the summary is in effect, displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            StartDate *string `json:"startDate,omitempty"`
            // EndDate - Date and time that the summary period ends, displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            EndDate *string `json:"endDate,omitempty"`
            // Severity - severity
            Severity *int32 `json:"severity,omitempty"`
            // Phrase - Summary phrase of the daily forecast.  Displayed in specified language.
            Phrase *string `json:"phrase,omitempty"`
            // Category - one or 2 word(s) to summarize the phrase.
            Category *string `json:"category,omitempty"`
            }

            // DailyIndex information about a daily index.
            type DailyIndex struct {
            // IndexName - Name of the index, for example, "Construction", "Outdoor Activity", "Flight Delays".
            IndexName *string `json:"indexName,omitempty"`
            // IndexID - Numeric ID used to identify the specific index. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details and to see the supported index IDs. For example, the index ID can support UI visualization scenarios.
            IndexID *int32 `json:"indexId,omitempty"`
            // DateTime - Date and time of the current observation displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            DateTime *string `json:"dateTime,omitempty"`
            // Value - Index value. Ranges from 0.0 to 10.0. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details and to see the supported ranges.
            Value *float64 `json:"value,omitempty"`
            // Category - Textual description for `categoryValue` corresponding to the level that the index value falls under, for example "Very Good".
            Category *string `json:"category,omitempty"`
            // CategoryValue - Level that the index value falls under, represented by an integer. This value can be 1 through 5 and should be used in combination with the `ascending` flag because it can differ among indices. For example, the following values apply for Mosquito Activity: Low=1, Moderate=2, High=3, Very High=4, and Extreme=5.
            CategoryValue *int32 `json:"categoryValue,omitempty"`
            // Ascending - Describes the direction of the `value` and `categoryValue`. For example, when `ascending`=True, the poorest index value is 0 and the best index value is 10. When `ascending`=True, the poorest index value is 10 and the best index value is 0.
            Ascending *bool `json:"ascending,omitempty"`
            // Description - A textual explanation that can be used for display purposes to summarize the index value and category. For example, when the index value for Flight Delays is very good, the description will be "Conditions are excellent for flying!".
            Description *string `json:"description,omitempty"`
            }

            // DailyIndicesResponse this object is returned from a successful Get Daily Indices call.
            type DailyIndicesResponse struct {
            autorest.Response `json:"-"`
            // Results - A list of all daily indices for the queried location.
            Results *[]DailyIndex `json:"results,omitempty"`
            }

            // DataDetailInfo detail information for the data.
            type DataDetailInfo struct {
            // Udid - READ-ONLY; The unique data id for the data.
            Udid *string `json:"udid,omitempty"`
            // Location - READ-ONLY; The location of the data. Execute a HTTP `GET` on this location to download the data.
            Location *string `json:"location,omitempty"`
            // SizeInBytes - READ-ONLY; The size of the content in bytes.
            SizeInBytes *int64 `json:"sizeInBytes,omitempty"`
            // UploadStatus - READ-ONLY; The current upload status of the content.
            UploadStatus *string `json:"uploadStatus,omitempty"`
            }

            // DataListResponse the response model for the Data List API. Returns a list of all the previously uploaded
            // data.
            type DataListResponse struct {
            autorest.Response `json:"-"`
            // MapDataList - READ-ONLY; A list of all the previously uploaded data.
            MapDataList *[]DataDetailInfo `json:"mapDataList,omitempty"`
            }

            // DatasetCreatePreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DatasetCreatePreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DatasetClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DatasetCreatePreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DatasetCreatePreviewFuture.Result.
        func (future *DatasetCreatePreviewFuture) result(client DatasetClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.DatasetCreatePreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.DatasetCreatePreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.CreatePreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.DatasetCreatePreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DatasetDetailInfo detail information for the dataset.
            type DatasetDetailInfo struct {
            // Created - READ-ONLY; The created timestamp for the dataset.
            Created *string `json:"created,omitempty"`
            // DatasetID - READ-ONLY; The id for the dataset.
            DatasetID *string `json:"datasetId,omitempty"`
            // Description - READ-ONLY; The description for the dataset.
            Description *string `json:"description,omitempty"`
            DatasetSources *DatasetSources `json:"datasetSources,omitempty"`
            // FeatureCounts - READ-ONLY; The feature counts for the dataset.
            FeatureCounts interface{} `json:"featureCounts,omitempty"`
            }

        // MarshalJSON is the custom marshaler for DatasetDetailInfo.
        func (ddi DatasetDetailInfo)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ddi.DatasetSources != nil) {
                objectMap["datasetSources"] = ddi.DatasetSources
                }
                return json.Marshal(objectMap)
        }

            // DatasetImportPreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DatasetImportPreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DatasetClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DatasetImportPreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DatasetImportPreviewFuture.Result.
        func (future *DatasetImportPreviewFuture) result(client DatasetClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.DatasetImportPreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.DatasetImportPreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.ImportPreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.DatasetImportPreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DatasetListResponse the response model for the Dataset List API. The response body will contain a list
            // of all the previously created datasets.
            type DatasetListResponse struct {
            autorest.Response `json:"-"`
            // Datasets - READ-ONLY; A list of all the previously created datasets.
            Datasets *[]DatasetDetailInfo `json:"datasets,omitempty"`
            }

            // DatasetSources information about the details of the create request for the dataset.
            type DatasetSources struct {
            // ConversionIds - READ-ONLY; The list of `conversionId` that were used to create the dataset.
            ConversionIds *[]string `json:"conversionIds,omitempty"`
            // Udids - READ-ONLY; The list of `conversionId` that were used to create the dataset.
            Udids *[]string `json:"udids,omitempty"`
            // AppendDatasetID - READ-ONLY; The dataset that was appended to to create the current dataset.
            AppendDatasetID *string `json:"appendDatasetId,omitempty"`
            // Type - READ-ONLY; The type of data stored in the dataset.
            Type *string `json:"type,omitempty"`
            }

            // DataSources optional section. Reference ids for use with the [Get Search
            // Polygon](https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon) API.
            type DataSources struct {
            Geometry *DataSourcesGeometry `json:"geometry,omitempty"`
            }

            // DataSourcesGeometry information about the geometric shape of the result. Only present if type ==
            // Geography.
            type DataSourcesGeometry struct {
            // ID - READ-ONLY; Pass this as geometryId to the [Get Search Polygon](https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon) API to fetch geometry information for this result.
            ID *string `json:"id,omitempty"`
            }

            // DataUpdatePreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DataUpdatePreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DataClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DataUpdatePreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DataUpdatePreviewFuture.Result.
        func (future *DataUpdatePreviewFuture) result(client DataClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.DataUpdatePreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.DataUpdatePreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.UpdatePreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.DataUpdatePreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DataUploadPreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type DataUploadPreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(DataClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *DataUploadPreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for DataUploadPreviewFuture.Result.
        func (future *DataUploadPreviewFuture) result(client DataClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.DataUploadPreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.DataUploadPreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.UploadPreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.DataUploadPreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // DayOrNight ...
            type DayOrNight struct {
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            // IconPhrase - Phrase description of the icon. Displayed in specified language. For example, 'Sunny'.
            IconPhrase *string `json:"iconPhrase,omitempty"`
            LocalSource *LocalSource `json:"localSource,omitempty"`
            // HasPrecipitation - Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates the absence of precipitation.
            HasPrecipitation *bool `json:"hasPrecipitation,omitempty"`
            // PrecipitationType - Specifies the type of precipitation ("rain" "snow" "ice" or "mix"). If dbz = zero, precipitationType is not present in the response.
            PrecipitationType *string `json:"precipitationType,omitempty"`
            // PrecipitationIntensity - Description of the intensity.
            PrecipitationIntensity *string `json:"precipitationIntensity,omitempty"`
            // ShortPhrase - Phrase description of the forecast in specified language. Azure Maps attempts to keep this phrase under 30 characters in length, but some languages/weather events may result in a longer phrase length, exceeding 30 characters.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            // LongPhrase - Phrase description of the forecast in specified language. Azure Maps attempts to keep this phrase under 100 characters in length, but some languages/weather events may result in a longer phrase length, exceeding 100 characters.
            LongPhrase *string `json:"longPhrase,omitempty"`
            // PrecipitationProbability - Percent representing the probability of precipitation. For example, '20'.
            PrecipitationProbability *int32 `json:"precipitationProbability,omitempty"`
            // ThunderstormProbability - Percent representing the probability of a thunderstorm. For example, '80'.
            ThunderstormProbability *int32 `json:"thunderstormProbability,omitempty"`
            // RainProbability - Percent representing the probability of rain. For example, '40'.
            RainProbability *int32 `json:"rainProbability,omitempty"`
            // SnowProbability - Percent representing the probability of snow. For example, '30'.
            SnowProbability *int32 `json:"snowProbability,omitempty"`
            // IceProbability - Percent representing the probability of ice. For example, '30'.
            IceProbability *int32 `json:"iceProbability,omitempty"`
            // Wind - Wind details being returned including speed and direction.
            Wind *Wind `json:"wind,omitempty"`
            // WindGust - Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
            WindGust *Wind `json:"windGust,omitempty"`
            // TotalLiquid - Total liquid equivalent of precipitation during the forecast period.
            TotalLiquid *WeatherUnit `json:"totalLiquid,omitempty"`
            // Rain - Rain
            Rain *WeatherUnit `json:"rain,omitempty"`
            // Snow - Snow
            Snow *WeatherUnit `json:"snow,omitempty"`
            // Ice - Ice
            Ice *WeatherUnit `json:"ice,omitempty"`
            // HoursOfPrecipitation - Hours of precipitation
            HoursOfPrecipitation *float64 `json:"hoursOfPrecipitation,omitempty"`
            // HoursOfRain - Hours of rain.
            HoursOfRain *float64 `json:"hoursOfRain,omitempty"`
            // HoursOfSnow - Hours of snow.
            HoursOfSnow *float64 `json:"hoursOfSnow,omitempty"`
            // HoursOfIce - Hours of ice.
            HoursOfIce *float64 `json:"hoursOfIce,omitempty"`
            // CloudCover - Percent representing cloud cover.
            CloudCover *int32 `json:"cloudCover,omitempty"`
            }

            // DefinitionProperties ...
            type DefinitionProperties struct {
            // Name - name of attribute
            Name *string `json:"name,omitempty"`
            // Required - is attribute required
            Required *bool `json:"required,omitempty"`
            // Type - type of attribute
            Type interface{} `json:"type,omitempty"`
            }

            // DegreeDaySummary ...
            type DegreeDaySummary struct {
            // Heating - Number of degrees that the mean temperature is below 65 degrees F/ 18 degree C.
            Heating *WeatherUnit `json:"heating,omitempty"`
            // Cooling - Number of degrees that the mean temperature is above 65 degrees F/ 18 degree C.
            Cooling *WeatherUnit `json:"cooling,omitempty"`
            }

            // Description description of a severe weather alert.
            type Description struct {
            // Localized - Description of the alert in the specified language. By default English (en-US) is returned if the language parameter is not specified in the request.
            Localized *string `json:"localized,omitempty"`
            // English - Description of the alert in English (en-US).
            English *string `json:"english,omitempty"`
            }

            // Direction the walking directions guidance.
            type Direction struct {
            // RelativeDirection - The relative walking direction associated with applicable step. Possible values include: 'Depart', 'HardLeft', 'Left', 'SlightlyLeft', 'Continue', 'SlightlyRight', 'Right', 'HardRight', 'CircleClockwise', 'CircleCounterclockwise', 'Elevator', 'UturnLeft', 'UturnRight'
            RelativeDirection RelativeDirection `json:"relativeDirection,omitempty"`
            // AbsoluteDirection - The absolute walking direction associated with this step. Possible values include: 'North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest'
            AbsoluteDirection AbsoluteDirection `json:"absoluteDirection,omitempty"`
            }

            // ErrorAdditionalInfo the resource management error additional info.
            type ErrorAdditionalInfo struct {
            // Type - READ-ONLY; The additional info type.
            Type *string `json:"type,omitempty"`
            // Info - READ-ONLY; The additional info.
            Info interface{} `json:"info,omitempty"`
            }

            // ErrorDetail the error detail.
            type ErrorDetail struct {
            // Code - READ-ONLY; The error code.
            Code *string `json:"code,omitempty"`
            // Message - READ-ONLY; The error message.
            Message *string `json:"message,omitempty"`
            // Target - READ-ONLY; The error target.
            Target *string `json:"target,omitempty"`
            // Details - READ-ONLY; The error details.
            Details *[]ErrorDetail `json:"details,omitempty"`
            // AdditionalInfo - READ-ONLY; The error additional info.
            AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
            }

            // ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
            // failed operations. (This also follows the OData error response format.).
            type ErrorResponse struct {
            // Error - The error object.
            Error *ErrorDetail `json:"error,omitempty"`
            }

            // Fares detailed fare information for the leg.
            type Fares struct {
            // Price - The price of the ticket when purchased for the individual leg, not for the entire route at once.
            Price *Price `json:"price,omitempty"`
            // Usage - Supported values are:
            //   * pay – user is expected to pay for this ticket in order to consume the current leg
            //   * transfer – user can use a ticket purchased in a previous leg in order to consume the current leg. In general, when transfer is specified, the number of transfers is counted, and has a limit.
            //   * continue – user can use a ticket purchased in a previous leg in order to consume the current leg. In general, when continue is specified, the number of transfers isn’t incremented for this leg.
            //   * upgrade – user is expected to upgrade a ticket purchased in a previous leg in order to consume the current leg.
            Usage *string `json:"usage,omitempty"`
            }

            // Feature ...
            type Feature struct {
            autorest.Response `json:"-"`
            Feature *FeatureGeoJSON `json:"feature,omitempty"`
            Links *[]Link `json:"links,omitempty"`
            }

            // FeatureCollectionGeoJSON ...
            type FeatureCollectionGeoJSON struct {
            autorest.Response `json:"-"`
            Type *string `json:"type,omitempty"`
            NumberReturned *int32 `json:"numberReturned,omitempty"`
            Features *[]FeatureGeoJSON `json:"features,omitempty"`
            Links *[]Link `json:"links,omitempty"`
            }

            // FeatureGeoJSON geoJSON Feature
            type FeatureGeoJSON struct {
            // Type - feature
            Type *string `json:"type,omitempty"`
            // Geometry - This represents the geometry for one or more geographical features (parks, state boundary etc.) and should be a `GeoJSON` compliant type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946) for details.
            Geometry interface{} `json:"geometry,omitempty"`
            // Properties - Additional properties of the feature.
            Properties interface{} `json:"properties,omitempty"`
            // ID - Identifier for the feature.
            ID *string `json:"id,omitempty"`
            // FeatureType - The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value.
            FeatureType *string `json:"featureType,omitempty"`
            }

            // FeatureStateObject single feature state model.
            type FeatureStateObject struct {
            // KeyName - Feature state Keyname.
            KeyName *string `json:"keyName,omitempty"`
            // Value - Value for the feature state.
            Value interface{} `json:"value,omitempty"`
            // EventTimestamp - Timestamp when the feature state was captured.
            EventTimestamp *string `json:"eventTimestamp,omitempty"`
            }

            // FeatureStatesStructure the feature states model for a feature.
            type FeatureStatesStructure struct {
            autorest.Response `json:"-"`
            // States - The feature states array.
            States *[]FeatureStateObject `json:"states,omitempty"`
            }

            // GeofenceGeometry the geofencing geometry.
            type GeofenceGeometry struct {
            // DeviceID - READ-ONLY; ID of the device.
            DeviceID *string `json:"deviceId,omitempty"`
            // UdID - READ-ONLY; The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object. Please refer to  [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature's properties should  contain `geometryId`, which is used for identifying the geometry and is case-sensitive.
            UdID *string `json:"udId,omitempty"`
            // GeometryID - READ-ONLY; The unique id identifies a geometry.
            GeometryID *string `json:"geometryId,omitempty"`
            // Distance - READ-ONLY; Distance from the coordinate to the closest border of the geofence. Positive means the  coordinate is outside of the geofence. If the coordinate is outside of the geofence, but more than the value of searchBuffer away from the closest geofence border, then the value is 999. Negative means the coordinate is inside of the geofence. If the coordinate is inside the polygon, but more than the value of searchBuffer away from the closest geofencing border, then the value is -999. A value of 999 means that there is great confidence the coordinate is well outside the geofence. A value of -999 means that there is great confidence the coordinate is well within the geofence.
            Distance *float64 `json:"distance,omitempty"`
            // NearestLat - READ-ONLY; Latitude of the nearest point of the geometry.
            NearestLat *float64 `json:"nearestLat,omitempty"`
            // NearestLon - READ-ONLY; Longitude of the nearest point of the geometry.
            NearestLon *float64 `json:"nearestLon,omitempty"`
            // NearestZ - READ-ONLY; Sea level in meter of the nearest point on the 2D extrusion geometry. This will only be presented in response when value is provided for 'zInMeter' in the request.
            NearestZ *float64 `json:"nearestZ,omitempty"`
            }

            // GeofenceResponse this object is returned from a geofence proximity call.
            type GeofenceResponse struct {
            autorest.Response `json:"-"`
            // Geometries - READ-ONLY; Lists the fence geometries that contain the coordinate position or overlap the searchBuffer around the position.
            Geometries *[]GeofenceGeometry `json:"geometries,omitempty"`
            // ExpiredGeofenceGeometryID - READ-ONLY; Lists of the geometry ID of the geofence which is expired relative to the user time in the request.
            ExpiredGeofenceGeometryID *[]string `json:"expiredGeofenceGeometryId,omitempty"`
            // InvalidPeriodGeofenceGeometryID - READ-ONLY; Lists of the geometry ID of the geofence which is in invalid period relative to the user time in the request.
            InvalidPeriodGeofenceGeometryID *[]string `json:"invalidPeriodGeofenceGeometryId,omitempty"`
            // IsEventPublished - READ-ONLY; True if at least one event is published to the Azure Maps event subscriber, false if no event is published to the Azure Maps event subscriber. This will only be presented in response when 'isAsync' query parameter is set to true.
            IsEventPublished *bool `json:"isEventPublished,omitempty"`
            }

            // GeoJSONFeatureCollection a valid `GeoJSON FeatureCollection` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
            type GeoJSONFeatureCollection struct {
            // Type - Specifies the `type` for the object. Value should always be equal to "FeatureCollection".
            Type *string `json:"type,omitempty"`
            // Features - Contains a list of valid `GeoJSON Feature` objects.
            Features *[]GeoJSONFeatureCollectionFeaturesItem `json:"features,omitempty"`
            }

            // GeoJSONFeatureCollectionFeaturesItem a valid `GeoJSON Feature` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.2) for details.
            type GeoJSONFeatureCollectionFeaturesItem struct {
            // Type - Specifies the `type` for the object. Value should always be equal to "Feature".
            Type *string `json:"type,omitempty"`
            Geometry BasicGeoJSONGeometry `json:"geometry,omitempty"`
            // Properties - Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value
            Properties interface{} `json:"properties,omitempty"`
            }
        // UnmarshalJSON is the custom unmarshaler for GeoJSONFeatureCollectionFeaturesItem struct.
        func (gjfcI *GeoJSONFeatureCollectionFeaturesItem) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
    if err != nil {
    return err
    }
        gjfcI.Type = &typeVar
    }
                case "geometry":
    if v != nil {
        geometry, err := unmarshalBasicGeoJSONGeometry(*v)
    if err != nil {
    return err
    }
        gjfcI.Geometry = geometry
    }
                case "properties":
    if v != nil {
        var properties interface{}
        err = json.Unmarshal(*v, &properties)
    if err != nil {
    return err
    }
        gjfcI.Properties = properties
    }
            }
        }

        return nil
        }

// BasicGeoJSONGeometry a valid `GeoJSON` geometry object. Please refer to [RFC
// 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details.
        type BasicGeoJSONGeometry interface {
        AsGeoJSONGeometry () (*GeoJSONGeometry, bool)
        }

        // GeoJSONGeometry a valid `GeoJSON` geometry object. Please refer to [RFC
        // 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details.
        type GeoJSONGeometry struct {
        // Type - Possible values include: 'TypeGeoJSONGeometry'
        Type TypeBasicGeoJSONGeometry `json:"type,omitempty"`
        }

        func unmarshalBasicGeoJSONGeometry(body []byte) (BasicGeoJSONGeometry, error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }

        switch m["type"] {
        default:
        var gjg GeoJSONGeometry
        err := json.Unmarshal(body, &gjg)
        return gjg, err
        }
        }
        func unmarshalBasicGeoJSONGeometryArray(body []byte) ([]BasicGeoJSONGeometry, error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }

        gjgArray := make([]BasicGeoJSONGeometry, len(rawMessages))

        for index, rawMessage := range rawMessages {
        gjg, err := unmarshalBasicGeoJSONGeometry(*rawMessage)
        if err != nil {
        return nil, err
        }
        gjgArray[index] = gjg
        }
        return gjgArray, nil
        }

        // MarshalJSON is the custom marshaler for GeoJSONGeometry.
        func (gjg GeoJSONGeometry)MarshalJSON() ([]byte, error){
            gjg.Type = TypeGeoJSONGeometry
            objectMap := make(map[string]interface{})
                if(gjg.Type != "") {
                objectMap["type"] = gjg.Type
                }
                return json.Marshal(objectMap)
        }

            // AsGeoJSONGeometry is the BasicGeoJSONGeometry implementation for GeoJSONGeometry.
            func (gjg GeoJSONGeometry) AsGeoJSONGeometry() (*GeoJSONGeometry, bool) {
                return &gjg, true
            }

                // AsBasicGeoJSONGeometry is the BasicGeoJSONGeometry implementation for GeoJSONGeometry.
                func(gjg GeoJSONGeometry) AsBasicGeoJSONGeometry()(BasicGeoJSONGeometry, bool) {
                    return &gjg, true
                }


            // GeometryCollection a valid `GeoJSON GeometryCollection` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.8) for details.
            type GeometryCollection struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            // Geometries - Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Geometries *[]BasicGeoJSONGeometry `json:"geometries,omitempty"`
            }
        // UnmarshalJSON is the custom unmarshaler for GeometryCollection struct.
        func (gc *GeometryCollection) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "type":
    if v != nil {
        var typeVar GeoJSONGeometryType
        err = json.Unmarshal(*v, &typeVar)
    if err != nil {
    return err
    }
        gc.Type = typeVar
    }
                case "geometries":
    if v != nil {
        geometries, err := unmarshalBasicGeoJSONGeometryArray(*v)
    if err != nil {
    return err
    }
        gc.Geometries = &geometries
    }
            }
        }

        return nil
        }

            // GeometryCollectionData ...
            type GeometryCollectionData struct {
            // Geometries - Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Geometries *[]BasicGeoJSONGeometry `json:"geometries,omitempty"`
            }
        // UnmarshalJSON is the custom unmarshaler for GeometryCollectionData struct.
        func (gcd *GeometryCollectionData) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "geometries":
    if v != nil {
        geometries, err := unmarshalBasicGeoJSONGeometryArray(*v)
    if err != nil {
    return err
    }
        gcd.Geometries = &geometries
    }
            }
        }

        return nil
        }

            // GetClosestPointResponse this object is returned from a successful Get Spatial Closest Point call
            type GetClosestPointResponse struct {
            autorest.Response `json:"-"`
            Summary *GetClosestPointSummary `json:"summary,omitempty"`
            Result *[]ClosestPointResultEntry `json:"result,omitempty"`
            }

            // GetClosestPointSummary get Closest Point Summary object
            type GetClosestPointSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; Processing information
            Information *string `json:"information,omitempty"`
            }

        // MarshalJSON is the custom marshaler for GetClosestPointSummary.
        func (gcps GetClosestPointSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(gcps.SourcePoint != nil) {
                objectMap["sourcePoint"] = gcps.SourcePoint
                }
                return json.Marshal(objectMap)
        }

            // GetPointInPolygonResponse returns true if point is within the polygon, false otherwise
            type GetPointInPolygonResponse struct {
            autorest.Response `json:"-"`
            Summary *GetPointInPolygonSummary `json:"summary,omitempty"`
            Result *PointInPolygonResult `json:"result,omitempty"`
            }

            // GetPointInPolygonSummary point In Polygon Summary object
            type GetPointInPolygonSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; Processing information
            Information *string `json:"information,omitempty"`
            }

        // MarshalJSON is the custom marshaler for GetPointInPolygonSummary.
        func (gpips GetPointInPolygonSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(gpips.SourcePoint != nil) {
                objectMap["sourcePoint"] = gpips.SourcePoint
                }
                return json.Marshal(objectMap)
        }

            // GreatCircleDistanceResponse this object is returned from a successful Great Circle Distance call
            type GreatCircleDistanceResponse struct {
            autorest.Response `json:"-"`
            // Summary - READ-ONLY; Summary object
            Summary *GreatCircleDistanceResponseSummary `json:"summary,omitempty"`
            // Result - READ-ONLY; Result Object
            Result *GreatCircleDistanceResponseResult `json:"result,omitempty"`
            }

            // GreatCircleDistanceResponseResult result Object
            type GreatCircleDistanceResponseResult struct {
            // DistanceInMeters - READ-ONLY; The great circle distance in meters from the source point to the target point
            DistanceInMeters *float64 `json:"distanceInMeters,omitempty"`
            }

            // GreatCircleDistanceResponseSummary summary object
            type GreatCircleDistanceResponseSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            TargetPoint *SpatialCoordinate `json:"targetPoint,omitempty"`
            }

            // HazardDetail ...
            type HazardDetail struct {
            HazardIndex *int32 `json:"hazardIndex,omitempty"`
            // HazardCode - A unique identifier (non-displayable) for each type of hazard: LightRain, ModerateRain, HeavyRain, LightMix, ModerateMix, HeavyMix, LightSnow, ModerateSnow, HeavySnow, LightIce, ModerateIce, HeavyIce, Hail, LargeHail, SunGlare, SunGlareHigh, Lightning, SevereLightning, WindModerate, WindHigh, WindExtreme, FloodWarning, FlashFloodWarning, TornadoWarning, TsunamiWarning, SevereThunderstormWarning.
            HazardCode *string `json:"hazardCode,omitempty"`
            // ShortPhrase - A displayable short phrase describing the forecasted conditions and precipitation intensity/type.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            }

            // Hazards ...
            type Hazards struct {
            MaxHazardIndex *int32 `json:"maxHazardIndex,omitempty"`
            // HazardDetails - Details of the weather hazards affecting the trip.
            HazardDetails *[]HazardDetail `json:"hazardDetails,omitempty"`
            }

            // HourlyAirQualityForecastResponse this object is returned from a successful Get Hourly Air Quality
            // Forecast call.
            type HourlyAirQualityForecastResponse struct {
            // Forecasts - A list of all hourly air quality forecasts for the queried location.
            Forecasts *[]AirQuality `json:"forecasts,omitempty"`
            }

            // HourlyForecast ...
            type HourlyForecast struct {
            // Date - Date and time of the forecast in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            Date *string `json:"date,omitempty"`
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            // IconPhrase - Phrase description of the weather icon.
            IconPhrase *string `json:"iconPhrase,omitempty"`
            // HasPrecipitation - Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates the absence of precipitation.
            HasPrecipitation *bool `json:"hasPrecipitation,omitempty"`
            // IsDaylight - Specifies whether or not it is daylight. True indicates day light.
            IsDaylight *bool `json:"isDaylight,omitempty"`
            // Temperature - Temperature being returned.
            Temperature *WeatherUnit `json:"temperature,omitempty"`
            // RealFeelTemperature - RealFeel™ Temperature being returned. Describes what the temperature really feels like in the shade.
            RealFeelTemperature *WeatherUnit `json:"realFeelTemperature,omitempty"`
            // WetBulbTemperature - The temperature to which air may be cooled by evaporating water into it at constant pressure until it reaches saturation.
            WetBulbTemperature *WeatherUnit `json:"wetBulbTemperature,omitempty"`
            // DewPoint - The dewpoint temperature in specified unit. The dewpoint temperature is the temperature that the air must be cooled to in order to reach saturation.
            DewPoint *WeatherUnit `json:"dewPoint,omitempty"`
            // Wind - Wind details being returned including speed and direction.
            Wind *Wind `json:"wind,omitempty"`
            // WindGust - Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
            WindGust *Wind `json:"windGust,omitempty"`
            // RelativeHumidity - Relative humidity is the amount of water vapor present in air expressed as a percentage of the amount needed for saturation at the same temperature.
            RelativeHumidity *int32 `json:"relativeHumidity,omitempty"`
            // Visibility - Visibility in specified unit. A measure of the distance at which an object or light can be clearly discerned.
            Visibility *WeatherUnit `json:"visibility,omitempty"`
            // Ceiling - Cloud ceiling in specified unit. The ceiling is a measurement of the height of the base of the lowest clouds.
            Ceiling *WeatherUnit `json:"ceiling,omitempty"`
            UvIndex *int32 `json:"uvIndex,omitempty"`
            // UvIndexPhrase - Phrase associated with the `uvIndex`.
            UvIndexPhrase *string `json:"uvIndexPhrase,omitempty"`
            // PrecipitationProbability - Percent representing the probability of precipitation. For example, '20'.
            PrecipitationProbability *int32 `json:"precipitationProbability,omitempty"`
            // RainProbability - Percent representing the probability of rain. For example, '50'.
            RainProbability *int32 `json:"rainProbability,omitempty"`
            // SnowProbability - Percent representing the probability of snow. For example, '50'.
            SnowProbability *int32 `json:"snowProbability,omitempty"`
            // IceProbability - Percent representing the probability of snow. For example, '5'.
            IceProbability *int32 `json:"iceProbability,omitempty"`
            // TotalLiquid - Total liquid equivalent of precipitation during the forecast period.
            TotalLiquid *WeatherUnit `json:"totalLiquid,omitempty"`
            // Rain - Rain
            Rain *WeatherUnit `json:"rain,omitempty"`
            // Snow - Snow
            Snow *WeatherUnit `json:"snow,omitempty"`
            // Ice - Ice
            Ice *WeatherUnit `json:"ice,omitempty"`
            // CloudCover - Percent representing cloud cover.
            CloudCover *int32 `json:"cloudCover,omitempty"`
            }

            // HourlyForecastResponse ...
            type HourlyForecastResponse struct {
            autorest.Response `json:"-"`
            // Forecasts - Forecast data for each returned hour.
            Forecasts *[]HourlyForecast `json:"forecasts,omitempty"`
            }

            // IanaID ...
            type IanaID struct {
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            // IsAlias - READ-ONLY; IsAlias property
            IsAlias *bool `json:"isAlias,omitempty"`
            // AliasOf - READ-ONLY; AliasOf property
            AliasOf *string `json:"aliasOf,omitempty"`
            // HasZone1970Location - READ-ONLY; HasZone1970Location property
            HasZone1970Location *bool `json:"hasZone1970Location,omitempty"`
            }

            // Interval ...
            type Interval struct {
            // StartTime - The date and time for the start of the interval in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            StartTime *string `json:"startTime,omitempty"`
            // Minute - The first minute for the interval.
            Minute *int32 `json:"minute,omitempty"`
            // Dbz - A unit that represents forecasted precipitation intensity.
            Dbz *float64 `json:"dbz,omitempty"`
            // ShortPhrase - A short phrase describing precipitation condition for the interval.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            // Threshold - Key that specifies the threshold value. Along with precipitationType, can be used to determine the simplifiedColor. If dbz is zero, not present in the response.
            Threshold *string `json:"threshold,omitempty"`
            // Color - The full spectrum color that maps to the dBZ (decibel relative to Z). If dbz is zero, color is not present in the response.
            Color *Color `json:"color,omitempty"`
            // SimplifiedColor - The band color that maps to the precipitation type and threshold. If dbz is zero, not present in the response.
            SimplifiedColor *Color `json:"simplifiedColor,omitempty"`
            // PrecipitationType - Specifies the type of precipitation ("rain" "snow" "ice" or "mix"). If dbz is zero, precipitationType is not present in the response.
            PrecipitationType *string `json:"precipitationType,omitempty"`
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            // CloudCover - Percent representing cloud cover.
            CloudCover *int32 `json:"cloudCover,omitempty"`
            }

            // IntervalSummary ...
            type IntervalSummary struct {
            // StartMinute - The first minute to which the summary applies.
            StartMinute *int32 `json:"startMinute,omitempty"`
            // EndMinute - The last minute to which the summary applies.
            EndMinute *int32 `json:"endMinute,omitempty"`
            // TotalMinutes - The number of minutes for which the summary applies.
            TotalMinutes *int32 `json:"totalMinutes,omitempty"`
            // ShortPhrase - Short summary phrase. Phrase length is approximately 25 characters.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            // BriefPhrase - Brief summary phrase. Phrase length is approximately 60 characters.
            BriefPhrase *string `json:"briefPhrase,omitempty"`
            // LongPhrase - Long summary phrase. Phrase length is 60+ characters.
            LongPhrase *string `json:"longPhrase,omitempty"`
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            }

            // IPAddressToLocationResult this object is returned from a successful call to IP Address to country/region
            // API
            type IPAddressToLocationResult struct {
            autorest.Response `json:"-"`
            CountryRegion *CountryRegion `json:"countryRegion,omitempty"`
            // IPAddress - READ-ONLY; The IP Address of the request.
            IPAddress *string `json:"ipAddress,omitempty"`
            }

        // MarshalJSON is the custom marshaler for IPAddressToLocationResult.
        func (iatlr IPAddressToLocationResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(iatlr.CountryRegion != nil) {
                objectMap["countryRegion"] = iatlr.CountryRegion
                }
                return json.Marshal(objectMap)
        }

            // ItineraryFare itinerary level transit fare information.
            type ItineraryFare struct {
            // Price - The total price for all tickets a user is expected to purchase in order to complete this itinerary.
            Price *Price `json:"price,omitempty"`
            // Tickets - An array describing the individual prices of each of the tickets that the user is expected to purchase throughout this itinerary. The list isn’t ordered.
            Tickets *[]Tickets `json:"tickets,omitempty"`
            }

            // ItineraryResult ...
            type ItineraryResult struct {
            // ItineraryID - A unique identifier of the returned itinerary.
            ItineraryID *string `json:"itineraryId,omitempty"`
            // DepartureTime - The date and time of departure from the origin point in ISO 8601 format, e.g. 1996-12-19T16:39:57-08:00.
            DepartureTime *date.Time `json:"departureTime,omitempty"`
            // ArrivalTime - The date and time of arrival at the destination point in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
            ArrivalTime *date.Time `json:"arrivalTime,omitempty"`
            // TravelTimeInSeconds - Estimated travel time in seconds.
            TravelTimeInSeconds *int32 `json:"travelTimeInSeconds,omitempty"`
            // NumberOfLegs - Number of legs.
            NumberOfLegs *int32 `json:"numberOfLegs,omitempty"`
            // Legs - An array summarizing the legs of this itinerary.
            Legs *[]RouteItineraryLeg `json:"legs,omitempty"`
            // ItineraryFare - Itinerary level transit fare information. Returned only if fare information is available for the entire itinerary. [Get Metro Area Info API](https://aka.ms/AzureMapsMobilityMetroAreaInfo) can be requested to confirm if fare information is available in the metro area.
            ItineraryFare *ItineraryFare `json:"itineraryFare,omitempty"`
            }

            // LatestStatus the latest status on the alert in the current area.
            type LatestStatus struct {
            // Localized - The latest status keyword for the alert, in the specified language. By default, returned in English (en-US).
            Localized *string `json:"localized,omitempty"`
            // English - Latest status keyword for the alert, in English (en-US). Possible values include: 'LatestStatusKeywordNew', 'LatestStatusKeywordExtend', 'LatestStatusKeywordCancel', 'LatestStatusKeywordCorrect', 'LatestStatusKeywordExpire', 'LatestStatusKeywordUpgrade', 'LatestStatusKeywordContinue', 'LatestStatusKeywordUpdate'
            English LatestStatusKeyword `json:"english,omitempty"`
            }

            // Leg ...
            type Leg struct {
            // LegType - The travel mode of the leg. Possible values include: 'Walk', 'Bicycle', 'Tram', 'Subway', 'Rail', 'Bus', 'Ferry', 'Cable', 'Gondola', 'Funicular', 'PathWayWalk', 'Wait', 'WaitOnVehicle'
            LegType LegType `json:"legType,omitempty"`
            // LegStartTime - Start time for the leg.
            LegStartTime *string `json:"legStartTime,omitempty"`
            // LegEndTime - End time for the leg.
            LegEndTime *string `json:"legEndTime,omitempty"`
            // Steps - In case of walk or bike leg, the directions.
            Steps *[]Step `json:"steps,omitempty"`
            // Origin - The walk/bike leg’s origin.
            Origin *LegPoint `json:"origin,omitempty"`
            // Destination - The walk/bike leg’s destination.
            Destination *LegPoint `json:"destination,omitempty"`
            Geometry *LineString `json:"geometry,omitempty"`
            // LineGroup - In case of a public transit leg, the line group serving this leg.
            LineGroup *LineGroup `json:"lineGroup,omitempty"`
            // Line - In case of a public transit leg, the line serving this leg.
            Line *Line `json:"line,omitempty"`
            // Stops - List of stops comprising the line’s route within the leg (e.g. the stops the leg passes through).
            Stops *[]Stop `json:"stops,omitempty"`
            // Departures - Relevant for Public Transit and Wait legs only
            Departures *[]LineArrival `json:"departures,omitempty"`
            // LegFare - Leg level public transit fare information. Returned only if fare information is available for the entire itinerary.
            LegFare *LegFare `json:"legFare,omitempty"`
            // WaitOnVehicle - Indicates whether it’s necessary to wait for the next leg on the same vehicle (i.e. the bus will only change its line number).
            WaitOnVehicle *string `json:"waitOnVehicle,omitempty"`
            }

            // LegFare leg level public transit fare information. Returned only if fare information is available for
            // the entire itinerary level and supported by the local transit agency.
            type LegFare struct {
            Fares *[]Fares `json:"fares,omitempty"`
            }

            // LegPoint ...
            type LegPoint struct {
            Position *Coordinate `json:"position,omitempty"`
            }

            // Line a stop line
            type Line struct {
            // LineID - Line Id.
            LineID *string `json:"lineId,omitempty"`
            // LineGroupID - Line group Id. Typically contains 2 lines having the same agency and line, one going from A to B, and the other from B to A.
            LineGroupID *string `json:"lineGroupId,omitempty"`
            // Direction - Line direction. Possible values 'forward' or 'backward'.
            Direction *string `json:"direction,omitempty"`
            // AgencyID - The Id of the transit agency, for example, '5872'.
            AgencyID *string `json:"agencyId,omitempty"`
            // AgencyName - The name of the transit agency, for example, 'NJ Transit'.
            AgencyName *string `json:"agencyName,omitempty"`
            // LineNumber - The transit line number.
            LineNumber *string `json:"lineNumber,omitempty"`
            // Origin - The line’s origin, will be present according to metro settings.
            Origin *string `json:"origin,omitempty"`
            // LineDestination - The line’s user displayable destination.
            LineDestination *string `json:"lineDestination,omitempty"`
            // MostFrequentPatternID - Most common pattern for the line.
            MostFrequentPatternID *string `json:"mostFrequentPatternId,omitempty"`
            // TransitType - The public transit type of the line. Possible values include: 'TransitTypeBus', 'TransitTypeCableCar', 'TransitTypeFerry', 'TransitTypeFunicular', 'TransitTypeGondola', 'TransitTypeRail', 'TransitTypeTram', 'TransitTypeSubway'
            TransitType TransitType `json:"transitType,omitempty"`
            }

            // LineArrival ...
            type LineArrival struct {
            // LineID - Line Id.
            LineID *string `json:"lineId,omitempty"`
            // StopID - The unique Azure Maps identifier for the respective public transit stop. When referring to public transit stops over time, it is recommended to use `stopId` since it will not change, as long as the physical stop exists.
            StopID *string `json:"stopId,omitempty"`
            // ScheduleTime - The date and time of departure from the stop in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
            ScheduleTime *date.Time `json:"scheduleTime,omitempty"`
            // ScheduleType - Whether the result is based on real-time or static data. Possible values include: 'ScheduledTime', 'RealTime'
            ScheduleType ScheduleType `json:"scheduleType,omitempty"`
            }

            // LineGroup a line group
            type LineGroup struct {
            // LineGroupID - Line group Id. Typically contains 2 lines having the same agency and line, one going from A to B, and the other from B to A.
            LineGroupID *string `json:"lineGroupId,omitempty"`
            // AgencyID - The Id of the transit agency, for example, '5872'.
            AgencyID *string `json:"agencyId,omitempty"`
            // AgencyName - The name of the transit agency, e.g. Metro Transit.
            AgencyName *string `json:"agencyName,omitempty"`
            // LineNumber - The transit line number.
            LineNumber *string `json:"lineNumber,omitempty"`
            // Caption1 - A descriptive string. In case caption2 is null, should be used alone as a subtitle to the line number (i.e. Circular). In case caption2 has a value present, should be used in conjunction with it (i.e. Rome ↔ Napoli).
            Caption1 *string `json:"caption1,omitempty"`
            // Caption2 - A descriptive string.
            Caption2 *string `json:"caption2,omitempty"`
            // Color - HEX color for the line.
            Color *string `json:"color,omitempty"`
            // TransitType - The public transit type of the line. Possible values include: 'TransitTypeBus', 'TransitTypeCableCar', 'TransitTypeFerry', 'TransitTypeFunicular', 'TransitTypeGondola', 'TransitTypeRail', 'TransitTypeTram', 'TransitTypeSubway'
            TransitType TransitType `json:"transitType,omitempty"`
            }

            // LinesResult the response from a successful Elevation Polyline request.
            type LinesResult struct {
            autorest.Response `json:"-"`
            Data *[]PointElevationResult `json:"data,omitempty"`
            }

            // LineString a valid `GeoJSON LineString` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details.
            type LineString struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            // Coordinates - Coordinates for the `LineString` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // LineStringData ...
            type LineStringData struct {
            // Coordinates - Coordinates for the `LineString` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // Link links to other WFS endpoints
            type Link struct {
            Href *string `json:"href,omitempty"`
            Rel *string `json:"rel,omitempty"`
            Type *string `json:"type,omitempty"`
            Hreflang *string `json:"hreflang,omitempty"`
            Title *string `json:"title,omitempty"`
            }

            // ListIanaID ...
            type ListIanaID struct {
            autorest.Response `json:"-"`
            Value *[]IanaID `json:"value,omitempty"`
            }

            // ListTimezoneEnumWindow ...
            type ListTimezoneEnumWindow struct {
            autorest.Response `json:"-"`
            Value *[]TimezoneEnumWindow `json:"value,omitempty"`
            }

            // LocalSource ...
            type LocalSource struct {
            // ID - Numeric identifier, unique to the local data provider.
            ID *int32 `json:"id,omitempty"`
            // Name - Name of the local data provider. Name is displayed in the language specified by language code in URL, if available. Otherwise, Name is displayed in English or the language in which the name was provided.
            Name *string `json:"name,omitempty"`
            // WeatherCode - Weather code provided by the local data provider. This weather code allows the forecast to be matched to icons provided by the local data provider instead of Azure Maps icons.
            WeatherCode *string `json:"weatherCode,omitempty"`
            }

            // LongRunningOperationResult the response model for a Long-Running Operations API.
            type LongRunningOperationResult struct {
            autorest.Response `json:"-"`
            // OperationID - The Id for this long-running operation.
            OperationID *string `json:"operationId,omitempty"`
            // Status - READ-ONLY; The status state of the request. Possible values include: 'NotStarted', 'Running', 'Failed', 'Succeeded'
            Status Type `json:"status,omitempty"`
            // Created - READ-ONLY; The created timestamp.
            Created *string `json:"created,omitempty"`
            // ResourceLocation - READ-ONLY; The location URI for details about the created resource. This is only provided when the request was successfully completed.
            ResourceLocation *string `json:"resourceLocation,omitempty"`
            Error *ErrorDetail `json:"error,omitempty"`
            Warning *ErrorDetail `json:"warning,omitempty"`
            }

        // MarshalJSON is the custom marshaler for LongRunningOperationResult.
        func (lror LongRunningOperationResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(lror.OperationID != nil) {
                objectMap["operationId"] = lror.OperationID
                }
                if(lror.Error != nil) {
                objectMap["error"] = lror.Error
                }
                if(lror.Warning != nil) {
                objectMap["warning"] = lror.Warning
                }
                return json.Marshal(objectMap)
        }

            // MetroAreaInfoResponse this object is returned from a successful Metro Area Info call.
            type MetroAreaInfoResponse struct {
            autorest.Response `json:"-"`
            // MetroName - The name of the metro area.
            MetroName *string `json:"metroName,omitempty"`
            // IsFaresSupported - Indicates if public transit fares information is available in the metro area. Fare information is available through [Get Transit Route API](https://aka.ms/AzureMapsMobilityTransitRoute) and [Get Transit Itinerary APIs](https://aka.ms/AzureMapsMobilityTransitItinerary).
            IsFaresSupported *string `json:"isFaresSupported,omitempty"`
            // TransitTypes - Supported transit types in the metro area. Returned if specified in the request.
            TransitTypes *[]TransitTypeResult `json:"transitTypes,omitempty"`
            Agencies *[]Agency `json:"agencies,omitempty"`
            Alerts *[]Alert `json:"alerts,omitempty"`
            }

            // MetroAreaResponse this object is returned from a successful Get Metro Area call
            type MetroAreaResponse struct {
            autorest.Response `json:"-"`
            Results *[]MetroAreaResult `json:"results,omitempty"`
            }

            // MetroAreaResult details of the metro area.
            type MetroAreaResult struct {
            // MetroID - The metro area's Id for use with other API calls.
            MetroID *int32 `json:"metroId,omitempty"`
            // MetroName - The main display name of the metro.
            MetroName *string `json:"metroName,omitempty"`
            Geometry *Polygon `json:"geometry,omitempty"`
            Viewport *ResultViewport `json:"viewport,omitempty"`
            }

            // MinuteForecastResponse ...
            type MinuteForecastResponse struct {
            autorest.Response `json:"-"`
            Summary *MinuteForecastSummary `json:"summary,omitempty"`
            // IntervalSummaries - Summary information for each interval in the forecast. The Summaries breaks down each potential interval where precipitation starts and stops.
            IntervalSummaries *[]IntervalSummary `json:"intervalSummaries,omitempty"`
            // Intervals - Forecast data for each interval in the forecast.
            Intervals *[]Interval `json:"intervals,omitempty"`
            }

            // MinuteForecastSummary phrase summaries for the entire forecast period.
            type MinuteForecastSummary struct {
            // BriefPhrase60 - Summary phrase for the next 60 minutes. Phrase length is approximately 60 characters.
            BriefPhrase60 *string `json:"briefPhrase60,omitempty"`
            // ShortPhrase - Short summary phrase for the next 120 minutes. Phrase length is approximately 25 characters.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            // BriefPhrase - Summary phrase for the next 120 minutes. Phrase length is approximately 60 characters.
            BriefPhrase *string `json:"briefPhrase,omitempty"`
            // LongPhrase - Long summary phrase for the next 120 minutes. Phrase length is 60+ characters.
            LongPhrase *string `json:"longPhrase,omitempty"`
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            }

            // MultiLineString a valid `GeoJSON MultiLineString` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.5) for details.
            type MultiLineString struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            // Coordinates - Coordinates for the `MultiLineString` geometry.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // MultiPoint a valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details.
            type MultiPoint struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            // Coordinates - Coordinates for the `MultiPoint` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // MultiPointData data contained by a `MultiPoint`.
            type MultiPointData struct {
            // Coordinates - Coordinates for the `MultiPoint` geometry.
            Coordinates *[][]float64 `json:"coordinates,omitempty"`
            }

            // MultiPointStringData ...
            type MultiPointStringData struct {
            // Type - Specifies the `type` for the geometry. Value should always be equal to "MultiLineString".
            Type *string `json:"type,omitempty"`
            // Coordinates - Coordinates for the `MultiLineString` geometry.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // MultiPolygon a valid `GeoJSON MultiPolygon` object type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.7) for details.
            type MultiPolygon struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            // Coordinates - Contains a list of valid `GeoJSON` Polygon objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Coordinates *[][][][]float64 `json:"coordinates,omitempty"`
            }

            // MultiPolygonData ...
            type MultiPolygonData struct {
            // Coordinates - Contains a list of valid `GeoJSON` Polygon objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude).
            Coordinates *[][][][]float64 `json:"coordinates,omitempty"`
            }

            // Names timezone names object.
            type Names struct {
            // ISO6391LanguageCode - READ-ONLY; The ISO 639-1 language code of the Names
            ISO6391LanguageCode *string `json:"ISO6391LanguageCode,omitempty"`
            // Generic - READ-ONLY; Generic Name
            Generic *string `json:"Generic,omitempty"`
            // Standard - READ-ONLY; Standard Name
            Standard *string `json:"Standard,omitempty"`
            // Daylight - READ-ONLY; Daylight Name
            Daylight *string `json:"Daylight,omitempty"`
            }

            // NearbyTransitResponse this object is returned from a successful Get Nearby Transit call
            type NearbyTransitResponse struct {
            autorest.Response `json:"-"`
            Results *[]TransitObjectResult `json:"results,omitempty"`
            }

            // Notification ...
            type Notification struct {
            // Type - A type of notification generated to warn drivers of the onset of a hazard, or increase in intensity of a hazard.
            Type *string `json:"type,omitempty"`
            HazardIndex *int32 `json:"hazardIndex,omitempty"`
            // HazardCode - A unique identifier (non-displayable) for each type of hazard: LightRain, ModerateRain, HeavyRain, LightMix, ModerateMix, HeavyMix, LightSnow, ModerateSnow, HeavySnow, LightIce, ModerateIce, HeavyIce, Hail, LargeHail, SunGlare, SunGlareHigh, Lightning, SevereLightning, WindModerate, WindHigh, WindExtreme, FloodWarning, FlashFloodWarning, TornadoWarning, TsunamiWarning, SevereThunderstormWarning.
            HazardCode *string `json:"hazardCode,omitempty"`
            // ShortPhrase - A displayable short phrase describing the forecasted conditions and precipitation intensity/type.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            }

            // NumberRuleObject the numeric rule
            type NumberRuleObject struct {
            Range *RangeObject `json:"range,omitempty"`
            // Color - Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255, 255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
            Color *string `json:"color,omitempty"`
            }

            // NumberTypeStyleRule the numeric type style rule object.
            type NumberTypeStyleRule struct {
            // Rules - Numeric style rules.
            Rules *[]NumberRuleObject `json:"rules,omitempty"`
            // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
            KeyName *string `json:"keyName,omitempty"`
            // Type - Possible values include: 'TypeStyleRuleBase', 'TypeBooleanTypeStyleRule', 'TypeNumberTypeStyleRule', 'TypeStringTypeStyleRule'
            Type TypeBasicStyleRuleBase `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for NumberTypeStyleRule.
        func (ntsr NumberTypeStyleRule)MarshalJSON() ([]byte, error){
            ntsr.Type = TypeNumberTypeStyleRule
            objectMap := make(map[string]interface{})
                if(ntsr.Rules != nil) {
                objectMap["rules"] = ntsr.Rules
                }
                if(ntsr.KeyName != nil) {
                objectMap["keyName"] = ntsr.KeyName
                }
                if(ntsr.Type != "") {
                objectMap["type"] = ntsr.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleRuleBase implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return nil, false
            }

            // AsNumberTypeStyleRule is the BasicStyleRuleBase implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return &ntsr, true
            }

            // AsStringTypeStyleRule is the BasicStyleRuleBase implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return nil, false
            }

            // AsStyleRuleBase is the BasicStyleRuleBase implementation for NumberTypeStyleRule.
            func (ntsr NumberTypeStyleRule) AsStyleRuleBase() (*StyleRuleBase, bool) {
                return nil, false
            }

                // AsBasicStyleRuleBase is the BasicStyleRuleBase implementation for NumberTypeStyleRule.
                func(ntsr NumberTypeStyleRule) AsBasicStyleRuleBase()(BasicStyleRuleBase, bool) {
                    return &ntsr, true
                }


            // Pattern stop-shape-segments of the trip pattern, which are an ordered list of the stops and the shapes
            // connecting them.
            type Pattern struct {
            // PatternID - Pattern Id, for example, '3267995'.
            PatternID *string `json:"patternId,omitempty"`
            // LineID - Line Id.
            LineID *string `json:"lineId,omitempty"`
            // StopIds - Stops the line goes through.
            StopIds *[]string `json:"stopIds,omitempty"`
            // Geometry - Stop sequence and shape per a line in GeoJSON format.
            Geometry *LineString `json:"geometry,omitempty"`
            }

            // PoiCategoryResponse this object is returned from a successful POI Category Tree call
            type PoiCategoryResponse struct {
            autorest.Response `json:"-"`
            // PoiCategories - READ-ONLY; Categories array
            PoiCategories *[]PoiCategoryResult `json:"poiCategories,omitempty"`
            }

            // PoiCategoryResult POI category result
            type PoiCategoryResult struct {
            // ID - READ-ONLY; Unique ID for the category. ID can be used to restrict search results to specific categories through other Search Service APIs, like [Get Search POI](https://docs.microsoft.com/rest/api/maps/search/getsearchpoi).
            ID *int32 `json:"id,omitempty"`
            // Name - READ-ONLY; Name of the category
            Name *string `json:"name,omitempty"`
            // ChildCategoryIds - READ-ONLY; Array of child category ids
            ChildCategoryIds *[]int32 `json:"childCategoryIds,omitempty"`
            // Synonyms - READ-ONLY; Array of alternative names of the category
            Synonyms *[]string `json:"synonyms,omitempty"`
            }

            // Point a valid `GeoJSON Point` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details.
            type Point struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            Coordinates *[]float64 `json:"coordinates,omitempty"`
            }

            // PointArray ...
            type PointArray struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection.
            Type *string `json:"type,omitempty"`
            Geometries *[]Point `json:"geometries,omitempty"`
            }

            // PointData data contained by a `Point`.
            type PointData struct {
            Coordinates *[]float64 `json:"coordinates,omitempty"`
            }

            // PointElevationResult the elevation data.
            type PointElevationResult struct {
            Coordinate *Coordinate `json:"coordinate,omitempty"`
            // ElevationInMeter - READ-ONLY; The elevation value in meters.
            ElevationInMeter *float64 `json:"elevationInMeter,omitempty"`
            }

        // MarshalJSON is the custom marshaler for PointElevationResult.
        func (per PointElevationResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(per.Coordinate != nil) {
                objectMap["coordinate"] = per.Coordinate
                }
                return json.Marshal(objectMap)
        }

            // PointInPolygonResult point In Polygon Result Object
            type PointInPolygonResult struct {
            // PointInPolygons - READ-ONLY; Point In Polygons Property
            PointInPolygons *bool `json:"pointInPolygons,omitempty"`
            // IntersectingGeometries - READ-ONLY; Geometries array
            IntersectingGeometries *[]string `json:"intersectingGeometries,omitempty"`
            }

            // PointsResult the response from a successful Elevation Points request.
            type PointsResult struct {
            autorest.Response `json:"-"`
            Data *[]PointElevationResult `json:"data,omitempty"`
            }

            // Pollutant detailed information about an individual pollutant. Not returned if `pollutants`=false.
            type Pollutant struct {
            // Type - Type of pollutant. Please note that more may be added at any time. Possible values include: 'CO', 'NO2', 'O3', 'PM25', 'PM10', 'SO2'
            Type PollutantType `json:"type,omitempty"`
            // Name - The name of the pollutant in English.
            Name *string `json:"name,omitempty"`
            // Index - Air quality rating on a scale set by local regulating bodies. Scales can vary widely based on location. See [Wikipedia](https://en.wikipedia.org/wiki/Air_quality_index) for more information.
            Index *float64 `json:"index,omitempty"`
            // GlobalIndex - Internationally normalized air quality rating on a scale from 0 to 300 and up, with higher numbers representing worse air quality.
            GlobalIndex *float64 `json:"globalIndex,omitempty"`
            // Concentration - An object containing the number of pollutant particles per volume of air.
            Concentration *Concentration `json:"concentration,omitempty"`
            }

            // Polygon a valid `GeoJSON Polygon` geometry type. Please refer to [RFC
            // 7946](https://tools.ietf.org/html/rfc7946#section-3.1.6) for details.
            type Polygon struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Possible values include: 'GeoJSONGeometryTypePoint', 'GeoJSONGeometryTypeMultiPoint', 'GeoJSONGeometryTypeLineString', 'GeoJSONGeometryTypeMultiLineString', 'GeoJSONGeometryTypePolygon', 'GeoJSONGeometryTypeMultiPolygon', 'GeoJSONGeometryTypeGeometryCollection'
            Type GeoJSONGeometryType `json:"type,omitempty"`
            // Coordinates - Coordinates for the `Polygon` geometry type.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // PolygonData ...
            type PolygonData struct {
            // Coordinates - Coordinates for the `Polygon` geometry type.
            Coordinates *[][][]float64 `json:"coordinates,omitempty"`
            }

            // PostClosestPointResponse this object is returned from a successful Post Spatial Closest Point call
            type PostClosestPointResponse struct {
            autorest.Response `json:"-"`
            Summary *PostClosestPointSummary `json:"summary,omitempty"`
            Result *[]ClosestPointResultEntry `json:"result,omitempty"`
            }

            // PostClosestPointSummary post Closest Point Summary object
            type PostClosestPointSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content. Udid is not applicable for POST spatial operations(set to null)
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; Processing information
            Information *string `json:"information,omitempty"`
            }

        // MarshalJSON is the custom marshaler for PostClosestPointSummary.
        func (pcps PostClosestPointSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(pcps.SourcePoint != nil) {
                objectMap["sourcePoint"] = pcps.SourcePoint
                }
                return json.Marshal(objectMap)
        }

            // PostPointInPolygonResponse returns true if point is within the polygon, false otherwise
            type PostPointInPolygonResponse struct {
            autorest.Response `json:"-"`
            Summary *PostPointInPolygonSummary `json:"summary,omitempty"`
            Result *PointInPolygonResult `json:"result,omitempty"`
            }

            // PostPointInPolygonSummary point In Polygon Summary object
            type PostPointInPolygonSummary struct {
            SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content. Udid is not applicable for POST spatial operations(set to null)
            Udid *string `json:"udid,omitempty"`
            // Information - READ-ONLY; Processing information
            Information *string `json:"information,omitempty"`
            }

        // MarshalJSON is the custom marshaler for PostPointInPolygonSummary.
        func (ppips PostPointInPolygonSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ppips.SourcePoint != nil) {
                objectMap["sourcePoint"] = ppips.SourcePoint
                }
                return json.Marshal(objectMap)
        }

            // PrecipitationSummary ...
            type PrecipitationSummary struct {
            // PastHour - The amount of precipitation (liquid equivalent) that has fallen in the past hour.
            PastHour *WeatherUnit `json:"pastHour,omitempty"`
            // Past3Hours - The amount of precipitation (liquid equivalent) that has fallen in the past three hours.
            Past3Hours *WeatherUnit `json:"past3Hours,omitempty"`
            // Past6Hours - The amount of precipitation (liquid equivalent) that has fallen in the past six hours. Contains Metric and Imperial Values.
            Past6Hours *WeatherUnit `json:"past6Hours,omitempty"`
            // Past9Hours - The amount of precipitation (liquid equivalent) that has fallen in the past nine hours.
            Past9Hours *WeatherUnit `json:"past9Hours,omitempty"`
            // Past12Hours - The amount of precipitation (liquid equivalent) that has fallen in the past 12 hours.
            Past12Hours *WeatherUnit `json:"past12Hours,omitempty"`
            // Past18Hours - The amount of precipitation (liquid equivalent) that has fallen in the past 18 hours.
            Past18Hours *WeatherUnit `json:"past18Hours,omitempty"`
            // Past24Hours - The amount of precipitation (liquid equivalent) that has fallen in the past 24 hours.
            Past24Hours *WeatherUnit `json:"past24Hours,omitempty"`
            }

            // PressureTendency ...
            type PressureTendency struct {
            // LocalizedDescription - Description of the pressure tendency in specified language
            LocalizedDescription *string `json:"localizedDescription,omitempty"`
            // Code - Pressure tendency code regardless of language. One of F=Falling, S=Steady, R=Rising.
            Code *string `json:"code,omitempty"`
            }

            // Price ...
            type Price struct {
            // Amount - Price of the ticket in cents. For example, $5.00 is returned as ‘500’.
            Amount *int32 `json:"amount,omitempty"`
            // CurrencyCode - Currency code, for example for US dollars “USD”.
            CurrencyCode *string `json:"currencyCode,omitempty"`
            }

            // QuarterDayForecast ...
            type QuarterDayForecast struct {
            // Date - Date and time of the forecast in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            Date *string `json:"date,omitempty"`
            // EffectiveDate - Date and time of the beginning of the forecast quarter displayed in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
            EffectiveDate *string `json:"effectiveDate,omitempty"`
            // Quarter - Quarter of the day.
            Quarter *int32 `json:"quarter,omitempty"`
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            // IconPhrase - Phrase description of the icon. Displayed in specified language. For example, 'Sunny'.
            IconPhrase *string `json:"iconPhrase,omitempty"`
            // Phrase - Short summary phrase summary for quarter.
            Phrase *string `json:"phrase,omitempty"`
            // Temperature - Temperature values for the quarter.
            Temperature *WeatherUnitRange `json:"temperature,omitempty"`
            // RealFeelTemperature - RealFeel™ Temperature values for the quarter.
            RealFeelTemperature *WeatherUnitRange `json:"realFeelTemperature,omitempty"`
            // DewPoint - The dewpoint temperature in specified unit. The dewpoint temperature is the temperature that the air must be cooled to in order to reach saturation.
            DewPoint *WeatherUnit `json:"dewPoint,omitempty"`
            // RelativeHumidity - Relative humidity is the amount of water vapor present in air expressed as a percentage of the amount needed for saturation at the same temperature.
            RelativeHumidity *int32 `json:"relativeHumidity,omitempty"`
            // Wind - Wind details being returned including speed and direction.
            Wind *Wind `json:"wind,omitempty"`
            // WindGust - Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
            WindGust *Wind `json:"windGust,omitempty"`
            // Visibility - Visibility in specified unit. A measure of the distance at which an object or light can be clearly discerned.
            Visibility *WeatherUnit `json:"visibility,omitempty"`
            // CloudCover - Percent representing cloud cover.
            CloudCover *int32 `json:"cloudCover,omitempty"`
            // HasPrecipitation - Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates the absence of precipitation.
            HasPrecipitation *bool `json:"hasPrecipitation,omitempty"`
            // PrecipitationType - Specifies the type of precipitation ("rain" "snow" "ice" or "mix"). If dbz = zero, precipitationType is not present in the response.
            PrecipitationType *string `json:"precipitationType,omitempty"`
            // PrecipitationIntensity - Description of the intensity.
            PrecipitationIntensity *string `json:"precipitationIntensity,omitempty"`
            // PrecipitationProbability - Percent representing the probability of precipitation. For example, '20'.
            PrecipitationProbability *int32 `json:"precipitationProbability,omitempty"`
            // ThunderstormProbability - Percent representing the probability of a thunderstorm. For example, '10'.
            ThunderstormProbability *int32 `json:"thunderstormProbability,omitempty"`
            // TotalLiquid - Total liquid equivalent of precipitation during the forecast period.
            TotalLiquid *WeatherUnit `json:"totalLiquid,omitempty"`
            // Rain - Rain
            Rain *WeatherUnit `json:"rain,omitempty"`
            // Snow - Snow
            Snow *WeatherUnit `json:"snow,omitempty"`
            // Ice - Ice
            Ice *WeatherUnit `json:"ice,omitempty"`
            }

            // QuarterDayForecastResponse ...
            type QuarterDayForecastResponse struct {
            autorest.Response `json:"-"`
            // Forecasts - Forecast data for each quarter in the response.
            Forecasts *[]QuarterDayForecast `json:"forecasts,omitempty"`
            }

            // RangeObject the numeric value range for this style rule, If the value is in the range, all the
            // conditions must hold true.
            type RangeObject struct {
            // Minimum - All the number x that x ≥ minimum.
            Minimum *float64 `json:"minimum,omitempty"`
            // Maximum - All the number x that x ≤ maximum.
            Maximum *float64 `json:"maximum,omitempty"`
            // ExclusiveMinimum - All the number x that x > exclusiveMinimum.
            ExclusiveMinimum *float64 `json:"exclusiveMinimum,omitempty"`
            // ExclusiveMaximum - All the number x that x < exclusiveMaximum.
            ExclusiveMaximum *float64 `json:"exclusiveMaximum,omitempty"`
            }

            // ReadCloser ...
            type ReadCloser struct {
            autorest.Response `json:"-"`
            Value *io.ReadCloser `json:"value,omitempty"`
            }

            // RealTimeArrivalResult contains real-time arrival related details.
            type RealTimeArrivalResult struct {
            // ArrivalMinutes - The estimated time of arrival in minutes.
            ArrivalMinutes *int32 `json:"arrivalMinutes,omitempty"`
            // ScheduleType - Whether the result is based on real-time or static data. Possible values include: 'ScheduledTime', 'RealTime'
            ScheduleType ScheduleType `json:"scheduleType,omitempty"`
            // PatternID - The pattern Id.
            PatternID *string `json:"patternId,omitempty"`
            // Line - The public transit type of the line.
            Line *Line `json:"line,omitempty"`
            // Stop - Object for the given stop.
            Stop *Stop `json:"stop,omitempty"`
            }

            // RealTimeArrivalsResponse this object is returned from a successful Get Real Time Arrival Info call.
            type RealTimeArrivalsResponse struct {
            autorest.Response `json:"-"`
            // Results - Results array. Contains results related details.
            Results *[]RealTimeArrivalResult `json:"results,omitempty"`
            }

            // ReferenceTimeByCoordinates details in effect at the local time.
            type ReferenceTimeByCoordinates struct {
            // Tag - READ-ONLY; Time zone name in effect at the reference timestamp (i.e. PST or PDT depending whether Daylight Savings Time is in effect).
            Tag *string `json:"Tag,omitempty"`
            // StandardOffset - READ-ONLY; UTC offset in effect at the `ReferenceUTCTimestamp`.
            StandardOffset *string `json:"StandardOffset,omitempty"`
            // DaylightSavings - READ-ONLY; Time saving in minutes in effect at the `ReferenceUTCTimestamp`.
            DaylightSavings *string `json:"DaylightSavings,omitempty"`
            // WallTime - READ-ONLY; Current wall time at the given time zone as shown in the `Tag` property.
            WallTime *string `json:"WallTime,omitempty"`
            // PosixTzValidYear - READ-ONLY; The year this POSIX string is valid for. Note: A POSIX string will only be valid in the given year.
            PosixTzValidYear *int32 `json:"PosixTzValidYear,omitempty"`
            // PosixTz - READ-ONLY; POSIX string used to set the time zone environment variable.
            PosixTz *string `json:"PosixTz,omitempty"`
            // Sunrise - READ-ONLY; Sunrise at the given time zone as shown in the `Tag` property.
            Sunrise *string `json:"Sunrise,omitempty"`
            // Sunset - READ-ONLY; Sunset at the given time zone as shown in the `Tag` property.
            Sunset *string `json:"Sunset,omitempty"`
            }

            // ReferenceTimeByID details in effect at the local time.
            type ReferenceTimeByID struct {
            // Tag - READ-ONLY; Time zone name in effect at the reference timestamp (i.e. PST or PDT depending whether Daylight Savings Time is in effect).
            Tag *string `json:"Tag,omitempty"`
            // StandardOffset - READ-ONLY; UTC offset in effect at the `ReferenceUTCTimestamp`.
            StandardOffset *string `json:"StandardOffset,omitempty"`
            // DaylightSavings - READ-ONLY; Time saving in minutes in effect at the `ReferenceUTCTimestamp`.
            DaylightSavings *string `json:"DaylightSavings,omitempty"`
            // WallTime - READ-ONLY; Current wall time at the given time zone as shown in the `Tag` property.
            WallTime *string `json:"WallTime,omitempty"`
            // PosixTzValidYear - READ-ONLY; The year this POSIX string is valid for. Note: A POSIX string will only be valid in the given year.
            PosixTzValidYear *int32 `json:"PosixTzValidYear,omitempty"`
            // PosixTz - READ-ONLY; POSIX string used to set the time zone environment variable.
            PosixTz *string `json:"PosixTz,omitempty"`
            }

            // Region ...
            type Region struct {
            // Copyrights - READ-ONLY; Copyrights array
            Copyrights *[]string `json:"copyrights,omitempty"`
            // Country - READ-ONLY; Country property
            Country *RegionCountry `json:"country,omitempty"`
            }

            // RegionCountry country property
            type RegionCountry struct {
            // ISO3 - READ-ONLY; ISO3 property
            ISO3 *string `json:"ISO3,omitempty"`
            // Label - READ-ONLY; Label property
            Label *string `json:"label,omitempty"`
            }

            // RepresentativePoint representative point property
            type RepresentativePoint struct {
            // Latitude - READ-ONLY; Latitude property
            Latitude *float64 `json:"Latitude,omitempty"`
            // Longitude - READ-ONLY; Longitude property
            Longitude *float64 `json:"Longitude,omitempty"`
            }

            // ReqClasses ...
            type ReqClasses struct {
            autorest.Response `json:"-"`
            ConformsTo *[]string `json:"conformsTo,omitempty"`
            }

            // ResultViewport the viewport that covers the result represented by the top-left and bottom-right
            // coordinates of the  viewport.
            type ResultViewport struct {
            TopLeftPoint *Coordinate `json:"topLeftPoint,omitempty"`
            BtmRightPoint *Coordinate `json:"btmRightPoint,omitempty"`
            }

            // Root ...
            type Root struct {
            autorest.Response `json:"-"`
            Links *[]Link `json:"links,omitempty"`
            }

            // RouteDirectionsRequestBody post body parameters for Route directions.
            type RouteDirectionsRequestBody struct {
            // SupportingPoints - A GeoJSON Geometry collection representing sequence of coordinates used as input for route reconstruction and for calculating zero or more alternative routes to this reference route.
            //   - The provided sequence of supporting points is used as input for route reconstruction.
            //   - The alternative routes are calculated between the origin and destination points specified in the base path parameter locations.
            //   - If both _minDeviationDistance_ and _minDeviationTime_ are set to zero, then these origin and destination points are
            //   expected to be at (or very near) the beginning and end of the reference route, respectively.
            //   - Intermediate locations (_waypoints_) are not supported when using <_supportingPoints_>.
            //   - The reference route may contain traffic incidents of type _ROAD_CLOSURE_, which are
            //   ignored for the calculation of the reference route's travel time and traffic delay.
            SupportingPoints *RouteDirectionsRequestBodySupportingPoints `json:"supportingPoints,omitempty"`
            // AvoidVignette - This is a list of 3-character, ISO 3166-1, alpha-3 country codes of countries in which all toll roads with vignettes are to be avoided, e.g. "AUS,CHE". Toll roads with vignettes in countries not in the list are unaffected. Note: It is an error to specify both **avoidVignette** and **allowVignette**.
            AvoidVignette *[]string `json:"avoidVignette,omitempty"`
            // AllowVignette - This is a list of 3-character, ISO 3166-1, alpha-3 country codes of countries in which toll roads with vignettes are allowed, e.g. "AUS,CHE". Specifying **allowVignette** with some countries X is equivalent to specifying **avoidVignette** with all countries but X. Specifying **allowVignette** with an empty list is the same as avoiding all toll roads with vignettes. Note: It is an error to specify both **avoidVignette** and **allowVignette**.
            AllowVignette *[]string `json:"allowVignette,omitempty"`
            // AvoidAreas - A GeoJSON MultiPolygon representing list of areas to avoid. Only rectangle polygons are supported. The maximum size of a rectangle is about 160x160 km. Maximum number of avoided areas is **10**. It cannot cross the 180th meridian. It must be between -80 and +80 degrees of latitude.
            AvoidAreas *MultiPolygon `json:"avoidAreas,omitempty"`
            }

            // RouteDirectionsRequestBodySupportingPoints a GeoJSON Geometry collection representing sequence of
            // coordinates used as input for route reconstruction and for calculating zero or more alternative routes
            // to this reference route.
            // - The provided sequence of supporting points is used as input for route reconstruction.
            // - The alternative routes are calculated between the origin and destination points specified in the base
            // path parameter locations.
            // - If both _minDeviationDistance_ and _minDeviationTime_ are set to zero, then these origin and
            // destination points are
            // expected to be at (or very near) the beginning and end of the reference route, respectively.
            // - Intermediate locations (_waypoints_) are not supported when using <_supportingPoints_>.
            // - The reference route may contain traffic incidents of type _ROAD_CLOSURE_, which are
            // ignored for the calculation of the reference route's travel time and traffic delay.
            type RouteDirectionsRequestBodySupportingPoints struct {
            // Type - Specifies the `GeoJSON` geometry type. Must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection.
            Type *string `json:"type,omitempty"`
            Geometries *[]Point `json:"geometries,omitempty"`
            }

            // RouteDirectionsResponse this object is returned from a successful Route Directions call
            type RouteDirectionsResponse struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            // Routes - READ-ONLY; Routes array
            Routes *[]RouteDirectionsResult `json:"routes,omitempty"`
            // OptimizedWaypoints - READ-ONLY; Optimized sequence of waypoints. It shows the index from the user provided waypoint sequence for the original and optimized list. For instance, a response:
            // ```
            // <optimizedWaypoints>
            // <waypoint providedIndex="0" optimizedIndex="1"/>
            // <waypoint providedIndex="1" optimizedIndex="2"/>
            // <waypoint providedIndex="2" optimizedIndex="0"/>
            // </optimizedWaypoints>
            // ```
            // means that the original sequence is [0, 1, 2] and optimized sequence is [1, 2, 0]. Since the index starts by 0 the original is "first, second, third" while the optimized is "second, third, first".
            OptimizedWaypoints *[]RouteOptimizedWaypoint `json:"optimizedWaypoints,omitempty"`
            Report *RouteResponseReport `json:"report,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteDirectionsResponse.
        func (rdr RouteDirectionsResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rdr.Report != nil) {
                objectMap["report"] = rdr.Report
                }
                return json.Marshal(objectMap)
        }

            // RouteDirectionsResult ...
            type RouteDirectionsResult struct {
            Summary *RouteDirectionsSummary `json:"summary,omitempty"`
            // Legs - READ-ONLY; Legs array
            Legs *[]RouteResultLeg `json:"legs,omitempty"`
            // Sections - READ-ONLY; Sections array
            Sections *[]RouteResultSection `json:"sections,omitempty"`
            Guidance *RouteResultGuidance `json:"guidance,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteDirectionsResult.
        func (rdr RouteDirectionsResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rdr.Summary != nil) {
                objectMap["summary"] = rdr.Summary
                }
                if(rdr.Guidance != nil) {
                objectMap["guidance"] = rdr.Guidance
                }
                return json.Marshal(objectMap)
        }

            // RouteDirectionsSummary summary object
            type RouteDirectionsSummary struct {
            // LengthInMeters - READ-ONLY; Length In Meters property
            LengthInMeters *int32 `json:"lengthInMeters,omitempty"`
            // TravelTimeInSeconds - READ-ONLY; Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
            TravelTimeInSeconds *int32 `json:"travelTimeInSeconds,omitempty"`
            // TrafficDelayInSeconds - READ-ONLY; Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
            TrafficDelayInSeconds *int32 `json:"trafficDelayInSeconds,omitempty"`
            // DepartureTime - READ-ONLY; Departure Time property
            DepartureTime *string `json:"departureTime,omitempty"`
            // ArrivalTime - READ-ONLY; Arrival Time property
            ArrivalTime *string `json:"arrivalTime,omitempty"`
            }

            // RouteItineraryLeg ...
            type RouteItineraryLeg struct {
            // LegType - The travel mode of the leg. Possible values include: 'Walk', 'Bicycle', 'Tram', 'Subway', 'Rail', 'Bus', 'Ferry', 'Cable', 'Gondola', 'Funicular', 'PathWayWalk', 'Wait', 'WaitOnVehicle'
            LegType LegType `json:"legType,omitempty"`
            // LegFare - Leg level public transit fare information. Returned only if fare information is available for the entire itinerary.
            LegFare *LegFare `json:"legFare,omitempty"`
            // LegStartTime - Start time for the leg in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
            LegStartTime *string `json:"legStartTime,omitempty"`
            // LegEndTime - End time for the leg in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
            LegEndTime *string `json:"legEndTime,omitempty"`
            // Caption - For Public Transit legs the caption of the line serving the leg, for example, line number.
            Caption *string `json:"caption,omitempty"`
            // LengthInMeters - The total distance of the leg in meters.
            LengthInMeters *int32 `json:"lengthInMeters,omitempty"`
            }

            // RouteMatrixRequestBody an object with a matrix of coordinates.
            type RouteMatrixRequestBody struct {
            Origins *MultiPoint `json:"origins,omitempty"`
            Destinations *MultiPoint `json:"destinations,omitempty"`
            }

            // RouteMatrixResponse this object is returned from a successful Route Matrix call. For ex, if 2 origins
            // and 3 destinations are provided, there are going to 2 arrays with 3 elements in each. Each element's
            // content depends on the options provided in the query.
            type RouteMatrixResponse struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            // Matrix - READ-ONLY; Results as a 2 dimensional array of route summaries.
            Matrix *[][]RouteMatrixResult `json:"matrix,omitempty"`
            Summary *RouteMatrixSummary `json:"summary,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteMatrixResponse.
        func (rmr RouteMatrixResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rmr.Summary != nil) {
                objectMap["summary"] = rmr.Summary
                }
                return json.Marshal(objectMap)
        }

            // RouteMatrixResult matrix result object
            type RouteMatrixResult struct {
            // StatusCode - READ-ONLY; StatusCode property for the current cell in the input matrix.
            StatusCode *int32 `json:"statusCode,omitempty"`
            Response *RouteMatrixResultResponse `json:"response,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteMatrixResult.
        func (rmr RouteMatrixResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rmr.Response != nil) {
                objectMap["response"] = rmr.Response
                }
                return json.Marshal(objectMap)
        }

            // RouteMatrixResultResponse response object of the current cell in the input matrix.
            type RouteMatrixResultResponse struct {
            RouteSummary *RouteResultLegSummary `json:"routeSummary,omitempty"`
            }

            // RouteMatrixSummary summary object
            type RouteMatrixSummary struct {
            // SuccessfulRoutes - READ-ONLY; Number of successful routes in the response.
            SuccessfulRoutes *int32 `json:"successfulRoutes,omitempty"`
            // TotalRoutes - READ-ONLY; Total number of routes requested. Number of cells in the input matrix.
            TotalRoutes *int32 `json:"totalRoutes,omitempty"`
            }

            // RouteOptimizedWaypoint optimized way point object.
            type RouteOptimizedWaypoint struct {
            // ProvidedIndex - READ-ONLY; Way point index provided by the user.
            ProvidedIndex *int32 `json:"providedIndex,omitempty"`
            // OptimizedIndex - READ-ONLY; Optimized way point index from the system.
            OptimizedIndex *int32 `json:"optimizedIndex,omitempty"`
            }

            // RoutePostRouteDirectionsBatchFuture an abstraction for monitoring and retrieving the results of a
            // long-running operation.
            type RoutePostRouteDirectionsBatchFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(RouteClient) (BatchResponse, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *RoutePostRouteDirectionsBatchFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for RoutePostRouteDirectionsBatchFuture.Result.
        func (future *RoutePostRouteDirectionsBatchFuture) result(client RouteClient) (br BatchResponse, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.RoutePostRouteDirectionsBatchFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.RoutePostRouteDirectionsBatchFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if br.Response.Response, err = future.GetResult(sender); err == nil && br.Response.Response.StatusCode != http.StatusNoContent {
            br, err = client.PostRouteDirectionsBatchResponder(br.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.RoutePostRouteDirectionsBatchFuture", "Result", br.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // RoutePostRouteMatrixFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type RoutePostRouteMatrixFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(RouteClient) (RouteMatrixResponse, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *RoutePostRouteMatrixFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for RoutePostRouteMatrixFuture.Result.
        func (future *RoutePostRouteMatrixFuture) result(client RouteClient) (rmr RouteMatrixResponse, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.RoutePostRouteMatrixFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.RoutePostRouteMatrixFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if rmr.Response.Response, err = future.GetResult(sender); err == nil && rmr.Response.Response.StatusCode != http.StatusNoContent {
            rmr, err = client.PostRouteMatrixResponder(rmr.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.RoutePostRouteMatrixFuture", "Result", rmr.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // RouteRange reachable Range
            type RouteRange struct {
            // Center - Center point of the reachable range
            Center *Coordinate `json:"center,omitempty"`
            // Boundary - READ-ONLY; Polygon boundary of the reachable range represented as a list of points.
            Boundary *[]Coordinate `json:"boundary,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteRange.
        func (rr RouteRange)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rr.Center != nil) {
                objectMap["center"] = rr.Center
                }
                return json.Marshal(objectMap)
        }

            // RouteRangeResponse this object is returned from a successful Route Reachable Range call
            type RouteRangeResponse struct {
            autorest.Response `json:"-"`
            // FormatVersion - READ-ONLY; Format Version property
            FormatVersion *string `json:"formatVersion,omitempty"`
            ReachableRange *RouteRange `json:"reachableRange,omitempty"`
            Report *RouteResponseReport `json:"report,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteRangeResponse.
        func (rrr RouteRangeResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rrr.ReachableRange != nil) {
                objectMap["reachableRange"] = rrr.ReachableRange
                }
                if(rrr.Report != nil) {
                objectMap["report"] = rrr.Report
                }
                return json.Marshal(objectMap)
        }

            // RouteResponseReport reports the effective settings used in the current call.
            type RouteResponseReport struct {
            // EffectiveSettings - READ-ONLY; Effective parameters or data used when calling this Route API.
            EffectiveSettings *[]RouteResponseReportEffectiveSetting `json:"effectiveSettings,omitempty"`
            }

            // RouteResponseReportEffectiveSetting effective parameter or data used when calling this Route API.
            type RouteResponseReportEffectiveSetting struct {
            // Key - READ-ONLY; Name of the parameter used.
            Key *string `json:"key,omitempty"`
            // Value - READ-ONLY; Value of the parameter used.
            Value *string `json:"value,omitempty"`
            }

            // RouteResultGuidance contains guidance related elements. This field is present only when guidance was
            // requested and is available.
            type RouteResultGuidance struct {
            // Instructions - READ-ONLY; A list of instructions describing maneuvers.
            Instructions *[]RouteResultInstruction `json:"instructions,omitempty"`
            // InstructionGroups - READ-ONLY; Groups a sequence of instruction elements which are related to each other.
            InstructionGroups *[]RouteResultInstructionGroup `json:"instructionGroups,omitempty"`
            }

            // RouteResultInstruction a set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take
            // the ferry', 'Take the motorway', 'Arrive'.
            type RouteResultInstruction struct {
            // RouteOffsetInMeters - READ-ONLY; Distance from the start of the route to the point of the instruction.
            RouteOffsetInMeters *int32 `json:"routeOffsetInMeters,omitempty"`
            // TravelTimeInSeconds - READ-ONLY; Estimated travel time up to the point corresponding to routeOffsetInMeters.
            TravelTimeInSeconds *int32 `json:"travelTimeInSeconds,omitempty"`
            Point *Coordinate `json:"point,omitempty"`
            // PointIndex - READ-ONLY; The index of the point in the list of polyline "points" corresponding to the point of the instruction.
            PointIndex *int32 `json:"pointIndex,omitempty"`
            // InstructionType - Type of the instruction, e.g., turn or change of road form. Possible values include: 'TURN', 'ROADCHANGE', 'LOCATIONDEPARTURE', 'LOCATIONARRIVAL', 'DIRECTIONINFO', 'LOCATIONWAYPOINT'
            InstructionType GuidanceInstructionType `json:"instructionType,omitempty"`
            // RoadNumbers - READ-ONLY; The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed. Example: ["E34", "N205"]
            RoadNumbers *[]string `json:"roadNumbers,omitempty"`
            // ExitNumber - READ-ONLY; The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
            ExitNumber *string `json:"exitNumber,omitempty"`
            // Street - READ-ONLY; Street name of the next significant road segment after the maneuver, or of the street that should be followed.
            Street *string `json:"street,omitempty"`
            // SignpostText - READ-ONLY; The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed.
            SignpostText *string `json:"signpostText,omitempty"`
            // CountryCode - READ-ONLY; 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA.
            CountryCode *string `json:"countryCode,omitempty"`
            // StateCode - READ-ONLY; A subdivision (e.g., state) of the country, represented by the second part of an [ISO 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries like the US, Canada, and Mexico.
            StateCode *string `json:"stateCode,omitempty"`
            // JunctionType - READ-ONLY; The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout. Possible values include: 'REGULAR', 'ROUNDABOUT', 'BIFURCATION'
            JunctionType JunctionType `json:"junctionType,omitempty"`
            // TurnAngleInDecimalDegrees - READ-ONLY; Indicates the direction of an instruction. If junctionType indicates a turn instruction:
            //   * 180 = U-turn
            //   * [-179, -1] = Left turn
            //   * 0 = Straight on (a '0 degree' turn)
            //   * [1, 179] = Right turn
            // If junctionType indicates a bifurcation instruction:
            //   * <0 - keep left
            //   * \>0 - keep right
            TurnAngleInDecimalDegrees *int32 `json:"turnAngleInDecimalDegrees,omitempty"`
            // RoundaboutExitNumber - READ-ONLY; This indicates which exit to take at a roundabout.
            RoundaboutExitNumber *string `json:"roundaboutExitNumber,omitempty"`
            // PossibleCombineWithNext - READ-ONLY; It is possible to optionally combine the instruction with the next one. This can be used to build messages like "Turn left and then turn right".
            PossibleCombineWithNext *bool `json:"possibleCombineWithNext,omitempty"`
            // DrivingSide - READ-ONLY; Indicates left-hand vs. right-hand side driving at the point of the maneuver. Possible values include: 'LEFT', 'RIGHT'
            DrivingSide DrivingSide `json:"drivingSide,omitempty"`
            // Maneuver - READ-ONLY; A code identifying the maneuver. Possible values include: 'ARRIVE', 'ARRIVELEFT', 'ARRIVERIGHT', 'DEPART', 'STRAIGHT', 'KEEPRIGHT', 'BEARRIGHT', 'TURNRIGHT', 'SHARPRIGHT', 'KEEPLEFT', 'BEARLEFT', 'TURNLEFT', 'SHARPLEFT', 'MAKEUTURN', 'ENTERMOTORWAY', 'ENTERFREEWAY', 'ENTERHIGHWAY', 'TAKEEXIT', 'MOTORWAYEXITLEFT', 'MOTORWAYEXITRIGHT', 'TAKEFERRY', 'ROUNDABOUTCROSS', 'ROUNDABOUTRIGHT', 'ROUNDABOUTLEFT', 'ROUNDABOUTBACK', 'TRYMAKEUTURN', 'FOLLOW', 'SWITCHPARALLELROAD', 'SWITCHMAINROAD', 'ENTRANCERAMP', 'WAYPOINTLEFT', 'WAYPOINTRIGHT', 'WAYPOINTREACHED'
            Maneuver GuidanceManeuver `json:"maneuver,omitempty"`
            // Message - READ-ONLY; A human-readable message for the maneuver.
            Message *string `json:"message,omitempty"`
            // CombinedMessage - READ-ONLY; A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is possible to combine two successive instructions into a single instruction making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
            // ```
            // 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
            // 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
            // ```
            // The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that it can be combined with instruction 11. The instructions will be combined automatically for clients requesting human-readable guidance. The combinedMessage field contains the combined message:
            // ```
            // Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
            // then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
            // ```
            CombinedMessage *string `json:"combinedMessage,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteResultInstruction.
        func (rri RouteResultInstruction)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rri.Point != nil) {
                objectMap["point"] = rri.Point
                }
                if(rri.InstructionType != "") {
                objectMap["instructionType"] = rri.InstructionType
                }
                return json.Marshal(objectMap)
        }

            // RouteResultInstructionGroup groups a sequence of instruction elements which are related to each other.
            // The sequence range is constrained with firstInstructionIndex and lastInstructionIndex. When
            // human-readable text messages are requested for guidance (instructionType=text or tagged), then the
            // instructionGroup has a summary message returned when available.
            type RouteResultInstructionGroup struct {
            // FirstInstructionIndex - READ-ONLY; Index of the first instruction.
            FirstInstructionIndex *int32 `json:"firstInstructionIndex,omitempty"`
            // LastInstructionIndex - READ-ONLY; Index of the last instruction.
            LastInstructionIndex *int32 `json:"lastInstructionIndex,omitempty"`
            // GroupLengthInMeters - READ-ONLY; Length of the group.
            GroupLengthInMeters *int32 `json:"groupLengthInMeters,omitempty"`
            // GroupMessage - READ-ONLY; Summary message when human-readable text messages are requested for guidance (instructionType=text or tagged).
            GroupMessage *string `json:"groupMessage,omitempty"`
            }

            // RouteResultLeg ...
            type RouteResultLeg struct {
            Summary *RouteResultLegSummary `json:"summary,omitempty"`
            // Points - READ-ONLY; Points array
            Points *[]Coordinate `json:"points,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteResultLeg.
        func (rrl RouteResultLeg)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rrl.Summary != nil) {
                objectMap["summary"] = rrl.Summary
                }
                return json.Marshal(objectMap)
        }

            // RouteResultLegSummary summary object for route section.
            type RouteResultLegSummary struct {
            // LengthInMeters - READ-ONLY; Length In Meters property
            LengthInMeters *int32 `json:"lengthInMeters,omitempty"`
            // TravelTimeInSeconds - READ-ONLY; Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
            TravelTimeInSeconds *int32 `json:"travelTimeInSeconds,omitempty"`
            // TrafficDelayInSeconds - READ-ONLY; Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
            TrafficDelayInSeconds *int32 `json:"trafficDelayInSeconds,omitempty"`
            // DepartureTime - READ-ONLY; Departure Time property
            DepartureTime *string `json:"departureTime,omitempty"`
            // ArrivalTime - READ-ONLY; Arrival Time property
            ArrivalTime *string `json:"arrivalTime,omitempty"`
            // NoTrafficTravelTimeInSeconds - READ-ONLY; Estimated travel time calculated as if there are no delays on the route due to traffic conditions (e.g. congestion). Included only if computeTravelTimeFor = all is used in the query.
            NoTrafficTravelTimeInSeconds *int32 `json:"noTrafficTravelTimeInSeconds,omitempty"`
            // HistoricTrafficTravelTimeInSeconds - READ-ONLY; Estimated travel time calculated using time-dependent historic traffic data. Included only if computeTravelTimeFor = all is used in the query.
            HistoricTrafficTravelTimeInSeconds *int32 `json:"historicTrafficTravelTimeInSeconds,omitempty"`
            // LiveTrafficIncidentsTravelTimeInSeconds - READ-ONLY; Estimated travel time calculated using real-time speed data. Included only if computeTravelTimeFor = all is used in the query.
            LiveTrafficIncidentsTravelTimeInSeconds *int32 `json:"liveTrafficIncidentsTravelTimeInSeconds,omitempty"`
            // FuelConsumptionInLiters - READ-ONLY; Estimated fuel consumption in liters using the Combustion Consumption Model. Included if vehicleEngineType is set to _combustion_ and constantSpeedConsumptionInLitersPerHundredkm is specified. The value will be non-negative.
            FuelConsumptionInLiters *float64 `json:"fuelConsumptionInLiters,omitempty"`
            // BatteryConsumptionInkWh - READ-ONLY; Estimated electric energy consumption in kilowatt hours (kWh) using the Electric Consumption Model. Included if vehicleEngineType is set to electric and constantSpeedConsumptionInkWhPerHundredkm is specified. The value of batteryConsumptionInkWh includes the recuperated electric energy and can therefore be negative (which indicates gaining energy). If both maxChargeInkWh and currentChargeInkWh are specified, recuperation will be capped to ensure that the battery charge level never exceeds maxChargeInkWh. If neither maxChargeInkWh nor currentChargeInkWh are specified, unconstrained recuperation is assumed in the consumption calculation.
            BatteryConsumptionInkWh *float64 `json:"batteryConsumptionInkWh,omitempty"`
            }

            // RouteResultSection ...
            type RouteResultSection struct {
            // StartPointIndex - READ-ONLY; Start Point Index property
            StartPointIndex *int32 `json:"startPointIndex,omitempty"`
            // EndPointIndex - READ-ONLY; End Point Index property
            EndPointIndex *int32 `json:"endPointIndex,omitempty"`
            // SectionType - READ-ONLY; Section Type property
            SectionType *string `json:"sectionType,omitempty"`
            // TravelMode - READ-ONLY; Travel Mode property
            TravelMode *string `json:"travelMode,omitempty"`
            // SimpleCategory - READ-ONLY; Type of the incident. Can currently be JAM, ROAD_WORK, ROAD_CLOSURE, or OTHER. See "tec" for detailed information.
            SimpleCategory *string `json:"simpleCategory,omitempty"`
            // EffectiveSpeedInKmh - READ-ONLY; Effective speed of the incident in km/h, averaged over its entire length.
            EffectiveSpeedInKmh *int32 `json:"effectiveSpeedInKmh,omitempty"`
            // DelayInSeconds - READ-ONLY; Delay in seconds caused by the incident.
            DelayInSeconds *int32 `json:"delayInSeconds,omitempty"`
            // MagnitudeOfDelay - READ-ONLY; The magnitude of delay caused by the incident. These values correspond to the values of the response field ty of the [Get Traffic Incident Detail API](https://docs.microsoft.com/rest/api/maps/traffic/gettrafficincidentdetail). Possible values include: 'Zero', 'One', 'Two', 'Three', 'Four'
            MagnitudeOfDelay MagnitudeOfDelay `json:"magnitudeOfDelay,omitempty"`
            Tec *RouteResultSectionTec `json:"tec,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteResultSection.
        func (rrs RouteResultSection)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rrs.Tec != nil) {
                objectMap["tec"] = rrs.Tec
                }
                return json.Marshal(objectMap)
        }

            // RouteResultSectionTec details of the traffic event, using definitions in the
            // [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can contain effectCode and causes
            // elements.
            type RouteResultSectionTec struct {
            // EffectCode - READ-ONLY; The effect on the traffic flow. Contains a value in the tec001:EffectCode table, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can be used to color-code traffic events according to severity.
            EffectCode *int32 `json:"effectCode,omitempty"`
            // Causes - Causes array
            Causes *[]RouteResultSectionTecCause `json:"causes,omitempty"`
            }

        // MarshalJSON is the custom marshaler for RouteResultSectionTec.
        func (rrst RouteResultSectionTec)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rrst.Causes != nil) {
                objectMap["causes"] = rrst.Causes
                }
                return json.Marshal(objectMap)
        }

            // RouteResultSectionTecCause the cause of the traffic event. Can contain mainCauseCode and subCauseCode
            // elements. Can be used to define iconography and descriptions.
            type RouteResultSectionTecCause struct {
            // MainCauseCode - READ-ONLY; The main cause of the traffic event. Contains a value in the tec002:CauseCode table, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard.
            MainCauseCode *int32 `json:"mainCauseCode,omitempty"`
            // SubCauseCode - READ-ONLY; The subcause of the traffic event. Contains a value in the sub cause table defined by the mainCauseCode, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard.
            SubCauseCode *int32 `json:"subCauseCode,omitempty"`
            }

            // SearchAddressResponse this object is returned from a successful Search Address call
            type SearchAddressResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchAddressSummary `json:"summary,omitempty"`
            // Results - READ-ONLY; Results array
            Results *[]SearchAddressResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressResponse.
        func (sar SearchAddressResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sar.Summary != nil) {
                objectMap["summary"] = sar.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressResult ...
            type SearchAddressResult struct {
            // Type - READ-ONLY; One of:
            // * POI
            // * Street
            // * Geography
            // * Point Address
            // * Address Range
            // * Cross Street
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            DataSources *DataSources `json:"dataSources,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressResult.
        func (sar SearchAddressResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sar.Score != nil) {
                objectMap["score"] = sar.Score
                }
                if(sar.Address != nil) {
                objectMap["address"] = sar.Address
                }
                if(sar.Position != nil) {
                objectMap["position"] = sar.Position
                }
                if(sar.Viewport != nil) {
                objectMap["viewport"] = sar.Viewport
                }
                if(sar.EntryPoints != nil) {
                objectMap["entryPoints"] = sar.EntryPoints
                }
                if(sar.DataSources != nil) {
                objectMap["dataSources"] = sar.DataSources
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressReverseCrossStreetResponse this object is returned from a successful Search Address Reverse
            // CrossStreet call
            type SearchAddressReverseCrossStreetResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchAddressReverseCrossStreetSummary `json:"summary,omitempty"`
            // Addresses - READ-ONLY; Addresses array
            Addresses *[]SearchAddressReverseCrossStreetResult `json:"addresses,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressReverseCrossStreetResponse.
        func (sarcsr SearchAddressReverseCrossStreetResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sarcsr.Summary != nil) {
                objectMap["summary"] = sarcsr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressReverseCrossStreetResult ...
            type SearchAddressReverseCrossStreetResult struct {
            Address *SearchResultAddress `json:"address,omitempty"`
            // Position - READ-ONLY; Position property in the form of "{latitude},{longitude}"
            Position *string `json:"position,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressReverseCrossStreetResult.
        func (sarcsr SearchAddressReverseCrossStreetResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sarcsr.Address != nil) {
                objectMap["address"] = sarcsr.Address
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressReverseCrossStreetSummary summary object for a Search Address Reverse Cross Street response
            type SearchAddressReverseCrossStreetSummary struct {
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            }

            // SearchAddressReverseResponse this object is returned from a successful Search Address Reverse call
            type SearchAddressReverseResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchAddressReverseSummary `json:"summary,omitempty"`
            // Addresses - READ-ONLY; Addresses array
            Addresses *[]SearchAddressReverseResult `json:"addresses,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressReverseResponse.
        func (sarr SearchAddressReverseResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sarr.Summary != nil) {
                objectMap["summary"] = sarr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressReverseResult ...
            type SearchAddressReverseResult struct {
            Address *SearchResultAddress `json:"address,omitempty"`
            // Position - READ-ONLY; Position property in the form of "{latitude},{longitude}"
            Position *string `json:"position,omitempty"`
            // MatchType - READ-ONLY; Information on the type of match.
            // One of:
            //   * AddressPoint
            //   * HouseNumberRange
            //   * Street
            MatchType *string `json:"matchType,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressReverseResult.
        func (sarr SearchAddressReverseResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sarr.Address != nil) {
                objectMap["address"] = sarr.Address
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressReverseSummary summary object for a Search Address Reverse response
            type SearchAddressReverseSummary struct {
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            }

            // SearchAddressStructuredResponse this object is returned from a successful Search Address Structured call
            type SearchAddressStructuredResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchAddressStructuredSummary `json:"summary,omitempty"`
            // Results - READ-ONLY; Results array
            Results *[]SearchAddressStructuredResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressStructuredResponse.
        func (sasr SearchAddressStructuredResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sasr.Summary != nil) {
                objectMap["summary"] = sasr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressStructuredResult ...
            type SearchAddressStructuredResult struct {
            // Type - READ-ONLY; Type property
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            Dist *float64 `json:"dist,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            AddressRanges *SearchResultAddressRanges `json:"addressRanges,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressStructuredResult.
        func (sasr SearchAddressStructuredResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sasr.Score != nil) {
                objectMap["score"] = sasr.Score
                }
                if(sasr.Dist != nil) {
                objectMap["dist"] = sasr.Dist
                }
                if(sasr.Address != nil) {
                objectMap["address"] = sasr.Address
                }
                if(sasr.Position != nil) {
                objectMap["position"] = sasr.Position
                }
                if(sasr.Viewport != nil) {
                objectMap["viewport"] = sasr.Viewport
                }
                if(sasr.EntryPoints != nil) {
                objectMap["entryPoints"] = sasr.EntryPoints
                }
                if(sasr.AddressRanges != nil) {
                objectMap["addressRanges"] = sasr.AddressRanges
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressStructuredSummary summary object for a Search Address Structured response
            type SearchAddressStructuredSummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Limit - READ-ONLY; Maximum number of responses that will be returned
            Limit *int32 `json:"limit,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            GeoBias *SearchSummaryGeoBias `json:"geoBias,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAddressStructuredSummary.
        func (sass SearchAddressStructuredSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sass.GeoBias != nil) {
                objectMap["geoBias"] = sass.GeoBias
                }
                return json.Marshal(objectMap)
        }

            // SearchAddressSummary summary object for a Search Address response
            type SearchAddressSummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            }

            // SearchAlongRouteRequestBody this type represents the request body for the Search Along Route service.
            type SearchAlongRouteRequestBody struct {
            Route *LineString `json:"route,omitempty"`
            }

            // SearchAlongRouteResponse this object is returned from a successful Search Along Route call.
            type SearchAlongRouteResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchAlongRouteSummary `json:"summary,omitempty"`
            // Results - READ-ONLY; A list of Search Along Route results.
            Results *[]SearchAlongRouteResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAlongRouteResponse.
        func (sarr SearchAlongRouteResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sarr.Summary != nil) {
                objectMap["summary"] = sarr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchAlongRouteResult this type represents the Search Along Route result object.
            type SearchAlongRouteResult struct {
            // Type - READ-ONLY; Type property
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            // Info - READ-ONLY; Info property
            Info *string `json:"info,omitempty"`
            // EntityType - Possible values include: 'EntityTypeCountry', 'EntityTypeCountrySubdivision', 'EntityTypeCountrySecondarySubdivision', 'EntityTypeCountryTertiarySubdivision', 'EntityTypeMunicipality', 'EntityTypeMunicipalitySubdivision', 'EntityTypeNeighbourhood', 'EntityTypePostalCodeArea'
            EntityType EntityType `json:"entityType,omitempty"`
            Poi *SearchResultPoi `json:"poi,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            Dist *float64 `json:"dist,omitempty"`
            // DetourTime - READ-ONLY; Detour time in seconds
            DetourTime *float64 `json:"detourTime,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchAlongRouteResult.
        func (sarr SearchAlongRouteResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sarr.Score != nil) {
                objectMap["score"] = sarr.Score
                }
                if(sarr.EntityType != "") {
                objectMap["entityType"] = sarr.EntityType
                }
                if(sarr.Poi != nil) {
                objectMap["poi"] = sarr.Poi
                }
                if(sarr.Address != nil) {
                objectMap["address"] = sarr.Address
                }
                if(sarr.Position != nil) {
                objectMap["position"] = sarr.Position
                }
                if(sarr.Viewport != nil) {
                objectMap["viewport"] = sarr.Viewport
                }
                if(sarr.EntryPoints != nil) {
                objectMap["entryPoints"] = sarr.EntryPoints
                }
                if(sarr.Dist != nil) {
                objectMap["dist"] = sarr.Dist
                }
                return json.Marshal(objectMap)
        }

            // SearchAlongRouteSummary summary object for a Search Along Route response
            type SearchAlongRouteSummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            }

            // SearchFuzzyResponse this object is returned from a successful Search Fuzzy call
            type SearchFuzzyResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchFuzzySummary `json:"summary,omitempty"`
            // Results - READ-ONLY; Results array
            Results *[]SearchFuzzyResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchFuzzyResponse.
        func (sfr SearchFuzzyResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sfr.Summary != nil) {
                objectMap["summary"] = sfr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchFuzzyResult ...
            type SearchFuzzyResult struct {
            // Type - READ-ONLY; One of:
            // * POI
            // * Street
            // * Geography
            // * Point Address
            // * Address Range
            // * Cross Street
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            // Info - READ-ONLY; Info property
            Info *string `json:"info,omitempty"`
            // EntityType - Possible values include: 'EntityTypeCountry', 'EntityTypeCountrySubdivision', 'EntityTypeCountrySecondarySubdivision', 'EntityTypeCountryTertiarySubdivision', 'EntityTypeMunicipality', 'EntityTypeMunicipalitySubdivision', 'EntityTypeNeighbourhood', 'EntityTypePostalCodeArea'
            EntityType EntityType `json:"entityType,omitempty"`
            Poi *SearchResultPoi `json:"poi,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            AddressRanges *SearchResultAddressRanges `json:"addressRanges,omitempty"`
            DataSources *DataSources `json:"dataSources,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchFuzzyResult.
        func (sfr SearchFuzzyResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sfr.Score != nil) {
                objectMap["score"] = sfr.Score
                }
                if(sfr.EntityType != "") {
                objectMap["entityType"] = sfr.EntityType
                }
                if(sfr.Poi != nil) {
                objectMap["poi"] = sfr.Poi
                }
                if(sfr.Address != nil) {
                objectMap["address"] = sfr.Address
                }
                if(sfr.Position != nil) {
                objectMap["position"] = sfr.Position
                }
                if(sfr.Viewport != nil) {
                objectMap["viewport"] = sfr.Viewport
                }
                if(sfr.EntryPoints != nil) {
                objectMap["entryPoints"] = sfr.EntryPoints
                }
                if(sfr.AddressRanges != nil) {
                objectMap["addressRanges"] = sfr.AddressRanges
                }
                if(sfr.DataSources != nil) {
                objectMap["dataSources"] = sfr.DataSources
                }
                return json.Marshal(objectMap)
        }

            // SearchFuzzySummary summary object for a Search Fuzzy response
            type SearchFuzzySummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            }

            // SearchGeometryResponse this object is returned from a successful Search By Geometry call
            type SearchGeometryResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchGeometrySummary `json:"summary,omitempty"`
            // Results - READ-ONLY; A list of Search Inside Geometry results.
            Results *[]SearchGeometryResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchGeometryResponse.
        func (sgr SearchGeometryResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sgr.Summary != nil) {
                objectMap["summary"] = sgr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchGeometryResult this type represents the Search Inside Geometry result object.
            type SearchGeometryResult struct {
            // Type - READ-ONLY; Type property
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            // Info - READ-ONLY; Info property
            Info *string `json:"info,omitempty"`
            // EntityType - Possible values include: 'EntityTypeCountry', 'EntityTypeCountrySubdivision', 'EntityTypeCountrySecondarySubdivision', 'EntityTypeCountryTertiarySubdivision', 'EntityTypeMunicipality', 'EntityTypeMunicipalitySubdivision', 'EntityTypeNeighbourhood', 'EntityTypePostalCodeArea'
            EntityType EntityType `json:"entityType,omitempty"`
            Poi *SearchResultPoi `json:"poi,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchGeometryResult.
        func (sgr SearchGeometryResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sgr.Score != nil) {
                objectMap["score"] = sgr.Score
                }
                if(sgr.EntityType != "") {
                objectMap["entityType"] = sgr.EntityType
                }
                if(sgr.Poi != nil) {
                objectMap["poi"] = sgr.Poi
                }
                if(sgr.Address != nil) {
                objectMap["address"] = sgr.Address
                }
                if(sgr.Position != nil) {
                objectMap["position"] = sgr.Position
                }
                if(sgr.Viewport != nil) {
                objectMap["viewport"] = sgr.Viewport
                }
                if(sgr.EntryPoints != nil) {
                objectMap["entryPoints"] = sgr.EntryPoints
                }
                return json.Marshal(objectMap)
        }

            // SearchGeometrySummary summary object for a Search Geometry response
            type SearchGeometrySummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            }

            // SearchInsideGeometryRequestBody this type represents the request body for the Search Inside Geometry
            // service.
            type SearchInsideGeometryRequestBody struct {
            Geometry interface{} `json:"geometry,omitempty"`
            }

            // SearchNearbyResponse this object is returned from a successful Search Nearby call
            type SearchNearbyResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchNearbySummary `json:"summary,omitempty"`
            // Results - READ-ONLY; Results array
            Results *[]SearchNearbyResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchNearbyResponse.
        func (snr SearchNearbyResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(snr.Summary != nil) {
                objectMap["summary"] = snr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchNearbyResult ...
            type SearchNearbyResult struct {
            // Type - READ-ONLY; Type property
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            Dist *float64 `json:"dist,omitempty"`
            // Info - READ-ONLY; Info property
            Info *string `json:"info,omitempty"`
            Poi *SearchResultPoi `json:"poi,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchNearbyResult.
        func (snr SearchNearbyResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(snr.Score != nil) {
                objectMap["score"] = snr.Score
                }
                if(snr.Dist != nil) {
                objectMap["dist"] = snr.Dist
                }
                if(snr.Poi != nil) {
                objectMap["poi"] = snr.Poi
                }
                if(snr.Address != nil) {
                objectMap["address"] = snr.Address
                }
                if(snr.Position != nil) {
                objectMap["position"] = snr.Position
                }
                if(snr.Viewport != nil) {
                objectMap["viewport"] = snr.Viewport
                }
                if(snr.EntryPoints != nil) {
                objectMap["entryPoints"] = snr.EntryPoints
                }
                return json.Marshal(objectMap)
        }

            // SearchNearbySummary summary object for a Search Nearby response
            type SearchNearbySummary struct {
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            GeoBias *SearchSummaryGeoBias `json:"geoBias,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchNearbySummary.
        func (sns SearchNearbySummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sns.GeoBias != nil) {
                objectMap["geoBias"] = sns.GeoBias
                }
                return json.Marshal(objectMap)
        }

            // SearchPoiCategoryResponse this object is returned from a successful Search POI Category call
            type SearchPoiCategoryResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchPoiCategorySummary `json:"summary,omitempty"`
            // Results - READ-ONLY; Results array
            Results *[]SearchPoiCategoryResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPoiCategoryResponse.
        func (spcr SearchPoiCategoryResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(spcr.Summary != nil) {
                objectMap["summary"] = spcr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchPoiCategoryResult ...
            type SearchPoiCategoryResult struct {
            // Type - READ-ONLY; Type property
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            Dist *float64 `json:"dist,omitempty"`
            // Info - READ-ONLY; Info property
            Info *string `json:"info,omitempty"`
            // EntityType - Possible values include: 'EntityTypeCountry', 'EntityTypeCountrySubdivision', 'EntityTypeCountrySecondarySubdivision', 'EntityTypeCountryTertiarySubdivision', 'EntityTypeMunicipality', 'EntityTypeMunicipalitySubdivision', 'EntityTypeNeighbourhood', 'EntityTypePostalCodeArea'
            EntityType EntityType `json:"entityType,omitempty"`
            Poi *SearchResultPoi `json:"poi,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPoiCategoryResult.
        func (spcr SearchPoiCategoryResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(spcr.Score != nil) {
                objectMap["score"] = spcr.Score
                }
                if(spcr.Dist != nil) {
                objectMap["dist"] = spcr.Dist
                }
                if(spcr.EntityType != "") {
                objectMap["entityType"] = spcr.EntityType
                }
                if(spcr.Poi != nil) {
                objectMap["poi"] = spcr.Poi
                }
                if(spcr.Address != nil) {
                objectMap["address"] = spcr.Address
                }
                if(spcr.Position != nil) {
                objectMap["position"] = spcr.Position
                }
                if(spcr.Viewport != nil) {
                objectMap["viewport"] = spcr.Viewport
                }
                if(spcr.EntryPoints != nil) {
                objectMap["entryPoints"] = spcr.EntryPoints
                }
                return json.Marshal(objectMap)
        }

            // SearchPoiCategorySummary summary object for a Search POI Category response
            type SearchPoiCategorySummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            GeoBias *SearchSummaryGeoBias `json:"geoBias,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPoiCategorySummary.
        func (spcs SearchPoiCategorySummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(spcs.GeoBias != nil) {
                objectMap["geoBias"] = spcs.GeoBias
                }
                return json.Marshal(objectMap)
        }

            // SearchPoiResponse this object is returned from a successful Search POI call
            type SearchPoiResponse struct {
            autorest.Response `json:"-"`
            Summary *SearchPoiSummary `json:"summary,omitempty"`
            // Results - READ-ONLY; Results array
            Results *[]SearchPoiResult `json:"results,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPoiResponse.
        func (spr SearchPoiResponse)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(spr.Summary != nil) {
                objectMap["summary"] = spr.Summary
                }
                return json.Marshal(objectMap)
        }

            // SearchPoiResult ...
            type SearchPoiResult struct {
            // Type - READ-ONLY; Type property
            Type *string `json:"type,omitempty"`
            // ID - READ-ONLY; Id property
            ID *string `json:"id,omitempty"`
            Score *float64 `json:"score,omitempty"`
            Dist *float64 `json:"dist,omitempty"`
            // Info - READ-ONLY; Info property
            Info *string `json:"info,omitempty"`
            // EntityType - Possible values include: 'EntityTypeCountry', 'EntityTypeCountrySubdivision', 'EntityTypeCountrySecondarySubdivision', 'EntityTypeCountryTertiarySubdivision', 'EntityTypeMunicipality', 'EntityTypeMunicipalitySubdivision', 'EntityTypeNeighbourhood', 'EntityTypePostalCodeArea'
            EntityType EntityType `json:"entityType,omitempty"`
            Poi *SearchResultPoi `json:"poi,omitempty"`
            Address *SearchResultAddress `json:"address,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            Viewport *SearchResultViewport `json:"viewport,omitempty"`
            // EntryPoints - Entry Points array
            EntryPoints *[]SearchResultEntryPoint `json:"entryPoints,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPoiResult.
        func (spr SearchPoiResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(spr.Score != nil) {
                objectMap["score"] = spr.Score
                }
                if(spr.Dist != nil) {
                objectMap["dist"] = spr.Dist
                }
                if(spr.EntityType != "") {
                objectMap["entityType"] = spr.EntityType
                }
                if(spr.Poi != nil) {
                objectMap["poi"] = spr.Poi
                }
                if(spr.Address != nil) {
                objectMap["address"] = spr.Address
                }
                if(spr.Position != nil) {
                objectMap["position"] = spr.Position
                }
                if(spr.Viewport != nil) {
                objectMap["viewport"] = spr.Viewport
                }
                if(spr.EntryPoints != nil) {
                objectMap["entryPoints"] = spr.EntryPoints
                }
                return json.Marshal(objectMap)
        }

            // SearchPoiSummary summary object for a Search POI response
            type SearchPoiSummary struct {
            // Query - READ-ONLY; Query property
            Query *string `json:"query,omitempty"`
            // QueryType - READ-ONLY; QueryType property
            QueryType *string `json:"queryType,omitempty"`
            // QueryTime - READ-ONLY; QueryTime property
            QueryTime *int32 `json:"queryTime,omitempty"`
            // NumResults - READ-ONLY; NumResults property
            NumResults *int32 `json:"numResults,omitempty"`
            // Offset - READ-ONLY; Offset property
            Offset *int32 `json:"offset,omitempty"`
            // TotalResults - READ-ONLY; TotalResults property
            TotalResults *int32 `json:"totalResults,omitempty"`
            // FuzzyLevel - READ-ONLY; FuzzyLevel property
            FuzzyLevel *int32 `json:"fuzzyLevel,omitempty"`
            GeoBias *SearchSummaryGeoBias `json:"geoBias,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPoiSummary.
        func (sps SearchPoiSummary)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sps.GeoBias != nil) {
                objectMap["geoBias"] = sps.GeoBias
                }
                return json.Marshal(objectMap)
        }

            // SearchPolygonResponse this object is returned from a successful Search Polygon call
            type SearchPolygonResponse struct {
            autorest.Response `json:"-"`
            // AdditionalData - READ-ONLY; Results array
            AdditionalData *[]SearchPolygonResult `json:"additionalData,omitempty"`
            }

            // SearchPolygonResult ...
            type SearchPolygonResult struct {
            // ProviderID - READ-ONLY; ID of the returned entity
            ProviderID *string `json:"providerID,omitempty"`
            // Error - READ-ONLY; Reason for the failure to obtain data for this provider.
            Error *string `json:"error,omitempty"`
            // GeometryData - Geometry data in GeoJSON format. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946) for details. Present only if "error" is not present.
            GeometryData interface{} `json:"geometryData,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchPolygonResult.
        func (spr SearchPolygonResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(spr.GeometryData != nil) {
                objectMap["geometryData"] = spr.GeometryData
                }
                return json.Marshal(objectMap)
        }

            // SearchPostSearchAddressBatchFuture an abstraction for monitoring and retrieving the results of a
            // long-running operation.
            type SearchPostSearchAddressBatchFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(SearchClient) (BatchResponse, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *SearchPostSearchAddressBatchFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for SearchPostSearchAddressBatchFuture.Result.
        func (future *SearchPostSearchAddressBatchFuture) result(client SearchClient) (br BatchResponse, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.SearchPostSearchAddressBatchFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.SearchPostSearchAddressBatchFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if br.Response.Response, err = future.GetResult(sender); err == nil && br.Response.Response.StatusCode != http.StatusNoContent {
            br, err = client.PostSearchAddressBatchResponder(br.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.SearchPostSearchAddressBatchFuture", "Result", br.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // SearchPostSearchAddressReverseBatchFuture an abstraction for monitoring and retrieving the results of a
            // long-running operation.
            type SearchPostSearchAddressReverseBatchFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(SearchClient) (BatchResponse, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *SearchPostSearchAddressReverseBatchFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for SearchPostSearchAddressReverseBatchFuture.Result.
        func (future *SearchPostSearchAddressReverseBatchFuture) result(client SearchClient) (br BatchResponse, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.SearchPostSearchAddressReverseBatchFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.SearchPostSearchAddressReverseBatchFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if br.Response.Response, err = future.GetResult(sender); err == nil && br.Response.Response.StatusCode != http.StatusNoContent {
            br, err = client.PostSearchAddressReverseBatchResponder(br.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.SearchPostSearchAddressReverseBatchFuture", "Result", br.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // SearchPostSearchFuzzyBatchFuture an abstraction for monitoring and retrieving the results of a
            // long-running operation.
            type SearchPostSearchFuzzyBatchFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(SearchClient) (BatchResponse, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *SearchPostSearchFuzzyBatchFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for SearchPostSearchFuzzyBatchFuture.Result.
        func (future *SearchPostSearchFuzzyBatchFuture) result(client SearchClient) (br BatchResponse, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.SearchPostSearchFuzzyBatchFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.SearchPostSearchFuzzyBatchFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if br.Response.Response, err = future.GetResult(sender); err == nil && br.Response.Response.StatusCode != http.StatusNoContent {
            br, err = client.PostSearchFuzzyBatchResponder(br.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.SearchPostSearchFuzzyBatchFuture", "Result", br.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // SearchResultAddress the address of the result
            type SearchResultAddress struct {
            // BuildingNumber - READ-ONLY; Building Number property
            BuildingNumber *string `json:"buildingNumber,omitempty"`
            // Street - READ-ONLY; Street property
            Street *string `json:"street,omitempty"`
            // CrossStreet - READ-ONLY; Cross Street property
            CrossStreet *string `json:"crossStreet,omitempty"`
            // StreetNumber - READ-ONLY; Street Number property
            StreetNumber *string `json:"streetNumber,omitempty"`
            // RouteNumbers - READ-ONLY; number of routes
            RouteNumbers *[]int32 `json:"routeNumbers,omitempty"`
            // StreetName - READ-ONLY; Street Name property
            StreetName *string `json:"streetName,omitempty"`
            // StreetNameAndNumber - READ-ONLY; Street Name and Number property
            StreetNameAndNumber *string `json:"streetNameAndNumber,omitempty"`
            // Municipality - READ-ONLY; Municipality property
            Municipality *string `json:"municipality,omitempty"`
            // MunicipalitySubdivision - READ-ONLY; Municipality Subdivision property
            MunicipalitySubdivision *string `json:"municipalitySubdivision,omitempty"`
            // CountryTertiarySubdivision - READ-ONLY; Country Tertiary Subdivision property
            CountryTertiarySubdivision *string `json:"countryTertiarySubdivision,omitempty"`
            // CountrySecondarySubdivision - READ-ONLY; Country Secondary Subdivision property
            CountrySecondarySubdivision *string `json:"countrySecondarySubdivision,omitempty"`
            // CountrySubdivision - READ-ONLY; Country Subdivision property
            CountrySubdivision *string `json:"countrySubdivision,omitempty"`
            // PostalCode - READ-ONLY; Postal Code property
            PostalCode *string `json:"postalCode,omitempty"`
            // ExtendedPostalCode - READ-ONLY; Extended Postal Code property
            ExtendedPostalCode *string `json:"extendedPostalCode,omitempty"`
            // CountryCode - READ-ONLY; Country Code property
            CountryCode *string `json:"countryCode,omitempty"`
            // Country - READ-ONLY; Country property
            Country *string `json:"country,omitempty"`
            // CountryCodeISO3 - READ-ONLY; Country Code ISO3 property
            CountryCodeISO3 *string `json:"countryCodeISO3,omitempty"`
            // FreeformAddress - READ-ONLY; Free form Address property
            FreeformAddress *string `json:"freeformAddress,omitempty"`
            // CountrySubdivisionName - READ-ONLY; Country Subdivision Name property
            CountrySubdivisionName *string `json:"countrySubdivisionName,omitempty"`
            // LocalName - READ-ONLY; An address component which represents the name of a geographic area or locality that groups a number of addressable objects for addressing purposes, without being an administrative unit. This field is used to build the `freeformAddress` property.
            LocalName *string `json:"localName,omitempty"`
            }

            // SearchResultAddressRanges describes the address range on both sides of the street for a search result.
            // Coordinates for the start and end locations of the address range are included.
            type SearchResultAddressRanges struct {
            RangeLeft *string `json:"rangeLeft,omitempty"`
            RangeRight *string `json:"rangeRight,omitempty"`
            From *CoordinateAbbreviated `json:"from,omitempty"`
            To *CoordinateAbbreviated `json:"to,omitempty"`
            }

            // SearchResultEntryPoint the entry point for the POI being returned.
            type SearchResultEntryPoint struct {
            // Type - READ-ONLY; The type of entry point. Value can be either _main_ or _minor_. Possible values include: 'Main', 'Minor'
            Type EntryPointType `json:"type,omitempty"`
            Position *CoordinateAbbreviated `json:"position,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchResultEntryPoint.
        func (srep SearchResultEntryPoint)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(srep.Position != nil) {
                objectMap["position"] = srep.Position
                }
                return json.Marshal(objectMap)
        }

            // SearchResultPoi details of the returned POI including information such as the name, phone, url address,
            // and classifications.
            type SearchResultPoi struct {
            // Name - READ-ONLY; Name of the POI property
            Name *string `json:"name,omitempty"`
            // Phone - READ-ONLY; Telephone number property
            Phone *string `json:"phone,omitempty"`
            // URL - READ-ONLY; Website URL property
            URL *string `json:"url,omitempty"`
            // CategorySet - READ-ONLY; The list of the most specific POI categories
            CategorySet *[]SearchResultPoiCategorySet `json:"categorySet,omitempty"`
            // Categories - READ-ONLY; __[Deprecated]__ Use classifications instead. Categories array
            Categories *[]string `json:"categories,omitempty"`
            // Classifications - READ-ONLY; Classification array
            Classifications *[]SearchResultPoiClassification `json:"classifications,omitempty"`
            // Brands - READ-ONLY; Brands array. The name of the brand for the POI being returned.
            Brands *[]SearchResultPoiBrand `json:"brands,omitempty"`
            OpeningHours *SearchResultPoiOpeningHours `json:"openingHours,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SearchResultPoi.
        func (srp SearchResultPoi)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(srp.OpeningHours != nil) {
                objectMap["openingHours"] = srp.OpeningHours
                }
                return json.Marshal(objectMap)
        }

            // SearchResultPoiBrand the name of the brand for the POI being returned
            type SearchResultPoiBrand struct {
            // Name - READ-ONLY; Name of the brand
            Name *string `json:"name,omitempty"`
            }

            // SearchResultPoiCategorySet POI category
            type SearchResultPoiCategorySet struct {
            // ID - READ-ONLY; Category ID
            ID *int32 `json:"id,omitempty"`
            }

            // SearchResultPoiClassification the classification for the POI being returned
            type SearchResultPoiClassification struct {
            // Code - READ-ONLY; Code property
            Code *string `json:"code,omitempty"`
            // Names - READ-ONLY; Names array
            Names *[]SearchResultPoiClassificationName `json:"names,omitempty"`
            }

            // SearchResultPoiClassificationName name for the classification
            type SearchResultPoiClassificationName struct {
            // NameLocale - READ-ONLY; Name Locale property
            NameLocale *string `json:"nameLocale,omitempty"`
            // Name - READ-ONLY; Name property
            Name *string `json:"name,omitempty"`
            }

            // SearchResultPoiOpeningHours opening hours for a POI (Points of Interest).
            type SearchResultPoiOpeningHours struct {
            // Mode - READ-ONLY; Value used in the Request
            Mode *string `json:"mode,omitempty"`
            // TimeRanges - READ-ONLY; List of time ranges for the next 7 days
            TimeRanges *[]SearchResultPoiOpeningHoursTimeRange `json:"timeRanges,omitempty"`
            }

            // SearchResultPoiOpeningHoursTimeRange open time range for a day
            type SearchResultPoiOpeningHoursTimeRange struct {
            // StartTime - The point in the next 7 days range when a given POI is being opened, or the beginning of the range if it was opened before the range.
            StartTime *SearchResultPoiOpeningHoursTimeRangeTime `json:"startTime,omitempty"`
            // EndTime - The point in the next 7 days range when a given POI is being closed, or the beginning of the range if it was closed before the range.
            EndTime *SearchResultPoiOpeningHoursTimeRangeTime `json:"endTime,omitempty"`
            }

            // SearchResultPoiOpeningHoursTimeRangeTime represents a date and time
            type SearchResultPoiOpeningHoursTimeRangeTime struct {
            // Date - READ-ONLY; Represents current day in calendar year in POI time zone.
            Date *string `json:"date,omitempty"`
            // Hour - READ-ONLY; Hours are in the 24 hour format in the local time of a POI; possible values are 0 - 23.
            Hour *int32 `json:"hour,omitempty"`
            // Minute - READ-ONLY; Minutes are in the local time of a POI; possible values are 0 - 59.
            Minute *int32 `json:"minute,omitempty"`
            }

            // SearchResultViewport the viewport that covers the result represented by the top-left and bottom-right
            // coordinates of the  viewport.
            type SearchResultViewport struct {
            TopLeftPoint *CoordinateAbbreviated `json:"topLeftPoint,omitempty"`
            BtmRightPoint *CoordinateAbbreviated `json:"btmRightPoint,omitempty"`
            }

            // SearchSummaryGeoBias indication when the internal search engine has applied a geospatial bias to improve
            // the ranking of results.  In  some methods, this can be affected by setting the lat and lon parameters
            // where available.  In other cases it is  purely internal.
            type SearchSummaryGeoBias struct {
            // Lat - READ-ONLY; Latitude property
            Lat *float64 `json:"lat,omitempty"`
            // Lon - READ-ONLY; Longitude property
            Lon *float64 `json:"lon,omitempty"`
            }

            // SetObject ...
            type SetObject struct {
            autorest.Response `json:"-"`
            Value interface{} `json:"value,omitempty"`
            }

            // SevereWeatherAlert information about a severe weather alert.
            type SevereWeatherAlert struct {
            // CountryCode - 2-character ISO 3166-1 Alpha-2 country code, for example, "US".
            CountryCode *string `json:"countryCode,omitempty"`
            // AlertID - A unique numerical identifier for a weather alert.
            AlertID *int32 `json:"alertId,omitempty"`
            // Description - Description of the alert.
            Description *Description `json:"description,omitempty"`
            // Category - Category of the alert.
            Category *string `json:"category,omitempty"`
            // Priority - Number signifying the importance or ranking order of the given alert within the country/region it has originated. A lower number signifies a higher priority. For example, 1 is the highest priority. The number varies by country/region and can change over time as each country/region evolves their alert systems.
            Priority *int32 `json:"priority,omitempty"`
            // Class - Classification of the alert. This field is not available for all countries and therefore not always returned.
            Class *string `json:"class,omitempty"`
            // Level - Severity level of the alert. This field is not available for all countries and therefore not always returned.
            Level *string `json:"level,omitempty"`
            // Source - The provider of the alert information. By default the source is returned in English (en-US). The alerts are from official Government Meteorological Agencies and leading global weather alert providers.
            Source *string `json:"source,omitempty"`
            // SourceID - A numerical identifier associated with the source provider name of the alert data.
            SourceID *int32 `json:"sourceId,omitempty"`
            // Disclaimer - A disclaimer regarding the source of the alert information. This field is not always available. For example, disclaimer may include details about the delays or potential issues related to the alarm.
            Disclaimer *string `json:"disclaimer,omitempty"`
            // AlertAreas - Information about the alert specific to the affected area(s).
            AlertAreas *[]AlertArea `json:"alertAreas,omitempty"`
            }

            // SevereWeatherAlertsResponse this object is returned from a successful Get Severe Weather Alerts call.
            type SevereWeatherAlertsResponse struct {
            autorest.Response `json:"-"`
            // Results - A list of all severe weather alerts for the queried location.
            Results *[]SevereWeatherAlert `json:"results,omitempty"`
            }

            // SpatialCoordinate a location represented as a latitude and longitude
            type SpatialCoordinate struct {
            // Lat - READ-ONLY; Latitude property
            Lat *float64 `json:"lat,omitempty"`
            // Lon - READ-ONLY; Longitude property
            Lon *float64 `json:"lon,omitempty"`
            }

            // StatesetCreatedResponse the response model for the successful Stateset Create API.
            type StatesetCreatedResponse struct {
            autorest.Response `json:"-"`
            // StatesetID - READ-ONLY; The ID for the new stateset created.
            StatesetID *string `json:"statesetId,omitempty"`
            }

            // StatesetGetResponse the response model for the successful Stateset Get API.
            type StatesetGetResponse struct {
            autorest.Response `json:"-"`
            // DatasetIDList - Dataset ID associated with the stateset.
            DatasetIDList *[]string `json:"datasetIdList,omitempty"`
            StatesetStyle *StylesObject `json:"statesetStyle,omitempty"`
            }

            // StatesetInfoObject the stateset information detail.
            type StatesetInfoObject struct {
            // StatesetID - The stateset ID of this stateset.
            StatesetID *string `json:"statesetId,omitempty"`
            // DatasetIDList - Dataset ID associated with the stateset.
            DatasetIDList *[]string `json:"datasetIdList,omitempty"`
            StatesetStyle *StylesObject `json:"statesetStyle,omitempty"`
            }

            // StatesetListResponse the response model for the successful Stateset List API.
            type StatesetListResponse struct {
            autorest.Response `json:"-"`
            // StatesetDetailList - A list of statesets information.
            StatesetDetailList *[]StatesetInfoObject `json:"statesetDetailList,omitempty"`
            }

            // Step ...
            type Step struct {
            // Direction - The walking direction associated with this step.
            Direction *Direction `json:"direction,omitempty"`
            // StreetName - The name of the street in which this step takes place.
            StreetName *string `json:"streetName,omitempty"`
            }

            // Stop the stop's basic info
            type Stop struct {
            // StopID - The unique Azure Maps identifier for the respective public transit stop. When referring to public transit stops over time, it is recommended to use `stopId` since it will not change, as long as the physical stop exists.
            StopID *string `json:"stopId,omitempty"`
            // StopKey - The GTFS stop Id. GTFS stop Ids are provided by the transit authority and subject to change.
            StopKey *string `json:"stopKey,omitempty"`
            // StopName - The name of the stop.
            StopName *string `json:"stopName,omitempty"`
            // StopCode - The stop code displayed at the physical stop. Returned if available.
            StopCode *string `json:"stopCode,omitempty"`
            // Position - The Stop's location, latitude and longitude.
            Position *Coordinate `json:"position,omitempty"`
            // MainTransitType - The transit type of most lines stopping at this stop. One of Tram, Subway, Rail, Bus, Ferry, CableCar, Gondola, Funicular
            MainTransitType *string `json:"mainTransitType,omitempty"`
            // MainAgencyID - The Id of the transit agency of most lines stopping at this stop. For example '5872'.
            MainAgencyID *string `json:"mainAgencyId,omitempty"`
            // MainAgencyName - The name of the agency of most lines stopping at this stop, for example, 'Metro Transit'.
            MainAgencyName *string `json:"mainAgencyName,omitempty"`
            }

            // String ...
            type String struct {
            autorest.Response `json:"-"`
            Value *string `json:"value,omitempty"`
            }

            // StringRuleObject the string rule. The string value matching is case sensitive. If a feature's state
            // doesn't match any of the values defined here, that feature will not have any dynamic style. If duplicate
            // string values are given, the first one takes precedence.
            type StringRuleObject struct {
            // StateValue1 - The color when value string is stateValue1.
            StateValue1 *string `json:"stateValue1,omitempty"`
            // StateValue2 - The color when value string is stateValue2.
            StateValue2 *string `json:"stateValue2,omitempty"`
            // StateValueN - The color when value string is stateValueN.
            StateValueN *string `json:"stateValueN,omitempty"`
            }

            // StringTypeStyleRule the string type style rule object.
            type StringTypeStyleRule struct {
            // Rules - String style rules.
            Rules *[]StringRuleObject `json:"rules,omitempty"`
            // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
            KeyName *string `json:"keyName,omitempty"`
            // Type - Possible values include: 'TypeStyleRuleBase', 'TypeBooleanTypeStyleRule', 'TypeNumberTypeStyleRule', 'TypeStringTypeStyleRule'
            Type TypeBasicStyleRuleBase `json:"type,omitempty"`
            }

        // MarshalJSON is the custom marshaler for StringTypeStyleRule.
        func (stsr StringTypeStyleRule)MarshalJSON() ([]byte, error){
            stsr.Type = TypeStringTypeStyleRule
            objectMap := make(map[string]interface{})
                if(stsr.Rules != nil) {
                objectMap["rules"] = stsr.Rules
                }
                if(stsr.KeyName != nil) {
                objectMap["keyName"] = stsr.KeyName
                }
                if(stsr.Type != "") {
                objectMap["type"] = stsr.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleRuleBase implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return nil, false
            }

            // AsNumberTypeStyleRule is the BasicStyleRuleBase implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return nil, false
            }

            // AsStringTypeStyleRule is the BasicStyleRuleBase implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return &stsr, true
            }

            // AsStyleRuleBase is the BasicStyleRuleBase implementation for StringTypeStyleRule.
            func (stsr StringTypeStyleRule) AsStyleRuleBase() (*StyleRuleBase, bool) {
                return nil, false
            }

                // AsBasicStyleRuleBase is the BasicStyleRuleBase implementation for StringTypeStyleRule.
                func(stsr StringTypeStyleRule) AsBasicStyleRuleBase()(BasicStyleRuleBase, bool) {
                    return &stsr, true
                }


// BasicStyleRuleBase contains common properties for numeric, string and boolean style rules.
        type BasicStyleRuleBase interface {
            AsBooleanTypeStyleRule () (*BooleanTypeStyleRule, bool)
            AsNumberTypeStyleRule () (*NumberTypeStyleRule, bool)
            AsStringTypeStyleRule () (*StringTypeStyleRule, bool)
        AsStyleRuleBase () (*StyleRuleBase, bool)
        }

        // StyleRuleBase contains common properties for numeric, string and boolean style rules.
        type StyleRuleBase struct {
        // KeyName - Stateset style key name. Key names are random strings but they should be unique inside style array.
        KeyName *string `json:"keyName,omitempty"`
        // Type - Possible values include: 'TypeStyleRuleBase', 'TypeBooleanTypeStyleRule', 'TypeNumberTypeStyleRule', 'TypeStringTypeStyleRule'
        Type TypeBasicStyleRuleBase `json:"type,omitempty"`
        }

        func unmarshalBasicStyleRuleBase(body []byte) (BasicStyleRuleBase, error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }

        switch m["type"] {
            case string(TypeBooleanTypeStyleRule):
            var btsr BooleanTypeStyleRule
            err := json.Unmarshal(body, &btsr)
            return btsr, err
            case string(TypeNumberTypeStyleRule):
            var ntsr NumberTypeStyleRule
            err := json.Unmarshal(body, &ntsr)
            return ntsr, err
            case string(TypeStringTypeStyleRule):
            var stsr StringTypeStyleRule
            err := json.Unmarshal(body, &stsr)
            return stsr, err
            default:
        var srb StyleRuleBase
        err := json.Unmarshal(body, &srb)
        return srb, err
        }
        }
        func unmarshalBasicStyleRuleBaseArray(body []byte) ([]BasicStyleRuleBase, error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }

        srbArray := make([]BasicStyleRuleBase, len(rawMessages))

        for index, rawMessage := range rawMessages {
        srb, err := unmarshalBasicStyleRuleBase(*rawMessage)
        if err != nil {
        return nil, err
        }
        srbArray[index] = srb
        }
        return srbArray, nil
        }

        // MarshalJSON is the custom marshaler for StyleRuleBase.
        func (srb StyleRuleBase)MarshalJSON() ([]byte, error){
            srb.Type = TypeStyleRuleBase
            objectMap := make(map[string]interface{})
                if(srb.KeyName != nil) {
                objectMap["keyName"] = srb.KeyName
                }
                if(srb.Type != "") {
                objectMap["type"] = srb.Type
                }
                return json.Marshal(objectMap)
        }

            // AsBooleanTypeStyleRule is the BasicStyleRuleBase implementation for StyleRuleBase.
            func (srb StyleRuleBase) AsBooleanTypeStyleRule() (*BooleanTypeStyleRule, bool) {
                return nil, false
            }

            // AsNumberTypeStyleRule is the BasicStyleRuleBase implementation for StyleRuleBase.
            func (srb StyleRuleBase) AsNumberTypeStyleRule() (*NumberTypeStyleRule, bool) {
                return nil, false
            }

            // AsStringTypeStyleRule is the BasicStyleRuleBase implementation for StyleRuleBase.
            func (srb StyleRuleBase) AsStringTypeStyleRule() (*StringTypeStyleRule, bool) {
                return nil, false
            }

            // AsStyleRuleBase is the BasicStyleRuleBase implementation for StyleRuleBase.
            func (srb StyleRuleBase) AsStyleRuleBase() (*StyleRuleBase, bool) {
                return &srb, true
            }

                // AsBasicStyleRuleBase is the BasicStyleRuleBase implementation for StyleRuleBase.
                func(srb StyleRuleBase) AsBasicStyleRuleBase()(BasicStyleRuleBase, bool) {
                    return &srb, true
                }


            // StylesObject the styles model.
            type StylesObject struct {
            // Styles - An array of stateset styles. The style rule could be a numeric or string or a boolean type style rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject definitions [here](https://aka.ms/AzureMapsStatesetStylesObject).
            Styles *[]interface{} `json:"styles,omitempty"`
            }

            // SunGlare a rating that indicates how blinding the sun is for the driver.
            type SunGlare struct {
            // CalculatedVehicleHeading - If the vehicle heading value is not provided for a waypoint, then the service will calculate a heading based upon the location of neighboring waypoints if provided.
            CalculatedVehicleHeading *int32 `json:"calculatedVehicleHeading,omitempty"`
            // GlareIndex - An index from 0 to 100 indicating sun glare intensity for a driver. A value of 50 and above can be considered a hazard for some drivers and a value of 100 signifies the driver is driving straight into the sun and atmospheric conditions are clear allowing for the full intensity of the sun to blind the driver.
            GlareIndex *int32 `json:"glareIndex,omitempty"`
            }

            // TemperatureSummary ...
            type TemperatureSummary struct {
            // Past6Hours - Summary of temperature fluctuations over the past 6 hours.
            Past6Hours *TemperatureSummaryPast6Hours `json:"past6Hours,omitempty"`
            // Past12Hours - Summary of temperature fluctuations over the past 12 hours.
            Past12Hours *TemperatureSummaryPast12Hours `json:"past12Hours,omitempty"`
            // Past24Hours - Summary of temperature fluctuations over the past 24 hours.
            Past24Hours *TemperatureSummaryPast24Hours `json:"past24Hours,omitempty"`
            }

            // TemperatureSummaryPast12Hours summary of temperature fluctuations over the past 12 hours.
            type TemperatureSummaryPast12Hours struct {
            // Minimum - minimum
            Minimum *WeatherUnit `json:"minimum,omitempty"`
            // Maximum - maximum
            Maximum *WeatherUnit `json:"maximum,omitempty"`
            }

            // TemperatureSummaryPast24Hours summary of temperature fluctuations over the past 24 hours.
            type TemperatureSummaryPast24Hours struct {
            // Minimum - minimum
            Minimum *WeatherUnit `json:"minimum,omitempty"`
            // Maximum - maximum
            Maximum *WeatherUnit `json:"maximum,omitempty"`
            }

            // TemperatureSummaryPast6Hours summary of temperature fluctuations over the past 6 hours.
            type TemperatureSummaryPast6Hours struct {
            // Minimum - minimum
            Minimum *WeatherUnit `json:"minimum,omitempty"`
            // Maximum - maximum
            Maximum *WeatherUnit `json:"maximum,omitempty"`
            }

            // Tickets an array describing the individual prices of each of the tickets that the user is expected to
            // purchase throughout this itinerary. The list isn’t ordered.
            type Tickets struct {
            // Amount - Price of the ticket in cents. For example, $5.00 is returned as ‘500’.
            Amount *int32 `json:"amount,omitempty"`
            // CurrencyCode - Currency code, for example for US dollars “USD”.
            CurrencyCode *string `json:"currencyCode,omitempty"`
            }

            // TilesetCreatePreviewFuture an abstraction for monitoring and retrieving the results of a long-running
            // operation.
            type TilesetCreatePreviewFuture struct {
            azure.FutureAPI
            // Result returns the result of the asynchronous operation.
            // If the operation has not completed it will return an error.
            Result func(TilesetClient) (LongRunningOperationResult, error)
            }
        // UnmarshalJSON is the custom unmarshaller for CreateFuture.
        func (future *TilesetCreatePreviewFuture) UnmarshalJSON(body []byte) error {
            var azFuture azure.Future
            if err := json.Unmarshal(body, &azFuture); err != nil {
                return err
            }
            future.FutureAPI = &azFuture
            future.Result = future.result
            return nil
        }
        // result is the default implementation for TilesetCreatePreviewFuture.Result.
        func (future *TilesetCreatePreviewFuture) result(client TilesetClient) (lror LongRunningOperationResult, err error) {
            var done bool
            done, err = future.DoneWithContext(context.Background(), client)
            if err != nil {
                err = autorest.NewErrorWithError(err, "maps.TilesetCreatePreviewFuture", "Result", future.Response(), "Polling failure")
                return
            }
            if !done {
                err = azure.NewAsyncOpIncompleteError("maps.TilesetCreatePreviewFuture")
                return
            }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if lror.Response.Response, err = future.GetResult(sender); err == nil && lror.Response.Response.StatusCode != http.StatusNoContent {
            lror, err = client.CreatePreviewResponder(lror.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "maps.TilesetCreatePreviewFuture", "Result", lror.Response.Response, "Failure responding to request")
            }
            }
            return
        }

            // TilesetDetailInfo detail information for the data.
            type TilesetDetailInfo struct {
            // TilesetID - READ-ONLY; The unique tileset id for the tileset.
            TilesetID *string `json:"tilesetId,omitempty"`
            // DatasetID - READ-ONLY; The unique dataset Id used to create the tileset.
            DatasetID *string `json:"datasetId,omitempty"`
            // Description - READ-ONLY; The description the caller provided when creating the tileset. Maximum length 1024 characters.
            Description *string `json:"description,omitempty"`
            // MinZoom - READ-ONLY; The lowest tile zoom level tile generated for the tileset.
            MinZoom *int32 `json:"minZoom,omitempty"`
            // MaxZoom - READ-ONLY; The highest tile zoom level tile generated for the tileset.
            MaxZoom *int32 `json:"maxZoom,omitempty"`
            // Bbox - READ-ONLY; Bounding box which all features of the tileset lay within. Projection used - EPSG:3857. Format : 'minLon, minLat, maxLon, maxLat'.
            Bbox *[]float64 `json:"bbox,omitempty"`
            }

            // TilesetListResponse the response model for the Tileset List API. Returns a list of all tilesets.
            type TilesetListResponse struct {
            autorest.Response `json:"-"`
            // Tilesets - READ-ONLY; A list of all tilesets.
            Tilesets *[]TilesetDetailInfo `json:"tilesets,omitempty"`
            }

            // TimeTransition ...
            type TimeTransition struct {
            // Tag - READ-ONLY; Tag property
            Tag *string `json:"Tag,omitempty"`
            // StandardOffset - READ-ONLY; StandardOffset property
            StandardOffset *string `json:"StandardOffset,omitempty"`
            // DaylightSavings - READ-ONLY; DaylightSavings property
            DaylightSavings *string `json:"DaylightSavings,omitempty"`
            // UtcStart - READ-ONLY; Start date, start time for this transition period
            UtcStart *date.Time `json:"UtcStart,omitempty"`
            // UtcEnd - READ-ONLY; End date, end time for this transition period
            UtcEnd *date.Time `json:"UtcEnd,omitempty"`
            }

            // TimeZoneByCoordinates ...
            type TimeZoneByCoordinates struct {
            // ID - READ-ONLY; Id property
            ID *string `json:"Id,omitempty"`
            // Aliases - READ-ONLY; An array of time zone ID aliases.  Only returned when [options]=*zoneinfo* or *all*.
            // Note: may be null.
            Aliases *[]string `json:"Aliases,omitempty"`
            // Countries - READ-ONLY; An array of country records. Only returned when [options]=*zoneinfo* or *all*.
            Countries *[]Country `json:"Countries,omitempty"`
            Names *Names `json:"Names,omitempty"`
            ReferenceTime *ReferenceTimeByCoordinates `json:"ReferenceTime,omitempty"`
            RepresentativePoint *RepresentativePoint `json:"RepresentativePoint,omitempty"`
            // TimeTransitions - READ-ONLY; Time zone DST transitions from [transitionsFrom] until timestamp + 1 year.
            TimeTransitions *[]TimeTransition `json:"TimeTransitions,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TimeZoneByCoordinates.
        func (tzbc TimeZoneByCoordinates)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tzbc.Names != nil) {
                objectMap["Names"] = tzbc.Names
                }
                if(tzbc.ReferenceTime != nil) {
                objectMap["ReferenceTime"] = tzbc.ReferenceTime
                }
                if(tzbc.RepresentativePoint != nil) {
                objectMap["RepresentativePoint"] = tzbc.RepresentativePoint
                }
                return json.Marshal(objectMap)
        }

            // TimezoneByCoordinatesResult this object is returned from a successful Timezone By Coordinates call
            type TimezoneByCoordinatesResult struct {
            autorest.Response `json:"-"`
            // Version - READ-ONLY; Version property
            Version *string `json:"Version,omitempty"`
            // ReferenceUtcTimestamp - READ-ONLY; Reference Utc Timestamp property
            ReferenceUtcTimestamp *date.Time `json:"ReferenceUtcTimestamp,omitempty"`
            TimeZones *[]TimeZoneByCoordinates `json:"TimeZones,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TimezoneByCoordinatesResult.
        func (tbcr TimezoneByCoordinatesResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tbcr.TimeZones != nil) {
                objectMap["TimeZones"] = tbcr.TimeZones
                }
                return json.Marshal(objectMap)
        }

            // TimezoneByID ...
            type TimezoneByID struct {
            // ID - READ-ONLY; Id property
            ID *string `json:"Id,omitempty"`
            // Aliases - READ-ONLY; An array of time zone ID aliases.  Only returned when [options]=*zoneinfo* or *all*.
            // Note: may be null.
            Aliases *[]string `json:"Aliases,omitempty"`
            // Countries - READ-ONLY; An array of country records. Only returned when [options]=*zoneinfo* or *all*.
            Countries *[]Country `json:"Countries,omitempty"`
            Names *Names `json:"Names,omitempty"`
            ReferenceTime *ReferenceTimeByID `json:"ReferenceTime,omitempty"`
            RepresentativePoint *RepresentativePoint `json:"RepresentativePoint,omitempty"`
            // TimeTransitions - READ-ONLY; Time zone DST transitions from [transitionsFrom] until timestamp + 1 year.
            TimeTransitions *[]TimeTransition `json:"TimeTransitions,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TimezoneByID.
        func (tbi TimezoneByID)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tbi.Names != nil) {
                objectMap["Names"] = tbi.Names
                }
                if(tbi.ReferenceTime != nil) {
                objectMap["ReferenceTime"] = tbi.ReferenceTime
                }
                if(tbi.RepresentativePoint != nil) {
                objectMap["RepresentativePoint"] = tbi.RepresentativePoint
                }
                return json.Marshal(objectMap)
        }

            // TimezoneByIDResult this object is returned from a successful Timezone By ID call
            type TimezoneByIDResult struct {
            autorest.Response `json:"-"`
            // Version - READ-ONLY; Version property
            Version *string `json:"Version,omitempty"`
            // ReferenceUtcTimestamp - READ-ONLY; Reference Utc Timestamp property
            ReferenceUtcTimestamp *date.Time `json:"ReferenceUtcTimestamp,omitempty"`
            TimeZones *[]TimezoneByID `json:"TimeZones,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TimezoneByIDResult.
        func (tbir TimezoneByIDResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tbir.TimeZones != nil) {
                objectMap["TimeZones"] = tbir.TimeZones
                }
                return json.Marshal(objectMap)
        }

            // TimezoneEnumWindow ...
            type TimezoneEnumWindow struct {
            // WindowsID - READ-ONLY; Windows Id property
            WindowsID *string `json:"WindowsId,omitempty"`
            // Territory - READ-ONLY; Territory property
            Territory *string `json:"Territory,omitempty"`
            // IanaIds - IanaIds array
            IanaIds *[]string `json:"IanaIds,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TimezoneEnumWindow.
        func (tew TimezoneEnumWindow)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tew.IanaIds != nil) {
                objectMap["IanaIds"] = tew.IanaIds
                }
                return json.Marshal(objectMap)
        }

            // TimezoneIanaVersionResult this object is returned from a successful Timezone IANA Version call
            type TimezoneIanaVersionResult struct {
            autorest.Response `json:"-"`
            // Version - READ-ONLY; Version property
            Version *string `json:"version,omitempty"`
            }

            // TrafficFlowSegmentResult this object is returned from a successful Traffic Flow Segment call
            type TrafficFlowSegmentResult struct {
            autorest.Response `json:"-"`
            // FlowSegmentData - READ-ONLY; Flow Segment Data property
            FlowSegmentData *TrafficFlowSegmentResultFlowSegmentData `json:"flowSegmentData,omitempty"`
            }

            // TrafficFlowSegmentResultFlowSegmentData flow Segment Data property
            type TrafficFlowSegmentResultFlowSegmentData struct {
            // Frc - READ-ONLY; Functional Road Class. This indicates the road type:
            //   0: Motorway, freeway or other major road.
            //   1: Major road, less important than a motorway.
            //   2: Other major road.
            //   3: Secondary road.
            //   4: Local connecting road.
            //   5: Local road of high importance.
            //   6: Local road.
            Frc *string `json:"frc,omitempty"`
            // CurrentSpeed - READ-ONLY; The current average speed at the selected point, in the units requested. This is calculated from the currentTravelTime and the length of the selected segment.
            CurrentSpeed *int32 `json:"currentSpeed,omitempty"`
            // FreeFlowSpeed - READ-ONLY; The free flow speed expected under ideal conditions, expressed in the units requested. This is related to the freeFlowTravelTime.
            FreeFlowSpeed *int32 `json:"freeFlowSpeed,omitempty"`
            // CurrentTravelTime - READ-ONLY; Current travel time in seconds based on fused real-time measurements between the defined locations in the specified direction.
            CurrentTravelTime *int32 `json:"currentTravelTime,omitempty"`
            // FreeFlowTravelTime - READ-ONLY; The travel time in seconds which would be expected under ideal free flow conditions.
            FreeFlowTravelTime *int32 `json:"freeFlowTravelTime,omitempty"`
            // Confidence - READ-ONLY; The confidence is a measure of the quality of the provided travel time and speed. A value of 1 means full confidence, that the response contains the highest quality data.  Lower values indicate the degree that the response may vary from the actual conditions on the road. Any value greater than 0.6 means the information was based on real-time probe input. A value of 0.5 means the reported speed is based on historical info.   A value between 0.5 and 0.6 has a calculated weighted average between historical and live speeds.
            Confidence *float64 `json:"confidence,omitempty"`
            // Coordinates - Includes the coordinates describing the shape of the segment. Coordinates are shifted from the road depending on the zoom level to support high quality visualization in every scale.
            Coordinates *TrafficFlowSegmentResultFlowSegmentDataCoordinates `json:"coordinates,omitempty"`
            // Version - READ-ONLY; This indicates the software version that generated the response.
            Version *string `json:"@version,omitempty"`
            // Openlr - READ-ONLY; OpenLR code for segment
            Openlr *float64 `json:"openlr,omitempty"`
            }

        // MarshalJSON is the custom marshaler for TrafficFlowSegmentResultFlowSegmentData.
        func (tfsrSd TrafficFlowSegmentResultFlowSegmentData)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tfsrSd.Coordinates != nil) {
                objectMap["coordinates"] = tfsrSd.Coordinates
                }
                return json.Marshal(objectMap)
        }

            // TrafficFlowSegmentResultFlowSegmentDataCoordinates includes the coordinates describing the shape of the
            // segment. Coordinates are shifted from the road depending on the zoom level to support high quality
            // visualization in every scale.
            type TrafficFlowSegmentResultFlowSegmentDataCoordinates struct {
            // Coordinate - READ-ONLY; Coordinate array
            Coordinate *[]Coordinate `json:"coordinate,omitempty"`
            }

            // TrafficIncidentDetailResult this object is returned from a successful Traffic incident Detail call
            type TrafficIncidentDetailResult struct {
            autorest.Response `json:"-"`
            // Tm - READ-ONLY; Main response element
            Tm *TrafficIncidentDetailResultTm `json:"tm,omitempty"`
            }

            // TrafficIncidentDetailResultTm main response element
            type TrafficIncidentDetailResultTm struct {
            // ID - READ-ONLY; ID of the traffic incident
            ID *string `json:"@id,omitempty"`
            // Poi - READ-ONLY; A single traffic incident, or a cluster of traffic incidents
            Poi *[]TrafficIncidentPoi `json:"poi,omitempty"`
            }

            // TrafficIncidentPoi ...
            type TrafficIncidentPoi struct {
            // ID - READ-ONLY; ID of the traffic incident
            ID *string `json:"id,omitempty"`
            // P - READ-ONLY; The point where an icon of the cluster or raw incident should be drawn, expressed in the requested projection. This is affected by traffic style, zoom level and road type
            P *TrafficIncidentPoiP `json:"p,omitempty"`
            // Ic - READ-ONLY; The icon category associated with this incident. Values are numbers in the range 0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions, 4: Rain, 5: Ice, 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding, 12: Detour, 13: Cluster
            Ic *int32 `json:"ic,omitempty"`
            // Ty - READ-ONLY; The magnitude of delay associated with incident. These values correspond to incident colors in the traffic tiles
            Ty *int32 `json:"ty,omitempty"`
            // Cbl - READ-ONLY; Bottom left coordinate of the cluster in the projection of the request
            Cbl *TrafficIncidentPoiCbl `json:"cbl,omitempty"`
            // Ctr - READ-ONLY; Top right coordinate of the cluster in the projection of the request
            Ctr *TrafficIncidentPoiCtr `json:"ctr,omitempty"`
            // Cs - READ-ONLY; Cluster size: the number of incidents in the cluster
            Cs *int32 `json:"cs,omitempty"`
            // L - READ-ONLY; Length of the incident in meters
            L *int32 `json:"l,omitempty"`
            // R - READ-ONLY; The road number(s) affected by the incident. Multiple road numbers will delimited by slashes
            R *string `json:"r,omitempty"`
            // Dl - READ-ONLY; Delay caused by the incident in seconds (except in road closures)
            Dl *int32 `json:"dl,omitempty"`
            // T - READ-ONLY; To: the name of the intersection or location where the traffic due to the incident ends
            T *string `json:"t,omitempty"`
            // F - READ-ONLY; From: the name of the intersection or location where the traffic due to the incident starts
            F *string `json:"f,omitempty"`
            // D - READ-ONLY; Description of the incident in the language requested
            D *string `json:"d,omitempty"`
            // C - READ-ONLY; Cause of the incident, where available, in the language requested
            C *string `json:"c,omitempty"`
            }

            // TrafficIncidentPoiCbl bottom left coordinate of the cluster in the projection of the request
            type TrafficIncidentPoiCbl struct {
            // X - READ-ONLY; x coordinate
            X *float64 `json:"x,omitempty"`
            // Y - READ-ONLY; y coordinate
            Y *float64 `json:"y,omitempty"`
            }

            // TrafficIncidentPoiCtr top right coordinate of the cluster in the projection of the request
            type TrafficIncidentPoiCtr struct {
            // X - READ-ONLY; x coordinate
            X *float64 `json:"x,omitempty"`
            // Y - READ-ONLY; y coordinate
            Y *float64 `json:"y,omitempty"`
            }

            // TrafficIncidentPoiP the point where an icon of the cluster or raw incident should be drawn, expressed in
            // the requested projection. This is affected by traffic style, zoom level and road type
            type TrafficIncidentPoiP struct {
            // X - READ-ONLY; x coordinate
            X *float64 `json:"x,omitempty"`
            // Y - READ-ONLY; y coordinate
            Y *float64 `json:"y,omitempty"`
            }

            // TrafficIncidentTileResult this object is returned from a successful Traffic Incident Tile call
            type TrafficIncidentTileResult struct {
            autorest.Response `json:"-"`
            // Image - READ-ONLY; Image property
            Image *string `json:"image,omitempty"`
            }

            // TrafficIncidentViewportResult this object is returned from a successful Traffic Incident Viewport call
            type TrafficIncidentViewportResult struct {
            autorest.Response `json:"-"`
            // ViewpResp - READ-ONLY; Viewport Response object
            ViewpResp *TrafficIncidentViewportResultViewpResp `json:"viewpResp,omitempty"`
            }

            // TrafficIncidentViewportResultViewpResp viewport Response object
            type TrafficIncidentViewportResultViewpResp struct {
            // TrafficState - READ-ONLY; Traffic State array
            TrafficState *TrafficIncidentViewportResultViewpRespTrafficState `json:"trafficState,omitempty"`
            // CopyrightIds - READ-ONLY; Copyright Ids property
            CopyrightIds *string `json:"copyrightIds,omitempty"`
            // Version - READ-ONLY; @Version property
            Version *string `json:"@version,omitempty"`
            // MapsProperty - READ-ONLY; @maps property
            MapsProperty *string `json:"@maps,omitempty"`
            }

            // TrafficIncidentViewportResultViewpRespTrafficState traffic State array
            type TrafficIncidentViewportResultViewpRespTrafficState struct {
            // TrafficAge - READ-ONLY; @Traffic Age property
            TrafficAge *int32 `json:"@trafficAge,omitempty"`
            // TrafficModelID - READ-ONLY; @Traffic Model Id property
            TrafficModelID *string `json:"@trafficModelId,omitempty"`
            }

            // TransitItineraryResponse this object is returned from a successful Get Transit Itinerary call
            type TransitItineraryResponse struct {
            autorest.Response `json:"-"`
            // DepartureTime - The date and time of departure from the origin point in ISO 8601 format, e.g. 1996-12-19T16:39:57-08:00.
            DepartureTime *string `json:"departureTime,omitempty"`
            // ArrivalTime - The date and time of arrival at the destination point in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
            ArrivalTime *string `json:"arrivalTime,omitempty"`
            Legs *[]Leg `json:"legs,omitempty"`
            // ItineraryFare - Itinerary level transit fare information. Returned only if fare information is available for the entire itinerary. [Get Metro Area Info API](https://aka.ms/AzureMapsMobilityMetroAreaInfo) can be requested to confirm if fare information is available in the metro area.
            ItineraryFare *ItineraryFare `json:"itineraryFare,omitempty"`
            }

            // TransitLineInfoResponse this object is returned from a successful Transit Line Info call.
            type TransitLineInfoResponse struct {
            autorest.Response `json:"-"`
            // LineGroup - Groups together all lines that are logically part of the same group. Typically contains 2 lines having the same agency and line, one going from A to B, and the other from B to A.
            LineGroup *LineGroup `json:"lineGroup,omitempty"`
            // Lines - The line group’s basic info and list of the lines.
            Lines *[]Line `json:"lines,omitempty"`
            // Stops - List of stops the line group goes through.
            Stops *[]Stop `json:"stops,omitempty"`
            // Patterns - List of patterns this group is comprised of. A pattern consists of a stop sequence and shape per a line in GeoJSON format.
            Patterns *[]Pattern `json:"patterns,omitempty"`
            // Schedule - Line schedule for the current 24h. May be null in case no schedule exists for the current time.
            Schedule *LineArrival `json:"schedule,omitempty"`
            }

            // TransitObjectResult ...
            type TransitObjectResult struct {
            // ID - The unique identifier (stopID) for the returned public transit stop. When referring to public transit stops over time, it is recommended to use `stopId` since it will not change, as long as the physical stop exists.
            ID *string `json:"id,omitempty"`
            // Type - The type of object found as a result of the query.
            Type *string `json:"type,omitempty"`
            // ObjectDetails - The object specific details.
            ObjectDetails interface{} `json:"objectDetails,omitempty"`
            // Position - The transit object's position.
            Position *Coordinate `json:"position,omitempty"`
            Viewport *ResultViewport `json:"viewport,omitempty"`
            }

            // TransitRouteResponse this object is returned from a successful Get Transit Stop Info call
            type TransitRouteResponse struct {
            autorest.Response `json:"-"`
            Results *[]ItineraryResult `json:"results,omitempty"`
            }

            // TransitStopInfoResponse this object is returned from a successful Get Transit Stop Info call
            type TransitStopInfoResponse struct {
            autorest.Response `json:"-"`
            Stop *Stop `json:"stop,omitempty"`
            Lines *[]Line `json:"lines,omitempty"`
            LineGroups *[]LineGroup `json:"lineGroups,omitempty"`
            Alerts *[]Alert `json:"alerts,omitempty"`
            }

            // TransitTypeResult ...
            type TransitTypeResult struct {
            // TransitType - Supported public transit type. Returned if specified in the request. Possible values include: 'TransitTypeBus', 'TransitTypeCableCar', 'TransitTypeFerry', 'TransitTypeFunicular', 'TransitTypeGondola', 'TransitTypeRail', 'TransitTypeTram', 'TransitTypeSubway'
            TransitType TransitType `json:"transitType,omitempty"`
            // CaptionOverride - For metro areas in which local name is different than the GTFS supported transit type, original name is returned.
            CaptionOverride *string `json:"captionOverride,omitempty"`
            }

            // UploadDataAcceptedResponse the response model for the spatial data upload API. Returns the current
            // status and a status URI.
            type UploadDataAcceptedResponse struct {
            // Status - READ-ONLY; Current status of the long running upload operation.
            Status *string `json:"status,omitempty"`
            }

            // UploadDataResponse the response model for the spatial data upload API. Returns a unique data id (udid)
            // for the uploaded content.
            type UploadDataResponse struct {
            // Udid - READ-ONLY; A unique data id (udid) for the uploaded content.
            Udid *string `json:"udid,omitempty"`
            }

            // VersionMaps ...
            type VersionMaps struct {
            // Version - version number of the dataset
            Version *string `json:"version,omitempty"`
            // RevisionTimestamp - timestamp of the revision
            RevisionTimestamp *string `json:"revisionTimestamp,omitempty"`
            Links *[]Link `json:"links,omitempty"`
            }

            // Waypoint ...
            type Waypoint struct {
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            // ShortPhrase - A displayable short phrase describing the forecasted conditions and precipitation intensity/type.
            ShortPhrase *string `json:"shortPhrase,omitempty"`
            // IsDayTime - Indicates the time of the day. True indicates 'day',', false indicates 'night.
            IsDayTime *bool `json:"isDayTime,omitempty"`
            // CloudCover - Percent representing cloud cover.
            CloudCover *int32 `json:"cloudCover,omitempty"`
            Temperature *WeatherUnit `json:"temperature,omitempty"`
            Wind *Wind `json:"wind,omitempty"`
            WindGust *Wind `json:"windGust,omitempty"`
            Precipitation *WeatherAlongRoutePrecipitation `json:"precipitation,omitempty"`
            // LightningCount - Estimation of thunderstorm intensity on an open scale. A value of 0 means there is no thunderstorm; values of 1 and higher mean there is a thunderstorm in increasing intensity.
            LightningCount *int32 `json:"lightningCount,omitempty"`
            // SunGlare - A rating that indicates how blinding the sun is for the driver.
            SunGlare *SunGlare `json:"sunGlare,omitempty"`
            Hazards *Hazards `json:"hazards,omitempty"`
            Notifications *[]Notification `json:"notifications,omitempty"`
            }

            // WeatherAlongRoutePrecipitation ...
            type WeatherAlongRoutePrecipitation struct {
            // Dbz - The forecasted precipitation intensity in dBZ (decibels relative to Z) from 0.0 to 100.0.
            Dbz *float64 `json:"dbz,omitempty"`
            // Type - Precipitation type. If precipitation should occur, the type that it will be: "RAIN," "HAIL," "SNOW," "ICE," or "MIX."
            Type *string `json:"type,omitempty"`
            }

            // WeatherAlongRouteResponse this object is returned from a successful Weather Along Route.
            type WeatherAlongRouteResponse struct {
            autorest.Response `json:"-"`
            Summary *WeatherAlongRouteSummary `json:"summary,omitempty"`
            // Waypoints - Data for each waypoint returned in the same order as specified in the request.
            Waypoints *[]Waypoint `json:"waypoints,omitempty"`
            }

            // WeatherAlongRouteSummary ...
            type WeatherAlongRouteSummary struct {
            // IconCode - Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            IconCode *int32 `json:"iconCode,omitempty"`
            Hazards *Hazards `json:"hazards,omitempty"`
            }

            // WeatherUnit ...
            type WeatherUnit struct {
            // Value - Rounded value.
            Value *float64 `json:"value,omitempty"`
            // Unit - Type of unit for the returned value.
            Unit *string `json:"unit,omitempty"`
            // UnitType - Numeric ID value associated with the type of unit being displayed. Can be used for unit translation. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            UnitType *int32 `json:"unitType,omitempty"`
            }

            // WeatherUnitRange returned temperature values.
            type WeatherUnitRange struct {
            // Minimum - Minimum temperature for the time period.
            Minimum *WeatherUnit `json:"minimum,omitempty"`
            // Maximum - Maximum temperature for the time period
            Maximum *WeatherUnit `json:"maximum,omitempty"`
            }

            // Wind wind details being returned including speed and direction.
            type Wind struct {
            // Direction - Wind direction
            Direction *WindDirection `json:"direction,omitempty"`
            // Speed - Speed of the wind in specified unit.
            Speed *WindSpeed `json:"speed,omitempty"`
            }

            // WindDirection wind direction
            type WindDirection struct {
            // Degrees - Wind direction in Azimuth degrees,  starting at true North and continuing in clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees. Possible values 0-359.
            Degrees *int32 `json:"degrees,omitempty"`
            // LocalizedDescription - Direction abbreviation in the specified language.
            LocalizedDescription *string `json:"localizedDescription,omitempty"`
            }

            // WindSpeed speed of wind in specified unit.
            type WindSpeed struct {
            // Value - Rounded value of the speed.
            Value *float64 `json:"value,omitempty"`
            // Unit - Type of unit for the speed value.
            Unit *string `json:"unit,omitempty"`
            // UnitType - Numeric ID value associated with the type of unit being displayed. Can be used for unit translation. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
            UnitType *int32 `json:"unitType,omitempty"`
            }

