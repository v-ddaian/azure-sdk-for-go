package maps

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// SpatialClient is the client for the Spatial methods of the Maps service.
type SpatialClient struct {
    BaseClient
}
// NewSpatialClient creates an instance of the SpatialClient client.
func NewSpatialClient(subscriptionKey string, xMsClientID string) SpatialClient {
    return NewSpatialClientWithBaseURI(DefaultBaseURI, subscriptionKey, xMsClientID)
}

// NewSpatialClientWithBaseURI creates an instance of the SpatialClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
    func NewSpatialClientWithBaseURI(baseURI string, subscriptionKey string, xMsClientID string) SpatialClient {
        return SpatialClient{ NewWithBaseURI(baseURI, subscriptionKey, xMsClientID)}
    }

// GetBuffer **Applies to**: S1 pricing tier.
//
// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the
// input. The buffer could be either on the outside or the inside of the provided Feature, depending on the distance
// provided in the input. There must be either one distance provided per Feature in the FeatureCollection  input, or if
// only one distance is provided, then that distance is applied to every Feature in the collection. The positive (or
// negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry with a circle of
// radius equal to the absolute value of the buffer distance. The buffer API always returns a polygonal result. The
// negative or zero-distance buffer of lines and points is always an empty polygon. The input features are provided by
// a GeoJSON file which is uploaded via [Data Upload
// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON
// file may contain a collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString.
// GeometryCollection will be ignored if provided.
//
// To test this API, you can upload the sample data from [Post Buffer
// API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples) examples(Request Body without
// distances array) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
// replace the [udid] from the [sample request
// below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples) with the udid returned by Data
// Upload API.
    // Parameters:
        // udid - the unique id returned from [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON
        // FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for
        // details. All the feature's properties should contain `geometryId`, which is used for identifying the
        // geometry and is case-sensitive.
        // distances - the list of distances (one per feature or one for all features), delimited by semicolons. For
        // example, 12.34;-56.78. Positive distance will generate a buffer outside of the feature, whereas negative
        // distance will generate a buffer inside of the feature. If the negative distance larger than the geometry
        // itself, an empty polygon will be returned.
func (client SpatialClient) GetBuffer(ctx context.Context, udid string, distances string) (result BufferResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.GetBuffer")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetBufferPreparer(ctx, udid, distances)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetBuffer", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetBufferSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetBuffer", resp, "Failure sending request")
        return
        }

        result, err = client.GetBufferResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetBuffer", resp, "Failure responding to request")
        return
        }

    return
}

    // GetBufferPreparer prepares the GetBuffer request.
    func (client SpatialClient) GetBufferPreparer(ctx context.Context, udid string, distances string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "distances": autorest.Encode("query",distances),
    "udid": autorest.Encode("query",udid),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/buffer/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetBufferSender sends the GetBuffer request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) GetBufferSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetBufferResponder handles the response to the GetBuffer request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) GetBufferResponder(resp *http.Response) (result BufferResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetClosestPoint **Applies to**: S1 pricing tier.
//
// This API returns the closest point between a base point and a given set of points in the user uploaded data set
// identified by udid. The set of target points is provided by a GeoJSON file which is uploaded via [Data Upload
// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON
// file may only contain a collection of Point geometry. MultiPoint or other geometries will be ignored if provided.
// The maximum number of points accepted is 100,000. The algorithm does not take into account routing or traffic.
// Information returned includes closest point latitude, longitude, and distance in meters from the closest point.
//
// To test this API, you can upload the sample data from [Post Closest Point
// API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples) examples(Request Body) via
// [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the
// [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples) with the
// udid returned by Data Upload API.
    // Parameters:
        // udid - the unique id returned from [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON
        // FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for
        // details. All the feature's properties should contain `geometryId`, which is used for identifying the
        // geometry and is case-sensitive.
        // lat - the base point latitude of the location being passed.  Example: 47.622942.
        // lon - the base point longitude of the location being passed.  Example: -122.316456.
        // numberOfClosestPoints - the number of closest points expected from response. Default: 1, minimum: 1 and
        // maximum: 50
func (client SpatialClient) GetClosestPoint(ctx context.Context, udid string, lat float64, lon float64, numberOfClosestPoints *int32) (result GetClosestPointResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.GetClosestPoint")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetClosestPointPreparer(ctx, udid, lat, lon, numberOfClosestPoints)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetClosestPoint", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetClosestPointSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetClosestPoint", resp, "Failure sending request")
        return
        }

        result, err = client.GetClosestPointResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetClosestPoint", resp, "Failure responding to request")
        return
        }

    return
}

    // GetClosestPointPreparer prepares the GetClosestPoint request.
    func (client SpatialClient) GetClosestPointPreparer(ctx context.Context, udid string, lat float64, lon float64, numberOfClosestPoints *int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    "udid": autorest.Encode("query",udid),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if numberOfClosestPoints != nil {
        queryParameters["numberOfClosestPoints"] = autorest.Encode("query",*numberOfClosestPoints)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/closestPoint/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetClosestPointSender sends the GetClosestPoint request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) GetClosestPointSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetClosestPointResponder handles the response to the GetClosestPoint request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) GetClosestPointResponder(resp *http.Response) (result GetClosestPointResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetGeofence **Search Geofence Get API**
//
// **Applies to:** S1 Pricing tier.
//
// The Geofence Get API allows you to retrieve the proximity of a coordinate to a
// geofence that has been uploaded to the Data service. You can use the
// [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) to upload
// a geofence or set of fences. See [Geofencing GeoJSON
// data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson)
// for more details on the geofence data format. To query the proximity of a coordinate, you supply the location of the
// object you are tracking as well
// as the ID for the fence or set of fences, and the response will contain information about
// the distance from the outer edge of the geofence. A negative value signifies that the
// coordinate is inside of the fence while a positive value means that it is outside of the
// fence.<br><br>This API can be used for a variety of scenarios that include things like asset
// tracking, fleet management, or setting up alerts for moving objects.
//
// The API supports [integration with Event
// Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration). The isAsync parameter is used
// to enable integration with Event Grid (disabled by default).
// To test this API, you can upload the sample data from Post Geofence API examples(Request Body) via Data Upload API
// and replace the [udid] from the sample request below with the udid returned by Data Upload API.
//
//
// ### Geofencing InnerError code
//
// In geofencing response error contract, `innererror` is  an object containing service specific information about the
// error. `code` is a property in `innererror` which can map to a specific geofencing error type. The table belows
// shows the code mapping between all the known client error type to the corresponding geofencing error `message`.
//
// innererror.code | error.message
// ---------------------------- | --------------------------------------
// NullDeviceId  | Device Id should not be null.
// NullUdid	  | Udid should not be null.
// UdidWrongFormat| Udid should be acquired from user data ingestion API.
// InvalidUserTime| Usertime is invalid.
// InvalidSearchBuffer| Searchbuffer is invalid.
// InvalidSearchRange| The value range of searchbuffer should be from 0 to 500 meters.
// InvalidLatLon| Lat and/or lon parameters are invalid.
// InvalidIsAsyncValue| The IsAsync parameter is invalid.
// InvalidModeValue| The mode parameter invalid.
// InvalidJson| Geofencing data is not a valid json file.
// NotSupportedGeoJson| Geofencing data can't be read as a Feature or FeatureCollections.
// InvalidGeoJson| Geofencing data is invalid.
// NoUserDataWithAccountOrSubscription| Can't find user geofencing data with provided account-id and/or
// subscription-id.
// NoUserDataWithUdid|	Can't find user geofencing data with provided udId.
    // Parameters:
        // deviceID - ID of the device
        // udID - the unique id returned from [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON
        // FeatureCollection object. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for
        // details. All the feature's  properties should contain `geometryId`, which is used for identifying the
        // geometry and is case-sensitive.
        // lat - the latitude of the location being passed.  Example: 48.36.
        // lon - the longitude of the location being passed.  Example: -124.63.
        // z - the sea level in meter of the location being passed. If this parameter is presented, 2D extrusion is
        // used. Example: 200.
        // userTime - the user request time. If not presented in the request, the default value is DateTime.Now.
        // searchBuffer - the radius of the buffer around the geofence in meters that defines how far to search inside
        // and outside the border of the fence against the coordinate that was provided when calculating the result.
        // The minimum value is 0, and the maximum is 500.  The default value is 50.
        // isAsync - if true, the request will use async event mechanism; if false, the request will be synchronized
        // and do not trigger any event. The default value is false.
        // mode - mode of the geofencing async event mechanism.
func (client SpatialClient) GetGeofence(ctx context.Context, deviceID string, udID string, lat float64, lon float64, z *float64, userTime string, searchBuffer *float64, isAsync *bool, mode GeofenceMode) (result GeofenceResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.GetGeofence")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: searchBuffer,
         Constraints: []validation.Constraint{	{Target: "searchBuffer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "searchBuffer", Name: validation.InclusiveMaximum, Rule: float64(500), Chain: nil },
        	{Target: "searchBuffer", Name: validation.InclusiveMinimum, Rule: float64(0), Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("maps.SpatialClient", "GetGeofence", err.Error())
        }

        req, err := client.GetGeofencePreparer(ctx, deviceID, udID, lat, lon, z, userTime, searchBuffer, isAsync, mode)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetGeofence", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetGeofenceSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetGeofence", resp, "Failure sending request")
        return
        }

        result, err = client.GetGeofenceResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetGeofence", resp, "Failure responding to request")
        return
        }

    return
}

    // GetGeofencePreparer prepares the GetGeofence request.
    func (client SpatialClient) GetGeofencePreparer(ctx context.Context, deviceID string, udID string, lat float64, lon float64, z *float64, userTime string, searchBuffer *float64, isAsync *bool, mode GeofenceMode) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "deviceId": autorest.Encode("query",deviceID),
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    "udId": autorest.Encode("query",udID),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if z != nil {
        queryParameters["z"] = autorest.Encode("query",*z)
        }
        if len(userTime) > 0 {
        queryParameters["userTime"] = autorest.Encode("query",userTime)
        }
        if searchBuffer != nil {
        queryParameters["searchBuffer"] = autorest.Encode("query",*searchBuffer)
            } else {
            queryParameters["searchBuffer"] = autorest.Encode("query",50)
        }
        if isAsync != nil {
        queryParameters["isAsync"] = autorest.Encode("query",*isAsync)
            } else {
            queryParameters["isAsync"] = autorest.Encode("query",false)
        }
        if len(string(mode)) > 0 {
        queryParameters["mode"] = autorest.Encode("query",mode)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/geofence/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGeofenceSender sends the GetGeofence request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) GetGeofenceSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetGeofenceResponder handles the response to the GetGeofence request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) GetGeofenceResponder(resp *http.Response) (result GeofenceResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetGreatCircleDistance **Applies to**: S1 pricing tier.
//
// This API will return the great-circle or shortest distance between two points on the surface of a sphere, measured
// along the surface of the sphere.  This differs from calculating a straight line through the sphere's interior. This
// method is helpful for estimating travel distances for airplanes by calculating the shortest distance between
// airports.
    // Parameters:
        // query - the Coordinates through which the distance is calculated, delimited by a colon. Two coordinates are
        // required.  The first one is the source point coordinate and the last is the target point coordinate. For
        // example, 47.622942,122.316456:57.673988,127.121513
func (client SpatialClient) GetGreatCircleDistance(ctx context.Context, query string) (result GreatCircleDistanceResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.GetGreatCircleDistance")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetGreatCircleDistancePreparer(ctx, query)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetGreatCircleDistance", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetGreatCircleDistanceSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetGreatCircleDistance", resp, "Failure sending request")
        return
        }

        result, err = client.GetGreatCircleDistanceResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetGreatCircleDistance", resp, "Failure responding to request")
        return
        }

    return
}

    // GetGreatCircleDistancePreparer prepares the GetGreatCircleDistance request.
    func (client SpatialClient) GetGreatCircleDistancePreparer(ctx context.Context, query string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "query": autorest.Encode("query",query),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/greatCircleDistance/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGreatCircleDistanceSender sends the GetGreatCircleDistance request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) GetGreatCircleDistanceSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetGreatCircleDistanceResponder handles the response to the GetGreatCircleDistance request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) GetGreatCircleDistanceResponder(resp *http.Response) (result GreatCircleDistanceResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetPointInPolygon **Applies to**: S1 pricing tier.
//
// This API returns a boolean value indicating whether a point is inside a set of polygons. The set of polygons is
// provided by a GeoJSON file which is uploaded via [Data Upload
// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON
// file may contain Polygon and MultiPolygon geometries, other geometries will be ignored if provided. If the point is
// inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value
// returned is false. When the point is inside multiple polygons, the result will give intersecting geometries section
// to show all valid geometries(referenced by geometryId) in user data. The maximum number of vertices accepted to form
// a Polygon is 10,000.
//
//
// To test this API, you can upload the sample data from [Post Point In Polygon
// API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples) examples(Request Body) via
// [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the
// [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples) with the
// udid returned by Data Upload API.
    // Parameters:
        // udid - the unique id returned from [Data Upload
        // API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON
        // FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for
        // details. All the feature's properties should contain `geometryId`, which is used for identifying the
        // geometry and is case-sensitive.
        // lat - the base point latitude of the location being passed.  Example: 47.622942.
        // lon - the base point longitude of the location being passed.  Example: -122.316456.
func (client SpatialClient) GetPointInPolygon(ctx context.Context, udid string, lat float64, lon float64) (result GetPointInPolygonResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.GetPointInPolygon")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetPointInPolygonPreparer(ctx, udid, lat, lon)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetPointInPolygon", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetPointInPolygonSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetPointInPolygon", resp, "Failure sending request")
        return
        }

        result, err = client.GetPointInPolygonResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "GetPointInPolygon", resp, "Failure responding to request")
        return
        }

    return
}

    // GetPointInPolygonPreparer prepares the GetPointInPolygon request.
    func (client SpatialClient) GetPointInPolygonPreparer(ctx context.Context, udid string, lat float64, lon float64) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    "udid": autorest.Encode("query",udid),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/pointInPolygon/{format}",pathParameters),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetPointInPolygonSender sends the GetPointInPolygon request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) GetPointInPolygonSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPointInPolygonResponder handles the response to the GetPointInPolygon request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) GetPointInPolygonResponder(resp *http.Response) (result GetPointInPolygonResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostBuffer **Applies to**: S1 pricing tier.
//
// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the
// input. The buffer could be either on the outside or the inside of the provided Feature, depending on the distance
// provided in the input. There must be either one distance provided per Feature in the FeatureCollection  input, or if
// only one distance is provided, then that distance is applied to every Feature in the collection. The positive (or
// negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry with a circle of
// radius equal to the absolute value of the buffer distance. The buffer API always returns a polygonal result. The
// negative or zero-distance buffer of lines and points is always an empty polygon. The input may contain a collection
// of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if
// provided.
    // Parameters:
        // bufferRequestBody - the FeatureCollection and the list of distances (one per feature or one for all
        // features).
func (client SpatialClient) PostBuffer(ctx context.Context, bufferRequestBody BufferRequestBody) (result BufferResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.PostBuffer")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: bufferRequestBody,
         Constraints: []validation.Constraint{	{Target: "bufferRequestBody.Geometries", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "bufferRequestBody.Geometries.Type", Name: validation.Null, Rule: true, Chain: nil },
        	{Target: "bufferRequestBody.Geometries.Features", Name: validation.Null, Rule: true, Chain: nil },
        }}}}}); err != nil {
        return result, validation.NewError("maps.SpatialClient", "PostBuffer", err.Error())
        }

        req, err := client.PostBufferPreparer(ctx, bufferRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostBuffer", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostBufferSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostBuffer", resp, "Failure sending request")
        return
        }

        result, err = client.PostBufferResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostBuffer", resp, "Failure responding to request")
        return
        }

    return
}

    // PostBufferPreparer prepares the PostBuffer request.
    func (client SpatialClient) PostBufferPreparer(ctx context.Context, bufferRequestBody BufferRequestBody) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/buffer/{format}",pathParameters),
autorest.WithJSON(bufferRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostBufferSender sends the PostBuffer request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) PostBufferSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostBufferResponder handles the response to the PostBuffer request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) PostBufferResponder(resp *http.Response) (result BufferResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostClosestPoint **Applies to**: S1 pricing tier.
//
// This API returns the closest point between a base point and a given set of target points. The set of target points
// is provided by user data in post request body. The user data may only contain a collection of Point geometry.
// MultiPoint or other geometries will be ignored if provided. The algorithm does not take into account routing or
// traffic. The maximum number of points accepted is 100,000. Information returned includes closest point latitude,
// longitude, and distance in meters from the closest point.
    // Parameters:
        // lat - the base point latitude of the location being passed.  Example: 47.622942.
        // lon - the base point longitude of the location being passed.  Example: -122.316456.
        // closestPointRequestBody - the FeatureCollection of Point geometries from which closest point to source point
        // should be determined. All the feature's properties should contain `geometryId`, which is used for
        // identifying the geometry and is case-sensitive.
        // numberOfClosestPoints - the number of closest points expected from response. Default: 1, minimum: 1 and
        // maximum: 50
func (client SpatialClient) PostClosestPoint(ctx context.Context, lat float64, lon float64, closestPointRequestBody GeoJSONFeatureCollection, numberOfClosestPoints *int32) (result PostClosestPointResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.PostClosestPoint")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: closestPointRequestBody,
         Constraints: []validation.Constraint{	{Target: "closestPointRequestBody.Type", Name: validation.Null, Rule: true, Chain: nil },
        	{Target: "closestPointRequestBody.Features", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("maps.SpatialClient", "PostClosestPoint", err.Error())
        }

        req, err := client.PostClosestPointPreparer(ctx, lat, lon, closestPointRequestBody, numberOfClosestPoints)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostClosestPoint", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostClosestPointSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostClosestPoint", resp, "Failure sending request")
        return
        }

        result, err = client.PostClosestPointResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostClosestPoint", resp, "Failure responding to request")
        return
        }

    return
}

    // PostClosestPointPreparer prepares the PostClosestPoint request.
    func (client SpatialClient) PostClosestPointPreparer(ctx context.Context, lat float64, lon float64, closestPointRequestBody GeoJSONFeatureCollection, numberOfClosestPoints *int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if numberOfClosestPoints != nil {
        queryParameters["numberOfClosestPoints"] = autorest.Encode("query",*numberOfClosestPoints)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/closestPoint/{format}",pathParameters),
autorest.WithJSON(closestPointRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostClosestPointSender sends the PostClosestPoint request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) PostClosestPointSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostClosestPointResponder handles the response to the PostClosestPoint request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) PostClosestPointResponder(resp *http.Response) (result PostClosestPointResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostGeofence **Search Geofence Post API**
// **Applies to:** S1 Pricing tier.
// The Geofence Post API allows you to retrieve the proximity of a coordinate to a  provided geofence or set of fences.
// With POST call, you do not have to upload the fence data in advance, instead you supply the location of the object
// you are tracking in query parameters as well as the fence or set of fences data in post request body. See
// [Geofencing GeoJSON data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson) for more details on
// the geofence data format. The response will contain information about the distance from the outer edge of the
// geofence. A negative value signifies that the  coordinate is inside of the fence while a positive value means that
// it is outside of the fence.<br><br>This API can be used for a variety of scenarios that include things like asset
// tracking, fleet management, or setting up alerts for moving objects.
//
// The API supports [integration with Event
// Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration).  The isAsync parameter is used
// to enable integration with Event Grid (disabled by default).
    // Parameters:
        // deviceID - ID of the device
        // lat - the latitude of the location being passed.  Example: 48.36.
        // lon - the longitude of the location being passed.  Example: -124.63.
        // searchGeofenceRequestBody - the geofencing GeoJSON data.
        // z - the sea level in meter of the location being passed. If this parameter is presented, 2D extrusion
        // geofencing is applied. Example: 200.
        // userTime - the user request time. If not presented in the request, the default value is DateTime.UtcNow.
        // searchBuffer - the radius of the buffer around the geofence in meters that defines how far to search inside
        // and outside the border of the fence against the coordinate that was provided when calculating the result.
        // The minimum value is 0, and the maximum is 500.  The default value is 50.
        // isAsync - if true, the request will use async event mechanism; if false, the request will be synchronized
        // and do not trigger any event. The default value is false.
        // mode - mode of the geofencing async event mechanism.
func (client SpatialClient) PostGeofence(ctx context.Context, deviceID string, lat float64, lon float64, searchGeofenceRequestBody GeoJSONFeatureCollection, z *float64, userTime string, searchBuffer *float64, isAsync *bool, mode GeofenceMode) (result GeofenceResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.PostGeofence")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: searchBuffer,
         Constraints: []validation.Constraint{	{Target: "searchBuffer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "searchBuffer", Name: validation.InclusiveMaximum, Rule: float64(500), Chain: nil },
        	{Target: "searchBuffer", Name: validation.InclusiveMinimum, Rule: float64(0), Chain: nil },
        }}}},
        { TargetValue: searchGeofenceRequestBody,
         Constraints: []validation.Constraint{	{Target: "searchGeofenceRequestBody.Type", Name: validation.Null, Rule: true, Chain: nil },
        	{Target: "searchGeofenceRequestBody.Features", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("maps.SpatialClient", "PostGeofence", err.Error())
        }

        req, err := client.PostGeofencePreparer(ctx, deviceID, lat, lon, searchGeofenceRequestBody, z, userTime, searchBuffer, isAsync, mode)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostGeofence", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostGeofenceSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostGeofence", resp, "Failure sending request")
        return
        }

        result, err = client.PostGeofenceResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostGeofence", resp, "Failure responding to request")
        return
        }

    return
}

    // PostGeofencePreparer prepares the PostGeofence request.
    func (client SpatialClient) PostGeofencePreparer(ctx context.Context, deviceID string, lat float64, lon float64, searchGeofenceRequestBody GeoJSONFeatureCollection, z *float64, userTime string, searchBuffer *float64, isAsync *bool, mode GeofenceMode) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "deviceId": autorest.Encode("query",deviceID),
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }
        if z != nil {
        queryParameters["z"] = autorest.Encode("query",*z)
        }
        if len(userTime) > 0 {
        queryParameters["userTime"] = autorest.Encode("query",userTime)
        }
        if searchBuffer != nil {
        queryParameters["searchBuffer"] = autorest.Encode("query",*searchBuffer)
            } else {
            queryParameters["searchBuffer"] = autorest.Encode("query",50)
        }
        if isAsync != nil {
        queryParameters["isAsync"] = autorest.Encode("query",*isAsync)
            } else {
            queryParameters["isAsync"] = autorest.Encode("query",false)
        }
        if len(string(mode)) > 0 {
        queryParameters["mode"] = autorest.Encode("query",mode)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/geofence/{format}",pathParameters),
autorest.WithJSON(searchGeofenceRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostGeofenceSender sends the PostGeofence request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) PostGeofenceSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostGeofenceResponder handles the response to the PostGeofence request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) PostGeofenceResponder(resp *http.Response) (result GeofenceResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// PostPointInPolygon **Applies to**: S1 pricing tier.
//
// This API returns a boolean value indicating whether a point is inside a set of polygons. The user data may contain
// Polygon and MultiPolygon geometries, other geometries will be ignored if provided. If the point is inside or on the
// boundary of one of these polygons, the value returned is true. In all other cases, the value returned is false. When
// the point is inside multiple polygons, the result will give intersecting geometries section to show all valid
// geometries (referenced by geometryId) in user data. The maximum number of vertices accepted to form a Polygon is
// 10,000.
    // Parameters:
        // lat - the base point latitude of the location being passed.  Example: 47.622942.
        // lon - the base point longitude of the location being passed.  Example: -122.316456.
        // pointInPolygonRequestBody - a FeatureCollection with a set of Polygon/MultiPolygon geometries. The maximum
        // number of vertices accepted to form a Polygon is 10,000. All the feature's properties should contain
        // `geometryId`, which is used for identifying the geometry and is case-sensitive.
func (client SpatialClient) PostPointInPolygon(ctx context.Context, lat float64, lon float64, pointInPolygonRequestBody GeoJSONFeatureCollection) (result PostPointInPolygonResponse, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SpatialClient.PostPointInPolygon")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: pointInPolygonRequestBody,
         Constraints: []validation.Constraint{	{Target: "pointInPolygonRequestBody.Type", Name: validation.Null, Rule: true, Chain: nil },
        	{Target: "pointInPolygonRequestBody.Features", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("maps.SpatialClient", "PostPointInPolygon", err.Error())
        }

        req, err := client.PostPointInPolygonPreparer(ctx, lat, lon, pointInPolygonRequestBody)
    if err != nil {
    err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostPointInPolygon", nil , "Failure preparing request")
    return
    }

        resp, err := client.PostPointInPolygonSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostPointInPolygon", resp, "Failure sending request")
        return
        }

        result, err = client.PostPointInPolygonResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "maps.SpatialClient", "PostPointInPolygon", resp, "Failure responding to request")
        return
        }

    return
}

    // PostPointInPolygonPreparer prepares the PostPointInPolygon request.
    func (client SpatialClient) PostPointInPolygonPreparer(ctx context.Context, lat float64, lon float64, pointInPolygonRequestBody GeoJSONFeatureCollection) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "format": autorest.Encode("path", "json"),
        }

            const APIVersion = "1.0"
    queryParameters := map[string]interface{} {
    "api-version": APIVersion,
    "lat": autorest.Encode("query",lat),
    "lon": autorest.Encode("query",lon),
    }
        if len(client.SubscriptionKey) > 0 {
        queryParameters["subscription-key"] = autorest.Encode("query",client.SubscriptionKey)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithBaseURL(client.BaseURI),
autorest.WithPathParameters("/spatial/pointInPolygon/{format}",pathParameters),
autorest.WithJSON(pointInPolygonRequestBody),
autorest.WithQueryParameters(queryParameters))
        if len(client.XMsClientID) > 0 {
        preparer = autorest.DecoratePreparer(preparer,
        autorest.WithHeader("x-ms-client-id",autorest.String(client.XMsClientID)))
        }
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // PostPointInPolygonSender sends the PostPointInPolygon request. The method will close the
    // http.Response Body if it receives an error.
    func (client SpatialClient) PostPointInPolygonSender(req *http.Request) (*http.Response, error) {
                return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // PostPointInPolygonResponder handles the response to the PostPointInPolygon request. The method always
    // closes the http.Response Body.
    func (client SpatialClient) PostPointInPolygonResponder(resp *http.Response) (result PostPointInPolygonResponse, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

